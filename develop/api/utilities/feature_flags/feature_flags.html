<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.feature_flags.feature_flags API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.feature_flags.feature_flags</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from typing import Any, Dict, List, Optional, Union, cast

from ... import Logger
from ...shared.types import JSONType
from . import schema
from .base import StoreProvider
from .exceptions import ConfigurationStoreError
from .time_conditions import (
    compare_datetime_range,
    compare_days_of_week,
    compare_time_range,
)


class FeatureFlags:
    def __init__(self, store: StoreProvider, logger: Optional[Union[logging.Logger, Logger]] = None):
        &#34;&#34;&#34;Evaluates whether feature flags should be enabled based on a given context.

        It uses the provided store to fetch feature flag rules before evaluating them.

        Examples
        --------

        ```python
        from aws_lambda_powertools.utilities.feature_flags import FeatureFlags, AppConfigStore

        app_config = AppConfigStore(
            environment=&#34;test&#34;,
            application=&#34;powertools&#34;,
            name=&#34;test_conf_name&#34;,
            max_age=300,
            envelope=&#34;features&#34;
        )

        feature_flags: FeatureFlags = FeatureFlags(store=app_config)
        ```

        Parameters
        ----------
        store: StoreProvider
            Store to use to fetch feature flag schema configuration.
        logger: A logging object
            Used to log messages. If None is supplied, one will be created.
        &#34;&#34;&#34;
        self.store = store
        self.logger = logger or logging.getLogger(__name__)

    def _match_by_action(self, action: str, condition_value: Any, context_value: Any) -&gt; bool:
        mapping_by_action = {
            schema.RuleAction.EQUALS.value: lambda a, b: a == b,
            schema.RuleAction.NOT_EQUALS.value: lambda a, b: a != b,
            schema.RuleAction.KEY_GREATER_THAN_VALUE.value: lambda a, b: a &gt; b,
            schema.RuleAction.KEY_GREATER_THAN_OR_EQUAL_VALUE.value: lambda a, b: a &gt;= b,
            schema.RuleAction.KEY_LESS_THAN_VALUE.value: lambda a, b: a &lt; b,
            schema.RuleAction.KEY_LESS_THAN_OR_EQUAL_VALUE.value: lambda a, b: a &lt;= b,
            schema.RuleAction.STARTSWITH.value: lambda a, b: a.startswith(b),
            schema.RuleAction.ENDSWITH.value: lambda a, b: a.endswith(b),
            schema.RuleAction.IN.value: lambda a, b: a in b,
            schema.RuleAction.NOT_IN.value: lambda a, b: a not in b,
            schema.RuleAction.KEY_IN_VALUE.value: lambda a, b: a in b,
            schema.RuleAction.KEY_NOT_IN_VALUE.value: lambda a, b: a not in b,
            schema.RuleAction.VALUE_IN_KEY.value: lambda a, b: b in a,
            schema.RuleAction.VALUE_NOT_IN_KEY.value: lambda a, b: b not in a,
            schema.RuleAction.SCHEDULE_BETWEEN_TIME_RANGE.value: lambda a, b: compare_time_range(a, b),
            schema.RuleAction.SCHEDULE_BETWEEN_DATETIME_RANGE.value: lambda a, b: compare_datetime_range(a, b),
            schema.RuleAction.SCHEDULE_BETWEEN_DAYS_OF_WEEK.value: lambda a, b: compare_days_of_week(a, b),
        }

        try:
            func = mapping_by_action.get(action, lambda a, b: False)
            return func(context_value, condition_value)
        except Exception as exc:
            self.logger.debug(f&#34;caught exception while matching action: action={action}, exception={str(exc)}&#34;)
            return False

    def _evaluate_conditions(
        self, rule_name: str, feature_name: str, rule: Dict[str, Any], context: Dict[str, Any]
    ) -&gt; bool:
        &#34;&#34;&#34;Evaluates whether context matches conditions, return False otherwise&#34;&#34;&#34;
        rule_match_value = rule.get(schema.RULE_MATCH_VALUE)
        conditions = cast(List[Dict], rule.get(schema.CONDITIONS_KEY))

        if not conditions:
            self.logger.debug(
                f&#34;rule did not match, no conditions to match, rule_name={rule_name}, rule_value={rule_match_value}, &#34;
                f&#34;name={feature_name} &#34;
            )
            return False

        for condition in conditions:
            context_value = context.get(condition.get(schema.CONDITION_KEY, &#34;&#34;))
            cond_action = condition.get(schema.CONDITION_ACTION, &#34;&#34;)
            cond_value = condition.get(schema.CONDITION_VALUE)

            # time based rule actions have no user context. the context is the condition key
            if cond_action in (
                schema.RuleAction.SCHEDULE_BETWEEN_TIME_RANGE.value,
                schema.RuleAction.SCHEDULE_BETWEEN_DATETIME_RANGE.value,
                schema.RuleAction.SCHEDULE_BETWEEN_DAYS_OF_WEEK.value,
            ):
                context_value = condition.get(schema.CONDITION_KEY)  # e.g., CURRENT_TIME

            if not self._match_by_action(action=cond_action, condition_value=cond_value, context_value=context_value):
                self.logger.debug(
                    f&#34;rule did not match action, rule_name={rule_name}, rule_value={rule_match_value}, &#34;
                    f&#34;name={feature_name}, context_value={str(context_value)} &#34;
                )
                return False  # context doesn&#39;t match condition

        self.logger.debug(f&#34;rule matched, rule_name={rule_name}, rule_value={rule_match_value}, name={feature_name}&#34;)
        return True

    def _evaluate_rules(
        self,
        *,
        feature_name: str,
        context: Dict[str, Any],
        feat_default: Any,
        rules: Dict[str, Any],
        boolean_feature: bool,
    ) -&gt; bool:
        &#34;&#34;&#34;Evaluates whether context matches rules and conditions, otherwise return feature default&#34;&#34;&#34;
        for rule_name, rule in rules.items():
            rule_match_value = rule.get(schema.RULE_MATCH_VALUE)

            # Context might contain PII data; do not log its value
            self.logger.debug(
                f&#34;Evaluating rule matching, rule={rule_name}, feature={feature_name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
            )
            if self._evaluate_conditions(rule_name=rule_name, feature_name=feature_name, rule=rule, context=context):
                # Maintenance: Revisit before going GA.
                return bool(rule_match_value) if boolean_feature else rule_match_value

        # no rule matched, return default value of feature
        self.logger.debug(
            f&#34;no rule matched, returning feature default, default={str(feat_default)}, name={feature_name}, boolean_feature={boolean_feature}&#34;  # noqa: E501
        )
        return feat_default

    def get_configuration(self) -&gt; Dict:
        &#34;&#34;&#34;Get validated feature flag schema from configured store.

        Largely used to aid testing, since it&#39;s called by `evaluate` and `get_enabled_features` methods.

        Raises
        ------
        ConfigurationStoreError
            Any propagated error from store
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema

        Returns
        ------
        Dict[str, Dict]
            parsed JSON dictionary

            **Example**

        ```python
        {
            &#34;premium_features&#34;: {
                &#34;default&#34;: False,
                &#34;rules&#34;: {
                    &#34;customer tier equals premium&#34;: {
                        &#34;when_match&#34;: True,
                        &#34;conditions&#34;: [
                            {
                                &#34;action&#34;: &#34;EQUALS&#34;,
                                &#34;key&#34;: &#34;tier&#34;,
                                &#34;value&#34;: &#34;premium&#34;,
                            }
                        ],
                    }
                },
            },
            &#34;feature_two&#34;: {
                &#34;default&#34;: False
            }
        }
        ```
        &#34;&#34;&#34;
        # parse result conf as JSON, keep in cache for max age defined in store
        self.logger.debug(f&#34;Fetching schema from registered store, store={self.store}&#34;)
        config: Dict = self.store.get_configuration()
        validator = schema.SchemaValidator(schema=config, logger=self.logger)
        validator.validate()

        return config

    def evaluate(self, *, name: str, context: Optional[Dict[str, Any]] = None, default: JSONType) -&gt; JSONType:
        &#34;&#34;&#34;Evaluate whether a feature flag should be enabled according to stored schema and input context

        **Logic when evaluating a feature flag**

        1. Feature exists and a rule matches, returns when_match value
        2. Feature exists but has either no rules or no match, return feature default value
        3. Feature doesn&#39;t exist in stored schema, encountered an error when fetching -&gt; return default value provided

        Parameters
        ----------
        name: str
            feature name to evaluate
        context: Optional[Dict[str, Any]]
            Attributes that should be evaluated against the stored schema.

            for example: `{&#34;tenant_id&#34;: &#34;X&#34;, &#34;username&#34;: &#34;Y&#34;, &#34;region&#34;: &#34;Z&#34;}`
        default: JSONType
            default value if feature flag doesn&#39;t exist in the schema,
            or there has been an error when fetching the configuration from the store
            Can be boolean or any JSON values for non-boolean features.

        Returns
        ------
        JSONType
            whether feature should be enabled (bool flags) or JSON value when non-bool feature matches

        Raises
        ------
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema
        &#34;&#34;&#34;
        if context is None:
            context = {}

        try:
            features = self.get_configuration()
        except ConfigurationStoreError as err:
            self.logger.debug(f&#34;Failed to fetch feature flags from store, returning default provided, reason={err}&#34;)
            return default

        feature = features.get(name)
        if feature is None:
            self.logger.debug(f&#34;Feature not found; returning default provided, name={name}, default={default}&#34;)
            return default

        rules = feature.get(schema.RULES_KEY)
        feat_default = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
        # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
        # for non-boolean flags. It&#39;ll need minor implementation changes, docs changes, and maybe refactor
        # get_enabled_features. We can minimize breaking change, despite Beta label, by having a new
        # method `get_matching_features` returning Dict[feature_name, feature_value]
        boolean_feature = feature.get(
            schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
        )  # backwards compatibility, assume feature flag
        if not rules:
            self.logger.debug(
                f&#34;no rules found, returning feature default, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
            )
            # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
            # for non-boolean flags.
            return bool(feat_default) if boolean_feature else feat_default

        self.logger.debug(
            f&#34;looking for rule match, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
        )
        return self._evaluate_rules(
            feature_name=name, context=context, feat_default=feat_default, rules=rules, boolean_feature=boolean_feature
        )

    def get_enabled_features(self, *, context: Optional[Dict[str, Any]] = None) -&gt; List[str]:
        &#34;&#34;&#34;Get all enabled feature flags while also taking into account context
        (when a feature has defined rules)

        Parameters
        ----------
        context: Optional[Dict[str, Any]]
            dict of attributes that you would like to match the rules
            against, can be `{&#39;tenant_id: &#39;X&#39;, &#39;username&#39;:&#39; &#39;Y&#39;, &#39;region&#39;: &#39;Z&#39;}` etc.

        Returns
        ----------
        List[str]
            list of all feature names that either matches context or have True as default

            **Example**

        ```python
        [&#34;premium_features&#34;, &#34;my_feature_two&#34;, &#34;always_true_feature&#34;]
        ```

        Raises
        ------
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema
        &#34;&#34;&#34;
        if context is None:
            context = {}

        features_enabled: List[str] = []

        try:
            features: Dict[str, Any] = self.get_configuration()
        except ConfigurationStoreError as err:
            self.logger.debug(f&#34;Failed to fetch feature flags from store, returning empty list, reason={err}&#34;)
            return features_enabled

        self.logger.debug(&#34;Evaluating all features&#34;)
        for name, feature in features.items():
            rules = feature.get(schema.RULES_KEY, {})
            feature_default_value = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
            boolean_feature = feature.get(
                schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
            )  # backwards compatibility, assume feature flag

            if feature_default_value and not rules:
                self.logger.debug(f&#34;feature is enabled by default and has no defined rules, name={name}&#34;)
                features_enabled.append(name)
            elif self._evaluate_rules(
                feature_name=name,
                context=context,
                feat_default=feature_default_value,
                rules=rules,
                boolean_feature=boolean_feature,
            ):
                self.logger.debug(f&#34;feature&#39;s calculated value is True, name={name}&#34;)
                features_enabled.append(name)

        return features_enabled</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags"><code class="flex name class">
<span>class <span class="ident">FeatureFlags</span></span>
<span>(</span><span>store: <a title="aws_lambda_powertools.utilities.feature_flags.base.StoreProvider" href="base.html#aws_lambda_powertools.utilities.feature_flags.base.StoreProvider">StoreProvider</a>, logger: Union[logging.Logger, <a title="aws_lambda_powertools.logging.logger.Logger" href="../../logging/logger.html#aws_lambda_powertools.logging.logger.Logger">Logger</a>, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates whether feature flags should be enabled based on a given context.</p>
<p>It uses the provided store to fetch feature flag rules before evaluating them.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">from aws_lambda_powertools.utilities.feature_flags import FeatureFlags, AppConfigStore

app_config = AppConfigStore(
    environment=&quot;test&quot;,
    application=&quot;powertools&quot;,
    name=&quot;test_conf_name&quot;,
    max_age=300,
    envelope=&quot;features&quot;
)

feature_flags: FeatureFlags = FeatureFlags(store=app_config)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>store</code></strong> :&ensp;<code>StoreProvider</code></dt>
<dd>Store to use to fetch feature flag schema configuration.</dd>
<dt><strong><code>logger</code></strong> :&ensp;<code>A logging object</code></dt>
<dd>Used to log messages. If None is supplied, one will be created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureFlags:
    def __init__(self, store: StoreProvider, logger: Optional[Union[logging.Logger, Logger]] = None):
        &#34;&#34;&#34;Evaluates whether feature flags should be enabled based on a given context.

        It uses the provided store to fetch feature flag rules before evaluating them.

        Examples
        --------

        ```python
        from aws_lambda_powertools.utilities.feature_flags import FeatureFlags, AppConfigStore

        app_config = AppConfigStore(
            environment=&#34;test&#34;,
            application=&#34;powertools&#34;,
            name=&#34;test_conf_name&#34;,
            max_age=300,
            envelope=&#34;features&#34;
        )

        feature_flags: FeatureFlags = FeatureFlags(store=app_config)
        ```

        Parameters
        ----------
        store: StoreProvider
            Store to use to fetch feature flag schema configuration.
        logger: A logging object
            Used to log messages. If None is supplied, one will be created.
        &#34;&#34;&#34;
        self.store = store
        self.logger = logger or logging.getLogger(__name__)

    def _match_by_action(self, action: str, condition_value: Any, context_value: Any) -&gt; bool:
        mapping_by_action = {
            schema.RuleAction.EQUALS.value: lambda a, b: a == b,
            schema.RuleAction.NOT_EQUALS.value: lambda a, b: a != b,
            schema.RuleAction.KEY_GREATER_THAN_VALUE.value: lambda a, b: a &gt; b,
            schema.RuleAction.KEY_GREATER_THAN_OR_EQUAL_VALUE.value: lambda a, b: a &gt;= b,
            schema.RuleAction.KEY_LESS_THAN_VALUE.value: lambda a, b: a &lt; b,
            schema.RuleAction.KEY_LESS_THAN_OR_EQUAL_VALUE.value: lambda a, b: a &lt;= b,
            schema.RuleAction.STARTSWITH.value: lambda a, b: a.startswith(b),
            schema.RuleAction.ENDSWITH.value: lambda a, b: a.endswith(b),
            schema.RuleAction.IN.value: lambda a, b: a in b,
            schema.RuleAction.NOT_IN.value: lambda a, b: a not in b,
            schema.RuleAction.KEY_IN_VALUE.value: lambda a, b: a in b,
            schema.RuleAction.KEY_NOT_IN_VALUE.value: lambda a, b: a not in b,
            schema.RuleAction.VALUE_IN_KEY.value: lambda a, b: b in a,
            schema.RuleAction.VALUE_NOT_IN_KEY.value: lambda a, b: b not in a,
            schema.RuleAction.SCHEDULE_BETWEEN_TIME_RANGE.value: lambda a, b: compare_time_range(a, b),
            schema.RuleAction.SCHEDULE_BETWEEN_DATETIME_RANGE.value: lambda a, b: compare_datetime_range(a, b),
            schema.RuleAction.SCHEDULE_BETWEEN_DAYS_OF_WEEK.value: lambda a, b: compare_days_of_week(a, b),
        }

        try:
            func = mapping_by_action.get(action, lambda a, b: False)
            return func(context_value, condition_value)
        except Exception as exc:
            self.logger.debug(f&#34;caught exception while matching action: action={action}, exception={str(exc)}&#34;)
            return False

    def _evaluate_conditions(
        self, rule_name: str, feature_name: str, rule: Dict[str, Any], context: Dict[str, Any]
    ) -&gt; bool:
        &#34;&#34;&#34;Evaluates whether context matches conditions, return False otherwise&#34;&#34;&#34;
        rule_match_value = rule.get(schema.RULE_MATCH_VALUE)
        conditions = cast(List[Dict], rule.get(schema.CONDITIONS_KEY))

        if not conditions:
            self.logger.debug(
                f&#34;rule did not match, no conditions to match, rule_name={rule_name}, rule_value={rule_match_value}, &#34;
                f&#34;name={feature_name} &#34;
            )
            return False

        for condition in conditions:
            context_value = context.get(condition.get(schema.CONDITION_KEY, &#34;&#34;))
            cond_action = condition.get(schema.CONDITION_ACTION, &#34;&#34;)
            cond_value = condition.get(schema.CONDITION_VALUE)

            # time based rule actions have no user context. the context is the condition key
            if cond_action in (
                schema.RuleAction.SCHEDULE_BETWEEN_TIME_RANGE.value,
                schema.RuleAction.SCHEDULE_BETWEEN_DATETIME_RANGE.value,
                schema.RuleAction.SCHEDULE_BETWEEN_DAYS_OF_WEEK.value,
            ):
                context_value = condition.get(schema.CONDITION_KEY)  # e.g., CURRENT_TIME

            if not self._match_by_action(action=cond_action, condition_value=cond_value, context_value=context_value):
                self.logger.debug(
                    f&#34;rule did not match action, rule_name={rule_name}, rule_value={rule_match_value}, &#34;
                    f&#34;name={feature_name}, context_value={str(context_value)} &#34;
                )
                return False  # context doesn&#39;t match condition

        self.logger.debug(f&#34;rule matched, rule_name={rule_name}, rule_value={rule_match_value}, name={feature_name}&#34;)
        return True

    def _evaluate_rules(
        self,
        *,
        feature_name: str,
        context: Dict[str, Any],
        feat_default: Any,
        rules: Dict[str, Any],
        boolean_feature: bool,
    ) -&gt; bool:
        &#34;&#34;&#34;Evaluates whether context matches rules and conditions, otherwise return feature default&#34;&#34;&#34;
        for rule_name, rule in rules.items():
            rule_match_value = rule.get(schema.RULE_MATCH_VALUE)

            # Context might contain PII data; do not log its value
            self.logger.debug(
                f&#34;Evaluating rule matching, rule={rule_name}, feature={feature_name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
            )
            if self._evaluate_conditions(rule_name=rule_name, feature_name=feature_name, rule=rule, context=context):
                # Maintenance: Revisit before going GA.
                return bool(rule_match_value) if boolean_feature else rule_match_value

        # no rule matched, return default value of feature
        self.logger.debug(
            f&#34;no rule matched, returning feature default, default={str(feat_default)}, name={feature_name}, boolean_feature={boolean_feature}&#34;  # noqa: E501
        )
        return feat_default

    def get_configuration(self) -&gt; Dict:
        &#34;&#34;&#34;Get validated feature flag schema from configured store.

        Largely used to aid testing, since it&#39;s called by `evaluate` and `get_enabled_features` methods.

        Raises
        ------
        ConfigurationStoreError
            Any propagated error from store
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema

        Returns
        ------
        Dict[str, Dict]
            parsed JSON dictionary

            **Example**

        ```python
        {
            &#34;premium_features&#34;: {
                &#34;default&#34;: False,
                &#34;rules&#34;: {
                    &#34;customer tier equals premium&#34;: {
                        &#34;when_match&#34;: True,
                        &#34;conditions&#34;: [
                            {
                                &#34;action&#34;: &#34;EQUALS&#34;,
                                &#34;key&#34;: &#34;tier&#34;,
                                &#34;value&#34;: &#34;premium&#34;,
                            }
                        ],
                    }
                },
            },
            &#34;feature_two&#34;: {
                &#34;default&#34;: False
            }
        }
        ```
        &#34;&#34;&#34;
        # parse result conf as JSON, keep in cache for max age defined in store
        self.logger.debug(f&#34;Fetching schema from registered store, store={self.store}&#34;)
        config: Dict = self.store.get_configuration()
        validator = schema.SchemaValidator(schema=config, logger=self.logger)
        validator.validate()

        return config

    def evaluate(self, *, name: str, context: Optional[Dict[str, Any]] = None, default: JSONType) -&gt; JSONType:
        &#34;&#34;&#34;Evaluate whether a feature flag should be enabled according to stored schema and input context

        **Logic when evaluating a feature flag**

        1. Feature exists and a rule matches, returns when_match value
        2. Feature exists but has either no rules or no match, return feature default value
        3. Feature doesn&#39;t exist in stored schema, encountered an error when fetching -&gt; return default value provided

        Parameters
        ----------
        name: str
            feature name to evaluate
        context: Optional[Dict[str, Any]]
            Attributes that should be evaluated against the stored schema.

            for example: `{&#34;tenant_id&#34;: &#34;X&#34;, &#34;username&#34;: &#34;Y&#34;, &#34;region&#34;: &#34;Z&#34;}`
        default: JSONType
            default value if feature flag doesn&#39;t exist in the schema,
            or there has been an error when fetching the configuration from the store
            Can be boolean or any JSON values for non-boolean features.

        Returns
        ------
        JSONType
            whether feature should be enabled (bool flags) or JSON value when non-bool feature matches

        Raises
        ------
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema
        &#34;&#34;&#34;
        if context is None:
            context = {}

        try:
            features = self.get_configuration()
        except ConfigurationStoreError as err:
            self.logger.debug(f&#34;Failed to fetch feature flags from store, returning default provided, reason={err}&#34;)
            return default

        feature = features.get(name)
        if feature is None:
            self.logger.debug(f&#34;Feature not found; returning default provided, name={name}, default={default}&#34;)
            return default

        rules = feature.get(schema.RULES_KEY)
        feat_default = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
        # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
        # for non-boolean flags. It&#39;ll need minor implementation changes, docs changes, and maybe refactor
        # get_enabled_features. We can minimize breaking change, despite Beta label, by having a new
        # method `get_matching_features` returning Dict[feature_name, feature_value]
        boolean_feature = feature.get(
            schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
        )  # backwards compatibility, assume feature flag
        if not rules:
            self.logger.debug(
                f&#34;no rules found, returning feature default, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
            )
            # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
            # for non-boolean flags.
            return bool(feat_default) if boolean_feature else feat_default

        self.logger.debug(
            f&#34;looking for rule match, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
        )
        return self._evaluate_rules(
            feature_name=name, context=context, feat_default=feat_default, rules=rules, boolean_feature=boolean_feature
        )

    def get_enabled_features(self, *, context: Optional[Dict[str, Any]] = None) -&gt; List[str]:
        &#34;&#34;&#34;Get all enabled feature flags while also taking into account context
        (when a feature has defined rules)

        Parameters
        ----------
        context: Optional[Dict[str, Any]]
            dict of attributes that you would like to match the rules
            against, can be `{&#39;tenant_id: &#39;X&#39;, &#39;username&#39;:&#39; &#39;Y&#39;, &#39;region&#39;: &#39;Z&#39;}` etc.

        Returns
        ----------
        List[str]
            list of all feature names that either matches context or have True as default

            **Example**

        ```python
        [&#34;premium_features&#34;, &#34;my_feature_two&#34;, &#34;always_true_feature&#34;]
        ```

        Raises
        ------
        SchemaValidationError
            When schema doesn&#39;t conform with feature flag schema
        &#34;&#34;&#34;
        if context is None:
            context = {}

        features_enabled: List[str] = []

        try:
            features: Dict[str, Any] = self.get_configuration()
        except ConfigurationStoreError as err:
            self.logger.debug(f&#34;Failed to fetch feature flags from store, returning empty list, reason={err}&#34;)
            return features_enabled

        self.logger.debug(&#34;Evaluating all features&#34;)
        for name, feature in features.items():
            rules = feature.get(schema.RULES_KEY, {})
            feature_default_value = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
            boolean_feature = feature.get(
                schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
            )  # backwards compatibility, assume feature flag

            if feature_default_value and not rules:
                self.logger.debug(f&#34;feature is enabled by default and has no defined rules, name={name}&#34;)
                features_enabled.append(name)
            elif self._evaluate_rules(
                feature_name=name,
                context=context,
                feat_default=feature_default_value,
                rules=rules,
                boolean_feature=boolean_feature,
            ):
                self.logger.debug(f&#34;feature&#39;s calculated value is True, name={name}&#34;)
                features_enabled.append(name)

        return features_enabled</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, *, name: str, context: Optional[Dict[str, Any]] = None, default: Union[str, int, float, bool, ForwardRef(None), Dict[str, Any], List[Any]]) ‑> Union[str, int, float, bool, ForwardRef(None), Dict[str, Any], List[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate whether a feature flag should be enabled according to stored schema and input context</p>
<p><strong>Logic when evaluating a feature flag</strong></p>
<ol>
<li>Feature exists and a rule matches, returns when_match value</li>
<li>Feature exists but has either no rules or no match, return feature default value</li>
<li>Feature doesn't exist in stored schema, encountered an error when fetching -&gt; return default value provided</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>feature name to evaluate</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>Optional[Dict[str, Any]]</code></dt>
<dd>
<p>Attributes that should be evaluated against the stored schema.</p>
<p>for example: <code>{"tenant_id": "X", "username": "Y", "region": "Z"}</code></p>
</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>JSONType</code></dt>
<dd>default value if feature flag doesn't exist in the schema,
or there has been an error when fetching the configuration from the store
Can be boolean or any JSON values for non-boolean features.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSONType</code></dt>
<dd>whether feature should be enabled (bool flags) or JSON value when non-bool feature matches</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SchemaValidationError</code></dt>
<dd>When schema doesn't conform with feature flag schema</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, *, name: str, context: Optional[Dict[str, Any]] = None, default: JSONType) -&gt; JSONType:
    &#34;&#34;&#34;Evaluate whether a feature flag should be enabled according to stored schema and input context

    **Logic when evaluating a feature flag**

    1. Feature exists and a rule matches, returns when_match value
    2. Feature exists but has either no rules or no match, return feature default value
    3. Feature doesn&#39;t exist in stored schema, encountered an error when fetching -&gt; return default value provided

    Parameters
    ----------
    name: str
        feature name to evaluate
    context: Optional[Dict[str, Any]]
        Attributes that should be evaluated against the stored schema.

        for example: `{&#34;tenant_id&#34;: &#34;X&#34;, &#34;username&#34;: &#34;Y&#34;, &#34;region&#34;: &#34;Z&#34;}`
    default: JSONType
        default value if feature flag doesn&#39;t exist in the schema,
        or there has been an error when fetching the configuration from the store
        Can be boolean or any JSON values for non-boolean features.

    Returns
    ------
    JSONType
        whether feature should be enabled (bool flags) or JSON value when non-bool feature matches

    Raises
    ------
    SchemaValidationError
        When schema doesn&#39;t conform with feature flag schema
    &#34;&#34;&#34;
    if context is None:
        context = {}

    try:
        features = self.get_configuration()
    except ConfigurationStoreError as err:
        self.logger.debug(f&#34;Failed to fetch feature flags from store, returning default provided, reason={err}&#34;)
        return default

    feature = features.get(name)
    if feature is None:
        self.logger.debug(f&#34;Feature not found; returning default provided, name={name}, default={default}&#34;)
        return default

    rules = feature.get(schema.RULES_KEY)
    feat_default = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
    # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
    # for non-boolean flags. It&#39;ll need minor implementation changes, docs changes, and maybe refactor
    # get_enabled_features. We can minimize breaking change, despite Beta label, by having a new
    # method `get_matching_features` returning Dict[feature_name, feature_value]
    boolean_feature = feature.get(
        schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
    )  # backwards compatibility, assume feature flag
    if not rules:
        self.logger.debug(
            f&#34;no rules found, returning feature default, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
        )
        # Maintenance: Revisit before going GA. We might to simplify customers on-boarding by not requiring it
        # for non-boolean flags.
        return bool(feat_default) if boolean_feature else feat_default

    self.logger.debug(
        f&#34;looking for rule match, name={name}, default={str(feat_default)}, boolean_feature={boolean_feature}&#34;  # noqa: E501
    )
    return self._evaluate_rules(
        feature_name=name, context=context, feat_default=feat_default, rules=rules, boolean_feature=boolean_feature
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_configuration"><code class="name flex">
<span>def <span class="ident">get_configuration</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get validated feature flag schema from configured store.</p>
<p>Largely used to aid testing, since it's called by <code>evaluate</code> and <code>get_enabled_features</code> methods.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConfigurationStoreError</code></dt>
<dd>Any propagated error from store</dd>
<dt><code>SchemaValidationError</code></dt>
<dd>When schema doesn't conform with feature flag schema</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Dict]</code></dt>
<dd>
<p>parsed JSON dictionary</p>
<p><strong>Example</strong></p>
</dd>
</dl>
<pre><code class="language-python">{
    &quot;premium_features&quot;: {
        &quot;default&quot;: False,
        &quot;rules&quot;: {
            &quot;customer tier equals premium&quot;: {
                &quot;when_match&quot;: True,
                &quot;conditions&quot;: [
                    {
                        &quot;action&quot;: &quot;EQUALS&quot;,
                        &quot;key&quot;: &quot;tier&quot;,
                        &quot;value&quot;: &quot;premium&quot;,
                    }
                ],
            }
        },
    },
    &quot;feature_two&quot;: {
        &quot;default&quot;: False
    }
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_configuration(self) -&gt; Dict:
    &#34;&#34;&#34;Get validated feature flag schema from configured store.

    Largely used to aid testing, since it&#39;s called by `evaluate` and `get_enabled_features` methods.

    Raises
    ------
    ConfigurationStoreError
        Any propagated error from store
    SchemaValidationError
        When schema doesn&#39;t conform with feature flag schema

    Returns
    ------
    Dict[str, Dict]
        parsed JSON dictionary

        **Example**

    ```python
    {
        &#34;premium_features&#34;: {
            &#34;default&#34;: False,
            &#34;rules&#34;: {
                &#34;customer tier equals premium&#34;: {
                    &#34;when_match&#34;: True,
                    &#34;conditions&#34;: [
                        {
                            &#34;action&#34;: &#34;EQUALS&#34;,
                            &#34;key&#34;: &#34;tier&#34;,
                            &#34;value&#34;: &#34;premium&#34;,
                        }
                    ],
                }
            },
        },
        &#34;feature_two&#34;: {
            &#34;default&#34;: False
        }
    }
    ```
    &#34;&#34;&#34;
    # parse result conf as JSON, keep in cache for max age defined in store
    self.logger.debug(f&#34;Fetching schema from registered store, store={self.store}&#34;)
    config: Dict = self.store.get_configuration()
    validator = schema.SchemaValidator(schema=config, logger=self.logger)
    validator.validate()

    return config</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_enabled_features"><code class="name flex">
<span>def <span class="ident">get_enabled_features</span></span>(<span>self, *, context: Optional[Dict[str, Any]] = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all enabled feature flags while also taking into account context
(when a feature has defined rules)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>Optional[Dict[str, Any]]</code></dt>
<dd>dict of attributes that you would like to match the rules
against, can be <code>{'tenant_id: 'X', 'username':' 'Y', 'region': 'Z'}</code> etc.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>
<p>list of all feature names that either matches context or have True as default</p>
<p><strong>Example</strong></p>
</dd>
</dl>
<pre><code class="language-python">[&quot;premium_features&quot;, &quot;my_feature_two&quot;, &quot;always_true_feature&quot;]
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SchemaValidationError</code></dt>
<dd>When schema doesn't conform with feature flag schema</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_enabled_features(self, *, context: Optional[Dict[str, Any]] = None) -&gt; List[str]:
    &#34;&#34;&#34;Get all enabled feature flags while also taking into account context
    (when a feature has defined rules)

    Parameters
    ----------
    context: Optional[Dict[str, Any]]
        dict of attributes that you would like to match the rules
        against, can be `{&#39;tenant_id: &#39;X&#39;, &#39;username&#39;:&#39; &#39;Y&#39;, &#39;region&#39;: &#39;Z&#39;}` etc.

    Returns
    ----------
    List[str]
        list of all feature names that either matches context or have True as default

        **Example**

    ```python
    [&#34;premium_features&#34;, &#34;my_feature_two&#34;, &#34;always_true_feature&#34;]
    ```

    Raises
    ------
    SchemaValidationError
        When schema doesn&#39;t conform with feature flag schema
    &#34;&#34;&#34;
    if context is None:
        context = {}

    features_enabled: List[str] = []

    try:
        features: Dict[str, Any] = self.get_configuration()
    except ConfigurationStoreError as err:
        self.logger.debug(f&#34;Failed to fetch feature flags from store, returning empty list, reason={err}&#34;)
        return features_enabled

    self.logger.debug(&#34;Evaluating all features&#34;)
    for name, feature in features.items():
        rules = feature.get(schema.RULES_KEY, {})
        feature_default_value = feature.get(schema.FEATURE_DEFAULT_VAL_KEY)
        boolean_feature = feature.get(
            schema.FEATURE_DEFAULT_VAL_TYPE_KEY, True
        )  # backwards compatibility, assume feature flag

        if feature_default_value and not rules:
            self.logger.debug(f&#34;feature is enabled by default and has no defined rules, name={name}&#34;)
            features_enabled.append(name)
        elif self._evaluate_rules(
            feature_name=name,
            context=context,
            feat_default=feature_default_value,
            rules=rules,
            boolean_feature=boolean_feature,
        ):
            self.logger.debug(f&#34;feature&#39;s calculated value is True, name={name}&#34;)
            features_enabled.append(name)

    return features_enabled</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.feature_flags" href="index.html">aws_lambda_powertools.utilities.feature_flags</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags" href="#aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags">FeatureFlags</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.evaluate" href="#aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.evaluate">evaluate</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_configuration" href="#aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_configuration">get_configuration</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_enabled_features" href="#aws_lambda_powertools.utilities.feature_flags.feature_flags.FeatureFlags.get_enabled_features">get_enabled_features</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>