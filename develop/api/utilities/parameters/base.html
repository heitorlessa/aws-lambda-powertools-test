<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.parameters.base API documentation</title>
<meta name="description" content="Base for Parameter providers" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.parameters.base</code></h1>
</header>
<section id="section-intro">
<p>Base for Parameter providers</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base for Parameter providers
&#34;&#34;&#34;
from __future__ import annotations

import base64
import json
import os
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    NamedTuple,
    Optional,
    Tuple,
    Type,
    Union,
    cast,
    overload,
)

import boto3
from botocore.config import Config

from aws_lambda_powertools.shared import constants
from aws_lambda_powertools.shared.functions import resolve_max_age
from aws_lambda_powertools.utilities.parameters.types import TransformOptions

from .exceptions import GetParameterError, TransformParameterError

if TYPE_CHECKING:
    from mypy_boto3_appconfigdata import AppConfigDataClient
    from mypy_boto3_dynamodb import DynamoDBServiceResource
    from mypy_boto3_secretsmanager import SecretsManagerClient
    from mypy_boto3_ssm import SSMClient


DEFAULT_MAX_AGE_SECS = &#34;5&#34;

# These providers will be dynamically initialized on first use of the helper functions
DEFAULT_PROVIDERS: Dict[str, Any] = {}
TRANSFORM_METHOD_JSON = &#34;json&#34;
TRANSFORM_METHOD_BINARY = &#34;binary&#34;
SUPPORTED_TRANSFORM_METHODS = [TRANSFORM_METHOD_JSON, TRANSFORM_METHOD_BINARY]
ParameterClients = Union[&#34;AppConfigDataClient&#34;, &#34;SecretsManagerClient&#34;, &#34;SSMClient&#34;]

TRANSFORM_METHOD_MAPPING = {
    TRANSFORM_METHOD_JSON: json.loads,
    TRANSFORM_METHOD_BINARY: base64.b64decode,
    &#34;.json&#34;: json.loads,
    &#34;.binary&#34;: base64.b64decode,
    None: lambda x: x,
}


class ExpirableValue(NamedTuple):
    value: str | bytes | Dict[str, Any]
    ttl: datetime


class BaseProvider(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Parameter providers
    &#34;&#34;&#34;

    store: Dict[Tuple[str, TransformOptions], ExpirableValue]

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the base provider
        &#34;&#34;&#34;

        self.store: Dict[Tuple[str, TransformOptions], ExpirableValue] = {}

    def has_not_expired_in_cache(self, key: Tuple[str, TransformOptions]) -&gt; bool:
        return key in self.store and self.store[key].ttl &gt;= datetime.now()

    def get(
        self,
        name: str,
        max_age: Optional[int] = None,
        transform: TransformOptions = None,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Optional[Union[str, dict, bytes]]:
        &#34;&#34;&#34;
        Retrieve a parameter value or return the cached value

        Parameters
        ----------
        name: str
            Parameter name
        max_age: int
            Maximum age of the cached value
        transform: str
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
            values.
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve a parameter value for
            a given name.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        # If there are multiple calls to the same parameter but in a different
        # transform, they will be stored multiple times. This allows us to
        # optimize by transforming the data only once per retrieval, thus there
        # is no need to transform cached values multiple times. However, this
        # means that we need to make multiple calls to the underlying parameter
        # store if we need to return it in different transforms. Since the number
        # of supported transform is small and the probability that a given
        # parameter will always be used in a specific transform, this should be
        # an acceptable tradeoff.
        value: Optional[Union[str, bytes, dict]] = None
        key = (name, transform)

        # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
        max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

        if not force_fetch and self.has_not_expired_in_cache(key):
            return self.store[key].value

        try:
            value = self._get(name, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform:
            value = transform_value(key=name, value=value, transform=transform, raise_on_transform_error=True)

        # NOTE: don&#39;t cache None, as they might&#39;ve been failed transforms and may be corrected
        if value is not None:
            self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

        return value

    @abstractmethod
    def _get(self, name: str, **sdk_options) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;
        Retrieve parameter value from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_multiple(
        self,
        path: str,
        max_age: Optional[int] = None,
        transform: TransformOptions = None,
        raise_on_transform_error: bool = False,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
        &#34;&#34;&#34;
        Retrieve multiple parameters based on a path prefix

        Parameters
        ----------
        path: str
            Parameter path used to retrieve multiple parameters
        max_age: int, optional
            Maximum age of the cached value
        transform: str, optional
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
            values or &#34;auto&#34; which looks at the attribute key to determine the type.
        raise_on_transform_error: bool, optional
            Raises an exception if any transform fails, otherwise this will
            return a None value for each transform that failed
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve parameter values for
            a given path.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;
        key = (path, transform)

        # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
        max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

        if not force_fetch and self.has_not_expired_in_cache(key):
            return self.store[key].value  # type: ignore # need to revisit entire typing here

        try:
            values = self._get_multiple(path, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform:
            values.update(transform_value(values, transform, raise_on_transform_error))

        self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

        return values

    @abstractmethod
    def _get_multiple(self, path: str, **sdk_options) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Retrieve multiple parameter values from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def clear_cache(self):
        self.store.clear()

    def add_to_cache(self, key: Tuple[str, TransformOptions], value: Any, max_age: int):
        if max_age &lt;= 0:
            return

        self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

    @staticmethod
    def _build_boto3_client(
        service_name: str,
        client: Optional[ParameterClients] = None,
        session: Optional[Type[boto3.Session]] = None,
        config: Optional[Type[Config]] = None,
    ) -&gt; Type[ParameterClients]:
        &#34;&#34;&#34;Builds a low level boto3 client with session and config provided

        Parameters
        ----------
        service_name : str
            AWS service name to instantiate a boto3 client, e.g. ssm
        client : Optional[ParameterClients], optional
            boto3 client instance, by default None
        session : Optional[Type[boto3.Session]], optional
            boto3 session instance, by default None
        config : Optional[Type[Config]], optional
            botocore config instance to configure client with, by default None

        Returns
        -------
        Type[ParameterClients]
            Instance of a boto3 client for Parameters feature (e.g., ssm, appconfig, secretsmanager, etc.)
        &#34;&#34;&#34;
        if client is not None:
            return client

        session = session or boto3.Session()
        config = config or Config()
        return session.client(service_name=service_name, config=config)

    # maintenance: change DynamoDBServiceResource type to ParameterResourceClients when we expand
    @staticmethod
    def _build_boto3_resource_client(
        service_name: str,
        client: Optional[&#34;DynamoDBServiceResource&#34;] = None,
        session: Optional[Type[boto3.Session]] = None,
        config: Optional[Type[Config]] = None,
        endpoint_url: Optional[str] = None,
    ) -&gt; &#34;DynamoDBServiceResource&#34;:
        &#34;&#34;&#34;Builds a high level boto3 resource client with session, config and endpoint_url provided

        Parameters
        ----------
        service_name : str
            AWS service name to instantiate a boto3 client, e.g. ssm
        client : Optional[DynamoDBServiceResource], optional
            boto3 client instance, by default None
        session : Optional[Type[boto3.Session]], optional
            boto3 session instance, by default None
        config : Optional[Type[Config]], optional
            botocore config instance to configure client, by default None

        Returns
        -------
        Type[DynamoDBServiceResource]
            Instance of a boto3 resource client for Parameters feature (e.g., dynamodb, etc.)
        &#34;&#34;&#34;
        if client is not None:
            return client

        session = session or boto3.Session()
        config = config or Config()
        return session.resource(service_name=service_name, config=config, endpoint_url=endpoint_url)


def get_transform_method(value: str, transform: TransformOptions = None) -&gt; Callable[..., Any]:
    &#34;&#34;&#34;
    Determine the transform method

    Examples
    -------
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,&#34;any_other_value&#34;)
        &#39;any_other_value&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.json&#34;,&#34;auto&#34;)
        &#39;json&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.binary&#34;,&#34;auto&#34;)
        &#39;binary&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,&#34;auto&#34;)
        None
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,None)
        None

    Parameters
    ---------
    value: str
        Only used when the transform is &#34;auto&#34;.
    transform: str, optional
        Original transform method, only &#34;auto&#34; will try to detect the transform method by the key

    Returns
    ------
    Callable:
        Transform function could be json.loads, base64.b64decode, or a lambda that echo the str value
    &#34;&#34;&#34;
    transform_method = TRANSFORM_METHOD_MAPPING.get(transform)

    if transform == &#34;auto&#34;:
        key_suffix = value.rsplit(&#34;.&#34;)[-1]
        transform_method = TRANSFORM_METHOD_MAPPING.get(key_suffix, TRANSFORM_METHOD_MAPPING[None])

    return cast(Callable, transform_method)  # https://github.com/python/mypy/issues/10740


@overload
def transform_value(
    value: Dict[str, Any],
    transform: TransformOptions,
    raise_on_transform_error: bool = False,
    key: str = &#34;&#34;,
) -&gt; Dict[str, Any]:
    ...


@overload
def transform_value(
    value: Union[str, bytes, Dict[str, Any]],
    transform: TransformOptions,
    raise_on_transform_error: bool = False,
    key: str = &#34;&#34;,
) -&gt; Optional[Union[str, bytes, Dict[str, Any]]]:
    ...


def transform_value(
    value: Union[str, bytes, Dict[str, Any]],
    transform: TransformOptions,
    raise_on_transform_error: bool = True,
    key: str = &#34;&#34;,
) -&gt; Optional[Union[str, bytes, Dict[str, Any]]]:
    &#34;&#34;&#34;
    Transform a value using one of the available options.

    Parameters
    ---------
    value: str
        Parameter value to transform
    transform: str
        Type of transform, supported values are &#34;json&#34;, &#34;binary&#34;, and &#34;auto&#34; based on suffix (.json, .binary)
    key: str
        Parameter key when transform is auto to infer its transform method
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed

    Raises
    ------
    TransformParameterError:
        When the parameter value could not be transformed
    &#34;&#34;&#34;
    # Maintenance: For v3, we should consider returning the original value for soft transform failures.

    err_msg = &#34;Unable to transform value using &#39;{transform}&#39; transform: {exc}&#34;

    if isinstance(value, bytes):
        value = value.decode(&#34;utf-8&#34;)

    if isinstance(value, dict):
        # NOTE: We must handle partial failures when receiving multiple values
        # where one of the keys might fail during transform, e.g. `{&#34;a&#34;: &#34;valid&#34;, &#34;b&#34;: &#34;{&#34;}`
        # expected: `{&#34;a&#34;: &#34;valid&#34;, &#34;b&#34;: None}`

        transformed_values: Dict[str, Any] = {}
        for dict_key, dict_value in value.items():
            transform_method = get_transform_method(value=dict_key, transform=transform)
            try:
                transformed_values[dict_key] = transform_method(dict_value)
            except Exception as exc:
                if raise_on_transform_error:
                    raise TransformParameterError(err_msg.format(transform=transform, exc=exc)) from exc
                transformed_values[dict_key] = None
        return transformed_values

    if transform == &#34;auto&#34;:
        # key=&#34;a.json&#34;, value=&#39;{&#34;a&#34;: &#34;b&#34;}&#39;, or key=&#34;a.binary&#34;, value=&#34;b64_encoded&#34;
        transform_method = get_transform_method(value=key, transform=transform)
    else:
        # value=&#39;{&#34;key&#34;: &#34;value&#34;}
        transform_method = get_transform_method(value=value, transform=transform)

    try:
        return transform_method(value)
    except Exception as exc:
        if raise_on_transform_error:
            raise TransformParameterError(err_msg.format(transform=transform, exc=exc)) from exc
        return None


def clear_caches():
    &#34;&#34;&#34;Clear cached parameter values from all providers&#34;&#34;&#34;
    DEFAULT_PROVIDERS.clear()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.clear_caches"><code class="name flex">
<span>def <span class="ident">clear_caches</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear cached parameter values from all providers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_caches():
    &#34;&#34;&#34;Clear cached parameter values from all providers&#34;&#34;&#34;
    DEFAULT_PROVIDERS.clear()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.get_transform_method"><code class="name flex">
<span>def <span class="ident">get_transform_method</span></span>(<span>value: str, transform: TransformOptions = None) ‑> Callable[..., Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the transform method</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; get_transform_method("key","any_other_value")
'any_other_value'
&gt;&gt;&gt; get_transform_method("key.json","auto")
'json'
&gt;&gt;&gt; get_transform_method("key.binary","auto")
'binary'
&gt;&gt;&gt; get_transform_method("key","auto")
None
&gt;&gt;&gt; get_transform_method("key",None)
None
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Only used when the transform is "auto".</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Original transform method, only "auto" will try to detect the transform method by the key</dd>
</dl>
<h2 id="returns">Returns</h2>
<h2 id="callable">Callable</h2>
<p>Transform function could be json.loads, base64.b64decode, or a lambda that echo the str value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_method(value: str, transform: TransformOptions = None) -&gt; Callable[..., Any]:
    &#34;&#34;&#34;
    Determine the transform method

    Examples
    -------
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,&#34;any_other_value&#34;)
        &#39;any_other_value&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.json&#34;,&#34;auto&#34;)
        &#39;json&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key.binary&#34;,&#34;auto&#34;)
        &#39;binary&#39;
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,&#34;auto&#34;)
        None
        &gt;&gt;&gt; get_transform_method(&#34;key&#34;,None)
        None

    Parameters
    ---------
    value: str
        Only used when the transform is &#34;auto&#34;.
    transform: str, optional
        Original transform method, only &#34;auto&#34; will try to detect the transform method by the key

    Returns
    ------
    Callable:
        Transform function could be json.loads, base64.b64decode, or a lambda that echo the str value
    &#34;&#34;&#34;
    transform_method = TRANSFORM_METHOD_MAPPING.get(transform)

    if transform == &#34;auto&#34;:
        key_suffix = value.rsplit(&#34;.&#34;)[-1]
        transform_method = TRANSFORM_METHOD_MAPPING.get(key_suffix, TRANSFORM_METHOD_MAPPING[None])

    return cast(Callable, transform_method)  # https://github.com/python/mypy/issues/10740</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.transform_value"><code class="name flex">
<span>def <span class="ident">transform_value</span></span>(<span>value: Union[str, bytes, Dict[str, Any]], transform: TransformOptions, raise_on_transform_error: bool = True, key: str = '') ‑> Union[str, bytes, Dict[str, Any], ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a value using one of the available options.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter value to transform</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of transform, supported values are "json", "binary", and "auto" based on suffix (.json, .binary)</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter key when transform is auto to infer its transform method</dd>
<dt><strong><code>raise_on_transform_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Raises an exception if any transform fails, otherwise this will
return a None value for each transform that failed</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="transformparametererror">Transformparametererror</h2>
<p>When the parameter value could not be transformed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_value(
    value: Union[str, bytes, Dict[str, Any]],
    transform: TransformOptions,
    raise_on_transform_error: bool = True,
    key: str = &#34;&#34;,
) -&gt; Optional[Union[str, bytes, Dict[str, Any]]]:
    &#34;&#34;&#34;
    Transform a value using one of the available options.

    Parameters
    ---------
    value: str
        Parameter value to transform
    transform: str
        Type of transform, supported values are &#34;json&#34;, &#34;binary&#34;, and &#34;auto&#34; based on suffix (.json, .binary)
    key: str
        Parameter key when transform is auto to infer its transform method
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed

    Raises
    ------
    TransformParameterError:
        When the parameter value could not be transformed
    &#34;&#34;&#34;
    # Maintenance: For v3, we should consider returning the original value for soft transform failures.

    err_msg = &#34;Unable to transform value using &#39;{transform}&#39; transform: {exc}&#34;

    if isinstance(value, bytes):
        value = value.decode(&#34;utf-8&#34;)

    if isinstance(value, dict):
        # NOTE: We must handle partial failures when receiving multiple values
        # where one of the keys might fail during transform, e.g. `{&#34;a&#34;: &#34;valid&#34;, &#34;b&#34;: &#34;{&#34;}`
        # expected: `{&#34;a&#34;: &#34;valid&#34;, &#34;b&#34;: None}`

        transformed_values: Dict[str, Any] = {}
        for dict_key, dict_value in value.items():
            transform_method = get_transform_method(value=dict_key, transform=transform)
            try:
                transformed_values[dict_key] = transform_method(dict_value)
            except Exception as exc:
                if raise_on_transform_error:
                    raise TransformParameterError(err_msg.format(transform=transform, exc=exc)) from exc
                transformed_values[dict_key] = None
        return transformed_values

    if transform == &#34;auto&#34;:
        # key=&#34;a.json&#34;, value=&#39;{&#34;a&#34;: &#34;b&#34;}&#39;, or key=&#34;a.binary&#34;, value=&#34;b64_encoded&#34;
        transform_method = get_transform_method(value=key, transform=transform)
    else:
        # value=&#39;{&#34;key&#34;: &#34;value&#34;}
        transform_method = get_transform_method(value=value, transform=transform)

    try:
        return transform_method(value)
    except Exception as exc:
        if raise_on_transform_error:
            raise TransformParameterError(err_msg.format(transform=transform, exc=exc)) from exc
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider"><code class="flex name class">
<span>class <span class="ident">BaseProvider</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Base Class for Parameter providers</p>
<p>Initialize the base provider</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProvider(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Parameter providers
    &#34;&#34;&#34;

    store: Dict[Tuple[str, TransformOptions], ExpirableValue]

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the base provider
        &#34;&#34;&#34;

        self.store: Dict[Tuple[str, TransformOptions], ExpirableValue] = {}

    def has_not_expired_in_cache(self, key: Tuple[str, TransformOptions]) -&gt; bool:
        return key in self.store and self.store[key].ttl &gt;= datetime.now()

    def get(
        self,
        name: str,
        max_age: Optional[int] = None,
        transform: TransformOptions = None,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Optional[Union[str, dict, bytes]]:
        &#34;&#34;&#34;
        Retrieve a parameter value or return the cached value

        Parameters
        ----------
        name: str
            Parameter name
        max_age: int
            Maximum age of the cached value
        transform: str
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
            values.
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve a parameter value for
            a given name.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;

        # If there are multiple calls to the same parameter but in a different
        # transform, they will be stored multiple times. This allows us to
        # optimize by transforming the data only once per retrieval, thus there
        # is no need to transform cached values multiple times. However, this
        # means that we need to make multiple calls to the underlying parameter
        # store if we need to return it in different transforms. Since the number
        # of supported transform is small and the probability that a given
        # parameter will always be used in a specific transform, this should be
        # an acceptable tradeoff.
        value: Optional[Union[str, bytes, dict]] = None
        key = (name, transform)

        # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
        max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

        if not force_fetch and self.has_not_expired_in_cache(key):
            return self.store[key].value

        try:
            value = self._get(name, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform:
            value = transform_value(key=name, value=value, transform=transform, raise_on_transform_error=True)

        # NOTE: don&#39;t cache None, as they might&#39;ve been failed transforms and may be corrected
        if value is not None:
            self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

        return value

    @abstractmethod
    def _get(self, name: str, **sdk_options) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;
        Retrieve parameter value from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def get_multiple(
        self,
        path: str,
        max_age: Optional[int] = None,
        transform: TransformOptions = None,
        raise_on_transform_error: bool = False,
        force_fetch: bool = False,
        **sdk_options,
    ) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
        &#34;&#34;&#34;
        Retrieve multiple parameters based on a path prefix

        Parameters
        ----------
        path: str
            Parameter path used to retrieve multiple parameters
        max_age: int, optional
            Maximum age of the cached value
        transform: str, optional
            Optional transformation of the parameter value. Supported values
            are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
            values or &#34;auto&#34; which looks at the attribute key to determine the type.
        raise_on_transform_error: bool, optional
            Raises an exception if any transform fails, otherwise this will
            return a None value for each transform that failed
        force_fetch: bool, optional
            Force update even before a cached item has expired, defaults to False
        sdk_options: dict, optional
            Arguments that will be passed directly to the underlying API call

        Raises
        ------
        GetParameterError
            When the parameter provider fails to retrieve parameter values for
            a given path.
        TransformParameterError
            When the parameter provider fails to transform a parameter value.
        &#34;&#34;&#34;
        key = (path, transform)

        # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
        max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

        if not force_fetch and self.has_not_expired_in_cache(key):
            return self.store[key].value  # type: ignore # need to revisit entire typing here

        try:
            values = self._get_multiple(path, **sdk_options)
        # Encapsulate all errors into a generic GetParameterError
        except Exception as exc:
            raise GetParameterError(str(exc))

        if transform:
            values.update(transform_value(values, transform, raise_on_transform_error))

        self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

        return values

    @abstractmethod
    def _get_multiple(self, path: str, **sdk_options) -&gt; Dict[str, str]:
        &#34;&#34;&#34;
        Retrieve multiple parameter values from the underlying parameter store
        &#34;&#34;&#34;
        raise NotImplementedError()

    def clear_cache(self):
        self.store.clear()

    def add_to_cache(self, key: Tuple[str, TransformOptions], value: Any, max_age: int):
        if max_age &lt;= 0:
            return

        self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

    @staticmethod
    def _build_boto3_client(
        service_name: str,
        client: Optional[ParameterClients] = None,
        session: Optional[Type[boto3.Session]] = None,
        config: Optional[Type[Config]] = None,
    ) -&gt; Type[ParameterClients]:
        &#34;&#34;&#34;Builds a low level boto3 client with session and config provided

        Parameters
        ----------
        service_name : str
            AWS service name to instantiate a boto3 client, e.g. ssm
        client : Optional[ParameterClients], optional
            boto3 client instance, by default None
        session : Optional[Type[boto3.Session]], optional
            boto3 session instance, by default None
        config : Optional[Type[Config]], optional
            botocore config instance to configure client with, by default None

        Returns
        -------
        Type[ParameterClients]
            Instance of a boto3 client for Parameters feature (e.g., ssm, appconfig, secretsmanager, etc.)
        &#34;&#34;&#34;
        if client is not None:
            return client

        session = session or boto3.Session()
        config = config or Config()
        return session.client(service_name=service_name, config=config)

    # maintenance: change DynamoDBServiceResource type to ParameterResourceClients when we expand
    @staticmethod
    def _build_boto3_resource_client(
        service_name: str,
        client: Optional[&#34;DynamoDBServiceResource&#34;] = None,
        session: Optional[Type[boto3.Session]] = None,
        config: Optional[Type[Config]] = None,
        endpoint_url: Optional[str] = None,
    ) -&gt; &#34;DynamoDBServiceResource&#34;:
        &#34;&#34;&#34;Builds a high level boto3 resource client with session, config and endpoint_url provided

        Parameters
        ----------
        service_name : str
            AWS service name to instantiate a boto3 client, e.g. ssm
        client : Optional[DynamoDBServiceResource], optional
            boto3 client instance, by default None
        session : Optional[Type[boto3.Session]], optional
            boto3 session instance, by default None
        config : Optional[Type[Config]], optional
            botocore config instance to configure client, by default None

        Returns
        -------
        Type[DynamoDBServiceResource]
            Instance of a boto3 resource client for Parameters feature (e.g., dynamodb, etc.)
        &#34;&#34;&#34;
        if client is not None:
            return client

        session = session or boto3.Session()
        config = config or Config()
        return session.resource(service_name=service_name, config=config, endpoint_url=endpoint_url)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parameters.appconfig.AppConfigProvider" href="appconfig.html#aws_lambda_powertools.utilities.parameters.appconfig.AppConfigProvider">AppConfigProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.dynamodb.DynamoDBProvider" href="dynamodb.html#aws_lambda_powertools.utilities.parameters.dynamodb.DynamoDBProvider">DynamoDBProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.secrets.SecretsProvider" href="secrets.html#aws_lambda_powertools.utilities.parameters.secrets.SecretsProvider">SecretsProvider</a></li>
<li><a title="aws_lambda_powertools.utilities.parameters.ssm.SSMProvider" href="ssm.html#aws_lambda_powertools.utilities.parameters.ssm.SSMProvider">SSMProvider</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.store"><code class="name">var <span class="ident">store</span> : Dict[Tuple[str, Literal['json', 'binary', 'auto', None]], <a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue">ExpirableValue</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.add_to_cache"><code class="name flex">
<span>def <span class="ident">add_to_cache</span></span>(<span>self, key: Tuple[str, TransformOptions], value: Any, max_age: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_cache(self, key: Tuple[str, TransformOptions], value: Any, max_age: int):
    if max_age &lt;= 0:
        return

    self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self):
    self.store.clear()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name: str, max_age: Optional[int] = None, transform: TransformOptions = None, force_fetch: bool = False, **sdk_options) ‑> Union[str, dict, bytes, ForwardRef(None)]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a parameter value or return the cached value</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter name</dd>
<dt><strong><code>max_age</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum age of the cached value</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional transformation of the parameter value. Supported values
are "json" for JSON strings and "binary" for base 64 encoded
values.</dd>
<dt><strong><code>force_fetch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Force update even before a cached item has expired, defaults to False</dd>
<dt><strong><code>sdk_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Arguments that will be passed directly to the underlying API call</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GetParameterError</code></dt>
<dd>When the parameter provider fails to retrieve a parameter value for
a given name.</dd>
<dt><code>TransformParameterError</code></dt>
<dd>When the parameter provider fails to transform a parameter value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(
    self,
    name: str,
    max_age: Optional[int] = None,
    transform: TransformOptions = None,
    force_fetch: bool = False,
    **sdk_options,
) -&gt; Optional[Union[str, dict, bytes]]:
    &#34;&#34;&#34;
    Retrieve a parameter value or return the cached value

    Parameters
    ----------
    name: str
        Parameter name
    max_age: int
        Maximum age of the cached value
    transform: str
        Optional transformation of the parameter value. Supported values
        are &#34;json&#34; for JSON strings and &#34;binary&#34; for base 64 encoded
        values.
    force_fetch: bool, optional
        Force update even before a cached item has expired, defaults to False
    sdk_options: dict, optional
        Arguments that will be passed directly to the underlying API call

    Raises
    ------
    GetParameterError
        When the parameter provider fails to retrieve a parameter value for
        a given name.
    TransformParameterError
        When the parameter provider fails to transform a parameter value.
    &#34;&#34;&#34;

    # If there are multiple calls to the same parameter but in a different
    # transform, they will be stored multiple times. This allows us to
    # optimize by transforming the data only once per retrieval, thus there
    # is no need to transform cached values multiple times. However, this
    # means that we need to make multiple calls to the underlying parameter
    # store if we need to return it in different transforms. Since the number
    # of supported transform is small and the probability that a given
    # parameter will always be used in a specific transform, this should be
    # an acceptable tradeoff.
    value: Optional[Union[str, bytes, dict]] = None
    key = (name, transform)

    # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
    max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

    if not force_fetch and self.has_not_expired_in_cache(key):
        return self.store[key].value

    try:
        value = self._get(name, **sdk_options)
    # Encapsulate all errors into a generic GetParameterError
    except Exception as exc:
        raise GetParameterError(str(exc))

    if transform:
        value = transform_value(key=name, value=value, transform=transform, raise_on_transform_error=True)

    # NOTE: don&#39;t cache None, as they might&#39;ve been failed transforms and may be corrected
    if value is not None:
        self.store[key] = ExpirableValue(value, datetime.now() + timedelta(seconds=max_age))

    return value</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple"><code class="name flex">
<span>def <span class="ident">get_multiple</span></span>(<span>self, path: str, max_age: Optional[int] = None, transform: TransformOptions = None, raise_on_transform_error: bool = False, force_fetch: bool = False, **sdk_options) ‑> Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve multiple parameters based on a path prefix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter path used to retrieve multiple parameters</dd>
<dt><strong><code>max_age</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum age of the cached value</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optional transformation of the parameter value. Supported values
are "json" for JSON strings, "binary" for base 64 encoded
values or "auto" which looks at the attribute key to determine the type.</dd>
<dt><strong><code>raise_on_transform_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Raises an exception if any transform fails, otherwise this will
return a None value for each transform that failed</dd>
<dt><strong><code>force_fetch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Force update even before a cached item has expired, defaults to False</dd>
<dt><strong><code>sdk_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Arguments that will be passed directly to the underlying API call</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GetParameterError</code></dt>
<dd>When the parameter provider fails to retrieve parameter values for
a given path.</dd>
<dt><code>TransformParameterError</code></dt>
<dd>When the parameter provider fails to transform a parameter value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_multiple(
    self,
    path: str,
    max_age: Optional[int] = None,
    transform: TransformOptions = None,
    raise_on_transform_error: bool = False,
    force_fetch: bool = False,
    **sdk_options,
) -&gt; Union[Dict[str, str], Dict[str, dict], Dict[str, bytes]]:
    &#34;&#34;&#34;
    Retrieve multiple parameters based on a path prefix

    Parameters
    ----------
    path: str
        Parameter path used to retrieve multiple parameters
    max_age: int, optional
        Maximum age of the cached value
    transform: str, optional
        Optional transformation of the parameter value. Supported values
        are &#34;json&#34; for JSON strings, &#34;binary&#34; for base 64 encoded
        values or &#34;auto&#34; which looks at the attribute key to determine the type.
    raise_on_transform_error: bool, optional
        Raises an exception if any transform fails, otherwise this will
        return a None value for each transform that failed
    force_fetch: bool, optional
        Force update even before a cached item has expired, defaults to False
    sdk_options: dict, optional
        Arguments that will be passed directly to the underlying API call

    Raises
    ------
    GetParameterError
        When the parameter provider fails to retrieve parameter values for
        a given path.
    TransformParameterError
        When the parameter provider fails to transform a parameter value.
    &#34;&#34;&#34;
    key = (path, transform)

    # If max_age is not set, resolve it from the environment variable, defaulting to DEFAULT_MAX_AGE_SECS
    max_age = resolve_max_age(env=os.getenv(constants.PARAMETERS_MAX_AGE_ENV, DEFAULT_MAX_AGE_SECS), choice=max_age)

    if not force_fetch and self.has_not_expired_in_cache(key):
        return self.store[key].value  # type: ignore # need to revisit entire typing here

    try:
        values = self._get_multiple(path, **sdk_options)
    # Encapsulate all errors into a generic GetParameterError
    except Exception as exc:
        raise GetParameterError(str(exc))

    if transform:
        values.update(transform_value(values, transform, raise_on_transform_error))

    self.store[key] = ExpirableValue(values, datetime.now() + timedelta(seconds=max_age))

    return values</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.BaseProvider.has_not_expired_in_cache"><code class="name flex">
<span>def <span class="ident">has_not_expired_in_cache</span></span>(<span>self, key: Tuple[str, TransformOptions]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_not_expired_in_cache(self, key: Tuple[str, TransformOptions]) -&gt; bool:
    return key in self.store and self.store[key].ttl &gt;= datetime.now()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue"><code class="flex name class">
<span>class <span class="ident">ExpirableValue</span></span>
<span>(</span><span>value: ForwardRef('str | bytes | Dict[str, Any]'), ttl: ForwardRef('datetime'))</span>
</code></dt>
<dd>
<div class="desc"><p>ExpirableValue(value, ttl)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpirableValue(NamedTuple):
    value: str | bytes | Dict[str, Any]
    ttl: datetime</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl"><code class="name">var <span class="ident">ttl</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value"><code class="name">var <span class="ident">value</span> : Union[str, bytes, Dict[str, Any]]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.parameters" href="index.html">aws_lambda_powertools.utilities.parameters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.clear_caches" href="#aws_lambda_powertools.utilities.parameters.base.clear_caches">clear_caches</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.get_transform_method" href="#aws_lambda_powertools.utilities.parameters.base.get_transform_method">get_transform_method</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.transform_value" href="#aws_lambda_powertools.utilities.parameters.base.transform_value">transform_value</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider">BaseProvider</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.add_to_cache" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.add_to_cache">add_to_cache</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.clear_cache" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.clear_cache">clear_cache</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.get">get</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.get_multiple">get_multiple</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.has_not_expired_in_cache" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.has_not_expired_in_cache">has_not_expired_in_cache</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.BaseProvider.store" href="#aws_lambda_powertools.utilities.parameters.base.BaseProvider.store">store</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue">ExpirableValue</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue.ttl">ttl</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value" href="#aws_lambda_powertools.utilities.parameters.base.ExpirableValue.value">value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>