<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.idempotency.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.idempotency.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import logging
from copy import deepcopy
from typing import Any, Callable, Dict, Optional, Tuple

from aws_lambda_powertools.utilities.idempotency.config import IdempotencyConfig
from aws_lambda_powertools.utilities.idempotency.exceptions import (
    IdempotencyAlreadyInProgressError,
    IdempotencyInconsistentStateError,
    IdempotencyItemAlreadyExistsError,
    IdempotencyItemNotFoundError,
    IdempotencyKeyError,
    IdempotencyPersistenceLayerError,
    IdempotencyValidationError,
)
from aws_lambda_powertools.utilities.idempotency.persistence.base import (
    STATUS_CONSTANTS,
    BasePersistenceLayer,
    DataRecord,
)

MAX_RETRIES = 2
logger = logging.getLogger(__name__)


def _prepare_data(data: Any) -&gt; Any:
    &#34;&#34;&#34;Prepare data for json serialization.

    We will convert Python dataclasses, pydantic models or event source data classes to a dict,
    otherwise return data as-is.
    &#34;&#34;&#34;
    if hasattr(data, &#34;__dataclass_fields__&#34;):
        import dataclasses

        return dataclasses.asdict(data)

    if callable(getattr(data, &#34;dict&#34;, None)):
        return data.dict()

    return getattr(data, &#34;raw_event&#34;, data)


class IdempotencyHandler:
    &#34;&#34;&#34;
    Base class to orchestrate calls to persistence layer.
    &#34;&#34;&#34;

    def __init__(
        self,
        function: Callable,
        function_payload: Any,
        config: IdempotencyConfig,
        persistence_store: BasePersistenceLayer,
        function_args: Optional[Tuple] = None,
        function_kwargs: Optional[Dict] = None,
    ):
        &#34;&#34;&#34;
        Initialize the IdempotencyHandler

        Parameters
        ----------
        function_payload: Any
            JSON Serializable payload to be hashed
        config: IdempotencyConfig
            Idempotency Configuration
        persistence_store : BasePersistenceLayer
            Instance of persistence layer to store idempotency records
        function_args: Optional[Tuple]
            Function arguments
        function_kwargs: Optional[Dict]
            Function keyword arguments
        &#34;&#34;&#34;
        self.function = function
        self.data = deepcopy(_prepare_data(function_payload))
        self.fn_args = function_args
        self.fn_kwargs = function_kwargs
        self.config = config

        persistence_store.configure(config, f&#34;{self.function.__module__}.{self.function.__qualname__}&#34;)
        self.persistence_store = persistence_store

    def handle(self) -&gt; Any:
        &#34;&#34;&#34;
        Main entry point for handling idempotent execution of a function.

        Returns
        -------
        Any
            Function response

        &#34;&#34;&#34;
        # IdempotencyInconsistentStateError can happen under rare but expected cases
        # when persistent state changes in the small time between put &amp; get requests.
        # In most cases we can retry successfully on this exception.
        for i in range(MAX_RETRIES + 1):  # pragma: no cover
            try:
                return self._process_idempotency()
            except IdempotencyInconsistentStateError:
                if i == MAX_RETRIES:
                    raise  # Bubble up when exceeded max tries

    def _process_idempotency(self):
        try:
            # We call save_inprogress first as an optimization for the most common case where no idempotent record
            # already exists. If it succeeds, there&#39;s no need to call get_record.
            self.persistence_store.save_inprogress(
                data=self.data, remaining_time_in_millis=self._get_remaining_time_in_millis()
            )
        except IdempotencyKeyError:
            raise
        except IdempotencyItemAlreadyExistsError:
            # Now we know the item already exists, we can retrieve it
            record = self._get_idempotency_record()
            return self._handle_for_status(record)
        except Exception as exc:
            raise IdempotencyPersistenceLayerError(
                &#34;Failed to save in progress record to idempotency store&#34;, exc
            ) from exc

        return self._get_function_response()

    def _get_remaining_time_in_millis(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Tries to determine the remaining time available for the current lambda invocation.

        This only works if the idempotent handler decorator is used, since we need to access the lambda context.
        However, this could be improved if we start storing the lambda context globally during the invocation. One
        way to do this is to register the lambda context when configuring the IdempotencyConfig object.

        Returns
        -------
        Optional[int]
            Remaining time in millis, or None if the remaining time cannot be determined.
        &#34;&#34;&#34;

        if self.config.lambda_context is not None:
            return self.config.lambda_context.get_remaining_time_in_millis()

        return None

    def _get_idempotency_record(self) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve the idempotency record from the persistence layer.

        Raises
        ----------
        IdempotencyInconsistentStateError

        &#34;&#34;&#34;
        try:
            data_record = self.persistence_store.get_record(data=self.data)
        except IdempotencyItemNotFoundError:
            # This code path will only be triggered if the record is removed between save_inprogress and get_record.
            logger.debug(
                f&#34;An existing idempotency record was deleted before we could fetch it. Proceeding with {self.function}&#34;
            )
            raise IdempotencyInconsistentStateError(&#34;save_inprogress and get_record return inconsistent results.&#34;)

        # Allow this exception to bubble up
        except IdempotencyValidationError:
            raise

        # Wrap remaining unhandled exceptions with IdempotencyPersistenceLayerError to ease exception handling for
        # clients
        except Exception as exc:
            raise IdempotencyPersistenceLayerError(&#34;Failed to get record from idempotency store&#34;, exc) from exc

        return data_record

    def _handle_for_status(self, data_record: DataRecord) -&gt; Optional[Dict[Any, Any]]:
        &#34;&#34;&#34;
        Take appropriate action based on data_record&#39;s status

        Parameters
        ----------
        data_record: DataRecord

        Returns
        -------
        Optional[Dict[Any, Any]
            Function&#39;s response previously used for this idempotency key, if it has successfully executed already.

        Raises
        ------
        AlreadyInProgressError
            A function execution is already in progress
        IdempotencyInconsistentStateError
            The persistence store reports inconsistent states across different requests. Retryable.
        &#34;&#34;&#34;
        # This code path will only be triggered if the record becomes expired between the save_inprogress call and here
        if data_record.status == STATUS_CONSTANTS[&#34;EXPIRED&#34;]:
            raise IdempotencyInconsistentStateError(&#34;save_inprogress and get_record return inconsistent results.&#34;)

        if data_record.status == STATUS_CONSTANTS[&#34;INPROGRESS&#34;]:
            if data_record.in_progress_expiry_timestamp is not None and data_record.in_progress_expiry_timestamp &lt; int(
                datetime.datetime.now().timestamp() * 1000
            ):
                raise IdempotencyInconsistentStateError(
                    &#34;item should have been expired in-progress because it already time-outed.&#34;
                )

            raise IdempotencyAlreadyInProgressError(
                f&#34;Execution already in progress with idempotency key: &#34;
                f&#34;{self.persistence_store.event_key_jmespath}={data_record.idempotency_key}&#34;
            )

        return data_record.response_json_as_dict()

    def _get_function_response(self):
        try:
            response = self.function(*self.fn_args, **self.fn_kwargs)
        except Exception as handler_exception:
            # We need these nested blocks to preserve function&#39;s exception in case the persistence store operation
            # also raises an exception
            try:
                self.persistence_store.delete_record(data=self.data, exception=handler_exception)
            except Exception as delete_exception:
                raise IdempotencyPersistenceLayerError(
                    &#34;Failed to delete record from idempotency store&#34;, delete_exception
                ) from delete_exception
            raise

        else:
            try:
                self.persistence_store.save_success(data=self.data, result=response)
            except Exception as save_exception:
                raise IdempotencyPersistenceLayerError(
                    &#34;Failed to update record state to success in idempotency store&#34;, save_exception
                ) from save_exception

        return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler"><code class="flex name class">
<span>class <span class="ident">IdempotencyHandler</span></span>
<span>(</span><span>function: Callable, function_payload: Any, config: <a title="aws_lambda_powertools.utilities.idempotency.config.IdempotencyConfig" href="config.html#aws_lambda_powertools.utilities.idempotency.config.IdempotencyConfig">IdempotencyConfig</a>, persistence_store: <a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer" href="persistence/base.html#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer">BasePersistenceLayer</a>, function_args: Optional[Tuple] = None, function_kwargs: Optional[Dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class to orchestrate calls to persistence layer.</p>
<p>Initialize the IdempotencyHandler</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function_payload</code></strong> :&ensp;<code>Any</code></dt>
<dd>JSON Serializable payload to be hashed</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>IdempotencyConfig</code></dt>
<dd>Idempotency Configuration</dd>
<dt><strong><code>persistence_store</code></strong> :&ensp;<code>BasePersistenceLayer</code></dt>
<dd>Instance of persistence layer to store idempotency records</dd>
<dt><strong><code>function_args</code></strong> :&ensp;<code>Optional[Tuple]</code></dt>
<dd>Function arguments</dd>
<dt><strong><code>function_kwargs</code></strong> :&ensp;<code>Optional[Dict]</code></dt>
<dd>Function keyword arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdempotencyHandler:
    &#34;&#34;&#34;
    Base class to orchestrate calls to persistence layer.
    &#34;&#34;&#34;

    def __init__(
        self,
        function: Callable,
        function_payload: Any,
        config: IdempotencyConfig,
        persistence_store: BasePersistenceLayer,
        function_args: Optional[Tuple] = None,
        function_kwargs: Optional[Dict] = None,
    ):
        &#34;&#34;&#34;
        Initialize the IdempotencyHandler

        Parameters
        ----------
        function_payload: Any
            JSON Serializable payload to be hashed
        config: IdempotencyConfig
            Idempotency Configuration
        persistence_store : BasePersistenceLayer
            Instance of persistence layer to store idempotency records
        function_args: Optional[Tuple]
            Function arguments
        function_kwargs: Optional[Dict]
            Function keyword arguments
        &#34;&#34;&#34;
        self.function = function
        self.data = deepcopy(_prepare_data(function_payload))
        self.fn_args = function_args
        self.fn_kwargs = function_kwargs
        self.config = config

        persistence_store.configure(config, f&#34;{self.function.__module__}.{self.function.__qualname__}&#34;)
        self.persistence_store = persistence_store

    def handle(self) -&gt; Any:
        &#34;&#34;&#34;
        Main entry point for handling idempotent execution of a function.

        Returns
        -------
        Any
            Function response

        &#34;&#34;&#34;
        # IdempotencyInconsistentStateError can happen under rare but expected cases
        # when persistent state changes in the small time between put &amp; get requests.
        # In most cases we can retry successfully on this exception.
        for i in range(MAX_RETRIES + 1):  # pragma: no cover
            try:
                return self._process_idempotency()
            except IdempotencyInconsistentStateError:
                if i == MAX_RETRIES:
                    raise  # Bubble up when exceeded max tries

    def _process_idempotency(self):
        try:
            # We call save_inprogress first as an optimization for the most common case where no idempotent record
            # already exists. If it succeeds, there&#39;s no need to call get_record.
            self.persistence_store.save_inprogress(
                data=self.data, remaining_time_in_millis=self._get_remaining_time_in_millis()
            )
        except IdempotencyKeyError:
            raise
        except IdempotencyItemAlreadyExistsError:
            # Now we know the item already exists, we can retrieve it
            record = self._get_idempotency_record()
            return self._handle_for_status(record)
        except Exception as exc:
            raise IdempotencyPersistenceLayerError(
                &#34;Failed to save in progress record to idempotency store&#34;, exc
            ) from exc

        return self._get_function_response()

    def _get_remaining_time_in_millis(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Tries to determine the remaining time available for the current lambda invocation.

        This only works if the idempotent handler decorator is used, since we need to access the lambda context.
        However, this could be improved if we start storing the lambda context globally during the invocation. One
        way to do this is to register the lambda context when configuring the IdempotencyConfig object.

        Returns
        -------
        Optional[int]
            Remaining time in millis, or None if the remaining time cannot be determined.
        &#34;&#34;&#34;

        if self.config.lambda_context is not None:
            return self.config.lambda_context.get_remaining_time_in_millis()

        return None

    def _get_idempotency_record(self) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve the idempotency record from the persistence layer.

        Raises
        ----------
        IdempotencyInconsistentStateError

        &#34;&#34;&#34;
        try:
            data_record = self.persistence_store.get_record(data=self.data)
        except IdempotencyItemNotFoundError:
            # This code path will only be triggered if the record is removed between save_inprogress and get_record.
            logger.debug(
                f&#34;An existing idempotency record was deleted before we could fetch it. Proceeding with {self.function}&#34;
            )
            raise IdempotencyInconsistentStateError(&#34;save_inprogress and get_record return inconsistent results.&#34;)

        # Allow this exception to bubble up
        except IdempotencyValidationError:
            raise

        # Wrap remaining unhandled exceptions with IdempotencyPersistenceLayerError to ease exception handling for
        # clients
        except Exception as exc:
            raise IdempotencyPersistenceLayerError(&#34;Failed to get record from idempotency store&#34;, exc) from exc

        return data_record

    def _handle_for_status(self, data_record: DataRecord) -&gt; Optional[Dict[Any, Any]]:
        &#34;&#34;&#34;
        Take appropriate action based on data_record&#39;s status

        Parameters
        ----------
        data_record: DataRecord

        Returns
        -------
        Optional[Dict[Any, Any]
            Function&#39;s response previously used for this idempotency key, if it has successfully executed already.

        Raises
        ------
        AlreadyInProgressError
            A function execution is already in progress
        IdempotencyInconsistentStateError
            The persistence store reports inconsistent states across different requests. Retryable.
        &#34;&#34;&#34;
        # This code path will only be triggered if the record becomes expired between the save_inprogress call and here
        if data_record.status == STATUS_CONSTANTS[&#34;EXPIRED&#34;]:
            raise IdempotencyInconsistentStateError(&#34;save_inprogress and get_record return inconsistent results.&#34;)

        if data_record.status == STATUS_CONSTANTS[&#34;INPROGRESS&#34;]:
            if data_record.in_progress_expiry_timestamp is not None and data_record.in_progress_expiry_timestamp &lt; int(
                datetime.datetime.now().timestamp() * 1000
            ):
                raise IdempotencyInconsistentStateError(
                    &#34;item should have been expired in-progress because it already time-outed.&#34;
                )

            raise IdempotencyAlreadyInProgressError(
                f&#34;Execution already in progress with idempotency key: &#34;
                f&#34;{self.persistence_store.event_key_jmespath}={data_record.idempotency_key}&#34;
            )

        return data_record.response_json_as_dict()

    def _get_function_response(self):
        try:
            response = self.function(*self.fn_args, **self.fn_kwargs)
        except Exception as handler_exception:
            # We need these nested blocks to preserve function&#39;s exception in case the persistence store operation
            # also raises an exception
            try:
                self.persistence_store.delete_record(data=self.data, exception=handler_exception)
            except Exception as delete_exception:
                raise IdempotencyPersistenceLayerError(
                    &#34;Failed to delete record from idempotency store&#34;, delete_exception
                ) from delete_exception
            raise

        else:
            try:
                self.persistence_store.save_success(data=self.data, result=response)
            except Exception as save_exception:
                raise IdempotencyPersistenceLayerError(
                    &#34;Failed to update record state to success in idempotency store&#34;, save_exception
                ) from save_exception

        return response</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler.handle"><code class="name flex">
<span>def <span class="ident">handle</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Main entry point for handling idempotent execution of a function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Function response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle(self) -&gt; Any:
    &#34;&#34;&#34;
    Main entry point for handling idempotent execution of a function.

    Returns
    -------
    Any
        Function response

    &#34;&#34;&#34;
    # IdempotencyInconsistentStateError can happen under rare but expected cases
    # when persistent state changes in the small time between put &amp; get requests.
    # In most cases we can retry successfully on this exception.
    for i in range(MAX_RETRIES + 1):  # pragma: no cover
        try:
            return self._process_idempotency()
        except IdempotencyInconsistentStateError:
            if i == MAX_RETRIES:
                raise  # Bubble up when exceeded max tries</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.idempotency" href="index.html">aws_lambda_powertools.utilities.idempotency</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler" href="#aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler">IdempotencyHandler</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler.handle" href="#aws_lambda_powertools.utilities.idempotency.base.IdempotencyHandler.handle">handle</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>