<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.idempotency.persistence.base API documentation</title>
<meta name="description" content="Persistence layers supporting idempotency" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.idempotency.persistence.base</code></h1>
</header>
<section id="section-intro">
<p>Persistence layers supporting idempotency</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Persistence layers supporting idempotency
&#34;&#34;&#34;
import datetime
import hashlib
import json
import logging
import os
import warnings
from abc import ABC, abstractmethod
from types import MappingProxyType
from typing import Any, Dict, Optional

import jmespath

from aws_lambda_powertools.shared import constants
from aws_lambda_powertools.shared.cache_dict import LRUDict
from aws_lambda_powertools.shared.json_encoder import Encoder
from aws_lambda_powertools.utilities.idempotency.config import IdempotencyConfig
from aws_lambda_powertools.utilities.idempotency.exceptions import (
    IdempotencyInvalidStatusError,
    IdempotencyItemAlreadyExistsError,
    IdempotencyKeyError,
    IdempotencyValidationError,
)
from aws_lambda_powertools.utilities.jmespath_utils import PowertoolsFunctions

logger = logging.getLogger(__name__)

STATUS_CONSTANTS = MappingProxyType({&#34;INPROGRESS&#34;: &#34;INPROGRESS&#34;, &#34;COMPLETED&#34;: &#34;COMPLETED&#34;, &#34;EXPIRED&#34;: &#34;EXPIRED&#34;})


class DataRecord:
    &#34;&#34;&#34;
    Data Class for idempotency records.
    &#34;&#34;&#34;

    def __init__(
        self,
        idempotency_key: str,
        status: str = &#34;&#34;,
        expiry_timestamp: Optional[int] = None,
        in_progress_expiry_timestamp: Optional[int] = None,
        response_data: str = &#34;&#34;,
        payload_hash: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;

        Parameters
        ----------
        idempotency_key: str
            hashed representation of the idempotent data
        status: str, optional
            status of the idempotent record
        expiry_timestamp: int, optional
            time before the record should expire, in seconds
        in_progress_expiry_timestamp: int, optional
            time before the record should expire while in the INPROGRESS state, in seconds
        payload_hash: str, optional
            hashed representation of payload
        response_data: str, optional
            response data from previous executions using the record
        &#34;&#34;&#34;
        self.idempotency_key = idempotency_key
        self.payload_hash = payload_hash
        self.expiry_timestamp = expiry_timestamp
        self.in_progress_expiry_timestamp = in_progress_expiry_timestamp
        self._status = status
        self.response_data = response_data

    @property
    def is_expired(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if data record is expired

        Returns
        -------
        bool
            Whether the record is currently expired or not
        &#34;&#34;&#34;
        return bool(self.expiry_timestamp and int(datetime.datetime.now().timestamp()) &gt; self.expiry_timestamp)

    @property
    def status(self) -&gt; str:
        &#34;&#34;&#34;
        Get status of data record

        Returns
        -------
        str
        &#34;&#34;&#34;
        if self.is_expired:
            return STATUS_CONSTANTS[&#34;EXPIRED&#34;]
        elif self._status in STATUS_CONSTANTS.values():
            return self._status
        else:
            raise IdempotencyInvalidStatusError(self._status)

    def response_json_as_dict(self) -&gt; Optional[dict]:
        &#34;&#34;&#34;
        Get response data deserialized to python dict

        Returns
        -------
        Optional[dict]
            previous response data deserialized
        &#34;&#34;&#34;
        return json.loads(self.response_data) if self.response_data else None


class BasePersistenceLayer(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Idempotency persistence layer.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the defaults&#34;&#34;&#34;
        self.function_name = &#34;&#34;
        self.configured = False
        self.event_key_jmespath: str = &#34;&#34;
        self.event_key_compiled_jmespath = None
        self.jmespath_options: Optional[dict] = None
        self.payload_validation_enabled = False
        self.validation_key_jmespath = None
        self.raise_on_no_idempotency_key = False
        self.expires_after_seconds: int = 60 * 60  # 1 hour default
        self.use_local_cache = False
        self.hash_function = hashlib.md5

    def configure(self, config: IdempotencyConfig, function_name: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Initialize the base persistence layer from the configuration settings

        Parameters
        ----------
        config: IdempotencyConfig
            Idempotency configuration settings
        function_name: str, Optional
            The name of the function being decorated
        &#34;&#34;&#34;
        self.function_name = f&#34;{os.getenv(constants.LAMBDA_FUNCTION_NAME_ENV, &#39;test-func&#39;)}.{function_name or &#39;&#39;}&#34;

        if self.configured:
            # Prevent being reconfigured multiple times
            return
        self.configured = True

        self.event_key_jmespath = config.event_key_jmespath
        if config.event_key_jmespath:
            self.event_key_compiled_jmespath = jmespath.compile(config.event_key_jmespath)
        self.jmespath_options = config.jmespath_options
        if not self.jmespath_options:
            self.jmespath_options = {&#34;custom_functions&#34;: PowertoolsFunctions()}
        if config.payload_validation_jmespath:
            self.validation_key_jmespath = jmespath.compile(config.payload_validation_jmespath)
            self.payload_validation_enabled = True
        self.raise_on_no_idempotency_key = config.raise_on_no_idempotency_key
        self.expires_after_seconds = config.expires_after_seconds
        self.use_local_cache = config.use_local_cache
        if self.use_local_cache:
            self._cache = LRUDict(max_items=config.local_cache_max_items)
        self.hash_function = getattr(hashlib, config.hash_function)

    def _get_hashed_idempotency_key(self, data: Dict[str, Any]) -&gt; str:
        &#34;&#34;&#34;
        Extract idempotency key and return a hashed representation

        Parameters
        ----------
        data: Dict[str, Any]
            Incoming data

        Returns
        -------
        str
            Hashed representation of the data extracted by the jmespath expression

        &#34;&#34;&#34;
        if self.event_key_jmespath:
            data = self.event_key_compiled_jmespath.search(data, options=jmespath.Options(**self.jmespath_options))

        if self.is_missing_idempotency_key(data=data):
            if self.raise_on_no_idempotency_key:
                raise IdempotencyKeyError(&#34;No data found to create a hashed idempotency_key&#34;)
            warnings.warn(f&#34;No value found for idempotency_key. jmespath: {self.event_key_jmespath}&#34;, stacklevel=2)

        generated_hash = self._generate_hash(data=data)
        return f&#34;{self.function_name}#{generated_hash}&#34;

    @staticmethod
    def is_missing_idempotency_key(data) -&gt; bool:
        if type(data).__name__ in (&#34;tuple&#34;, &#34;list&#34;, &#34;dict&#34;):
            return all(x is None for x in data)
        return not data

    def _get_hashed_payload(self, data: Dict[str, Any]) -&gt; str:
        &#34;&#34;&#34;
        Extract payload using validation key jmespath and return a hashed representation

        Parameters
        ----------
        data: Dict[str, Any]
            Payload

        Returns
        -------
        str
            Hashed representation of the data extracted by the jmespath expression

        &#34;&#34;&#34;
        if not self.payload_validation_enabled:
            return &#34;&#34;
        data = self.validation_key_jmespath.search(data)
        return self._generate_hash(data=data)

    def _generate_hash(self, data: Any) -&gt; str:
        &#34;&#34;&#34;
        Generate a hash value from the provided data

        Parameters
        ----------
        data: Any
            The data to hash

        Returns
        -------
        str
            Hashed representation of the provided data

        &#34;&#34;&#34;
        hashed_data = self.hash_function(json.dumps(data, cls=Encoder, sort_keys=True).encode())
        return hashed_data.hexdigest()

    def _validate_payload(self, data: Dict[str, Any], data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Validate that the hashed payload matches data provided and stored data record

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        data_record: DataRecord
            DataRecord instance

        Raises
        ----------
        IdempotencyValidationError
            Payload doesn&#39;t match the stored record for the given idempotency key

        &#34;&#34;&#34;
        if self.payload_validation_enabled:
            data_hash = self._get_hashed_payload(data=data)
            if data_record.payload_hash != data_hash:
                raise IdempotencyValidationError(&#34;Payload does not match stored record for this event key&#34;)

    def _get_expiry_timestamp(self) -&gt; int:
        &#34;&#34;&#34;

        Returns
        -------
        int
            unix timestamp of expiry date for idempotency record

        &#34;&#34;&#34;
        now = datetime.datetime.now()
        period = datetime.timedelta(seconds=self.expires_after_seconds)
        return int((now + period).timestamp())

    def _save_to_cache(self, data_record: DataRecord):
        &#34;&#34;&#34;
        Save data_record to local cache except when status is &#34;INPROGRESS&#34;

        NOTE: We can&#39;t cache &#34;INPROGRESS&#34; records as we have no way to reflect updates that can happen outside of the
        execution environment

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance

        Returns
        -------

        &#34;&#34;&#34;
        if not self.use_local_cache:
            return
        if data_record.status == STATUS_CONSTANTS[&#34;INPROGRESS&#34;]:
            return
        self._cache[data_record.idempotency_key] = data_record

    def _retrieve_from_cache(self, idempotency_key: str):
        if not self.use_local_cache:
            return
        cached_record = self._cache.get(key=idempotency_key)
        if cached_record:
            if not cached_record.is_expired:
                return cached_record
            logger.debug(f&#34;Removing expired local cache record for idempotency key: {idempotency_key}&#34;)
            self._delete_from_cache(idempotency_key=idempotency_key)

    def _delete_from_cache(self, idempotency_key: str):
        if not self.use_local_cache:
            return
        if idempotency_key in self._cache:
            del self._cache[idempotency_key]

    def save_success(self, data: Dict[str, Any], result: dict) -&gt; None:
        &#34;&#34;&#34;
        Save record of function&#39;s execution completing successfully

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        result: dict
            The response from function
        &#34;&#34;&#34;
        response_data = json.dumps(result, cls=Encoder, sort_keys=True)

        data_record = DataRecord(
            idempotency_key=self._get_hashed_idempotency_key(data=data),
            status=STATUS_CONSTANTS[&#34;COMPLETED&#34;],
            expiry_timestamp=self._get_expiry_timestamp(),
            response_data=response_data,
            payload_hash=self._get_hashed_payload(data=data),
        )
        logger.debug(
            f&#34;Function successfully executed. Saving record to persistence store with &#34;
            f&#34;idempotency key: {data_record.idempotency_key}&#34;
        )
        self._update_record(data_record=data_record)

        self._save_to_cache(data_record=data_record)

    def save_inprogress(self, data: Dict[str, Any], remaining_time_in_millis: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Save record of function&#39;s execution being in progress

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        remaining_time_in_millis: Optional[int]
            If expiry of in-progress invocations is enabled, this will contain the remaining time available in millis
        &#34;&#34;&#34;
        data_record = DataRecord(
            idempotency_key=self._get_hashed_idempotency_key(data=data),
            status=STATUS_CONSTANTS[&#34;INPROGRESS&#34;],
            expiry_timestamp=self._get_expiry_timestamp(),
            payload_hash=self._get_hashed_payload(data=data),
        )

        if remaining_time_in_millis:
            now = datetime.datetime.now()
            period = datetime.timedelta(milliseconds=remaining_time_in_millis)
            timestamp = (now + period).timestamp()

            data_record.in_progress_expiry_timestamp = int(timestamp * 1000)
        else:
            warnings.warn(
                &#34;Couldn&#39;t determine the remaining time left. &#34;
                &#34;Did you call register_lambda_context on IdempotencyConfig?&#34;,
                stacklevel=2,
            )

        logger.debug(f&#34;Saving in progress record for idempotency key: {data_record.idempotency_key}&#34;)

        if self._retrieve_from_cache(idempotency_key=data_record.idempotency_key):
            raise IdempotencyItemAlreadyExistsError

        self._put_record(data_record=data_record)

    def delete_record(self, data: Dict[str, Any], exception: Exception):
        &#34;&#34;&#34;
        Delete record from the persistence store

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        exception
            The exception raised by the function
        &#34;&#34;&#34;
        data_record = DataRecord(idempotency_key=self._get_hashed_idempotency_key(data=data))

        logger.debug(
            f&#34;Function raised an exception ({type(exception).__name__}). Clearing in progress record in persistence &#34;
            f&#34;store for idempotency key: {data_record.idempotency_key}&#34;
        )
        self._delete_record(data_record=data_record)

        self._delete_from_cache(idempotency_key=data_record.idempotency_key)

    def get_record(self, data: Dict[str, Any]) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve idempotency key for data provided, fetch from persistence store, and convert to DataRecord.

        Parameters
        ----------
        data: Dict[str, Any]
            Payload

        Returns
        -------
        DataRecord
            DataRecord representation of existing record found in persistence store

        Raises
        ------
        IdempotencyItemNotFoundError
            Exception raised if no record exists in persistence store with the idempotency key
        IdempotencyValidationError
            Payload doesn&#39;t match the stored record for the given idempotency key
        &#34;&#34;&#34;

        idempotency_key = self._get_hashed_idempotency_key(data=data)

        cached_record = self._retrieve_from_cache(idempotency_key=idempotency_key)
        if cached_record:
            logger.debug(f&#34;Idempotency record found in cache with idempotency key: {idempotency_key}&#34;)
            self._validate_payload(data=data, data_record=cached_record)
            return cached_record

        record = self._get_record(idempotency_key=idempotency_key)

        self._save_to_cache(data_record=record)

        self._validate_payload(data=data, data_record=record)
        return record

    @abstractmethod
    def _get_record(self, idempotency_key) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve item from persistence store using idempotency key and return it as a DataRecord instance.

        Parameters
        ----------
        idempotency_key

        Returns
        -------
        DataRecord
            DataRecord representation of existing record found in persistence store

        Raises
        ------
        IdempotencyItemNotFoundError
            Exception raised if no record exists in persistence store with the idempotency key
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def _put_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Add a DataRecord to persistence store if it does not already exist with that key. Raise ItemAlreadyExists
        if a non-expired entry already exists.

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError

    @abstractmethod
    def _update_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Update item in persistence store

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError

    @abstractmethod
    def _delete_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Remove item from persistence store
        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer"><code class="flex name class">
<span>class <span class="ident">BasePersistenceLayer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Base Class for Idempotency persistence layer.</p>
<p>Initialize the defaults</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePersistenceLayer(ABC):
    &#34;&#34;&#34;
    Abstract Base Class for Idempotency persistence layer.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the defaults&#34;&#34;&#34;
        self.function_name = &#34;&#34;
        self.configured = False
        self.event_key_jmespath: str = &#34;&#34;
        self.event_key_compiled_jmespath = None
        self.jmespath_options: Optional[dict] = None
        self.payload_validation_enabled = False
        self.validation_key_jmespath = None
        self.raise_on_no_idempotency_key = False
        self.expires_after_seconds: int = 60 * 60  # 1 hour default
        self.use_local_cache = False
        self.hash_function = hashlib.md5

    def configure(self, config: IdempotencyConfig, function_name: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Initialize the base persistence layer from the configuration settings

        Parameters
        ----------
        config: IdempotencyConfig
            Idempotency configuration settings
        function_name: str, Optional
            The name of the function being decorated
        &#34;&#34;&#34;
        self.function_name = f&#34;{os.getenv(constants.LAMBDA_FUNCTION_NAME_ENV, &#39;test-func&#39;)}.{function_name or &#39;&#39;}&#34;

        if self.configured:
            # Prevent being reconfigured multiple times
            return
        self.configured = True

        self.event_key_jmespath = config.event_key_jmespath
        if config.event_key_jmespath:
            self.event_key_compiled_jmespath = jmespath.compile(config.event_key_jmespath)
        self.jmespath_options = config.jmespath_options
        if not self.jmespath_options:
            self.jmespath_options = {&#34;custom_functions&#34;: PowertoolsFunctions()}
        if config.payload_validation_jmespath:
            self.validation_key_jmespath = jmespath.compile(config.payload_validation_jmespath)
            self.payload_validation_enabled = True
        self.raise_on_no_idempotency_key = config.raise_on_no_idempotency_key
        self.expires_after_seconds = config.expires_after_seconds
        self.use_local_cache = config.use_local_cache
        if self.use_local_cache:
            self._cache = LRUDict(max_items=config.local_cache_max_items)
        self.hash_function = getattr(hashlib, config.hash_function)

    def _get_hashed_idempotency_key(self, data: Dict[str, Any]) -&gt; str:
        &#34;&#34;&#34;
        Extract idempotency key and return a hashed representation

        Parameters
        ----------
        data: Dict[str, Any]
            Incoming data

        Returns
        -------
        str
            Hashed representation of the data extracted by the jmespath expression

        &#34;&#34;&#34;
        if self.event_key_jmespath:
            data = self.event_key_compiled_jmespath.search(data, options=jmespath.Options(**self.jmespath_options))

        if self.is_missing_idempotency_key(data=data):
            if self.raise_on_no_idempotency_key:
                raise IdempotencyKeyError(&#34;No data found to create a hashed idempotency_key&#34;)
            warnings.warn(f&#34;No value found for idempotency_key. jmespath: {self.event_key_jmespath}&#34;, stacklevel=2)

        generated_hash = self._generate_hash(data=data)
        return f&#34;{self.function_name}#{generated_hash}&#34;

    @staticmethod
    def is_missing_idempotency_key(data) -&gt; bool:
        if type(data).__name__ in (&#34;tuple&#34;, &#34;list&#34;, &#34;dict&#34;):
            return all(x is None for x in data)
        return not data

    def _get_hashed_payload(self, data: Dict[str, Any]) -&gt; str:
        &#34;&#34;&#34;
        Extract payload using validation key jmespath and return a hashed representation

        Parameters
        ----------
        data: Dict[str, Any]
            Payload

        Returns
        -------
        str
            Hashed representation of the data extracted by the jmespath expression

        &#34;&#34;&#34;
        if not self.payload_validation_enabled:
            return &#34;&#34;
        data = self.validation_key_jmespath.search(data)
        return self._generate_hash(data=data)

    def _generate_hash(self, data: Any) -&gt; str:
        &#34;&#34;&#34;
        Generate a hash value from the provided data

        Parameters
        ----------
        data: Any
            The data to hash

        Returns
        -------
        str
            Hashed representation of the provided data

        &#34;&#34;&#34;
        hashed_data = self.hash_function(json.dumps(data, cls=Encoder, sort_keys=True).encode())
        return hashed_data.hexdigest()

    def _validate_payload(self, data: Dict[str, Any], data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Validate that the hashed payload matches data provided and stored data record

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        data_record: DataRecord
            DataRecord instance

        Raises
        ----------
        IdempotencyValidationError
            Payload doesn&#39;t match the stored record for the given idempotency key

        &#34;&#34;&#34;
        if self.payload_validation_enabled:
            data_hash = self._get_hashed_payload(data=data)
            if data_record.payload_hash != data_hash:
                raise IdempotencyValidationError(&#34;Payload does not match stored record for this event key&#34;)

    def _get_expiry_timestamp(self) -&gt; int:
        &#34;&#34;&#34;

        Returns
        -------
        int
            unix timestamp of expiry date for idempotency record

        &#34;&#34;&#34;
        now = datetime.datetime.now()
        period = datetime.timedelta(seconds=self.expires_after_seconds)
        return int((now + period).timestamp())

    def _save_to_cache(self, data_record: DataRecord):
        &#34;&#34;&#34;
        Save data_record to local cache except when status is &#34;INPROGRESS&#34;

        NOTE: We can&#39;t cache &#34;INPROGRESS&#34; records as we have no way to reflect updates that can happen outside of the
        execution environment

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance

        Returns
        -------

        &#34;&#34;&#34;
        if not self.use_local_cache:
            return
        if data_record.status == STATUS_CONSTANTS[&#34;INPROGRESS&#34;]:
            return
        self._cache[data_record.idempotency_key] = data_record

    def _retrieve_from_cache(self, idempotency_key: str):
        if not self.use_local_cache:
            return
        cached_record = self._cache.get(key=idempotency_key)
        if cached_record:
            if not cached_record.is_expired:
                return cached_record
            logger.debug(f&#34;Removing expired local cache record for idempotency key: {idempotency_key}&#34;)
            self._delete_from_cache(idempotency_key=idempotency_key)

    def _delete_from_cache(self, idempotency_key: str):
        if not self.use_local_cache:
            return
        if idempotency_key in self._cache:
            del self._cache[idempotency_key]

    def save_success(self, data: Dict[str, Any], result: dict) -&gt; None:
        &#34;&#34;&#34;
        Save record of function&#39;s execution completing successfully

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        result: dict
            The response from function
        &#34;&#34;&#34;
        response_data = json.dumps(result, cls=Encoder, sort_keys=True)

        data_record = DataRecord(
            idempotency_key=self._get_hashed_idempotency_key(data=data),
            status=STATUS_CONSTANTS[&#34;COMPLETED&#34;],
            expiry_timestamp=self._get_expiry_timestamp(),
            response_data=response_data,
            payload_hash=self._get_hashed_payload(data=data),
        )
        logger.debug(
            f&#34;Function successfully executed. Saving record to persistence store with &#34;
            f&#34;idempotency key: {data_record.idempotency_key}&#34;
        )
        self._update_record(data_record=data_record)

        self._save_to_cache(data_record=data_record)

    def save_inprogress(self, data: Dict[str, Any], remaining_time_in_millis: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Save record of function&#39;s execution being in progress

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        remaining_time_in_millis: Optional[int]
            If expiry of in-progress invocations is enabled, this will contain the remaining time available in millis
        &#34;&#34;&#34;
        data_record = DataRecord(
            idempotency_key=self._get_hashed_idempotency_key(data=data),
            status=STATUS_CONSTANTS[&#34;INPROGRESS&#34;],
            expiry_timestamp=self._get_expiry_timestamp(),
            payload_hash=self._get_hashed_payload(data=data),
        )

        if remaining_time_in_millis:
            now = datetime.datetime.now()
            period = datetime.timedelta(milliseconds=remaining_time_in_millis)
            timestamp = (now + period).timestamp()

            data_record.in_progress_expiry_timestamp = int(timestamp * 1000)
        else:
            warnings.warn(
                &#34;Couldn&#39;t determine the remaining time left. &#34;
                &#34;Did you call register_lambda_context on IdempotencyConfig?&#34;,
                stacklevel=2,
            )

        logger.debug(f&#34;Saving in progress record for idempotency key: {data_record.idempotency_key}&#34;)

        if self._retrieve_from_cache(idempotency_key=data_record.idempotency_key):
            raise IdempotencyItemAlreadyExistsError

        self._put_record(data_record=data_record)

    def delete_record(self, data: Dict[str, Any], exception: Exception):
        &#34;&#34;&#34;
        Delete record from the persistence store

        Parameters
        ----------
        data: Dict[str, Any]
            Payload
        exception
            The exception raised by the function
        &#34;&#34;&#34;
        data_record = DataRecord(idempotency_key=self._get_hashed_idempotency_key(data=data))

        logger.debug(
            f&#34;Function raised an exception ({type(exception).__name__}). Clearing in progress record in persistence &#34;
            f&#34;store for idempotency key: {data_record.idempotency_key}&#34;
        )
        self._delete_record(data_record=data_record)

        self._delete_from_cache(idempotency_key=data_record.idempotency_key)

    def get_record(self, data: Dict[str, Any]) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve idempotency key for data provided, fetch from persistence store, and convert to DataRecord.

        Parameters
        ----------
        data: Dict[str, Any]
            Payload

        Returns
        -------
        DataRecord
            DataRecord representation of existing record found in persistence store

        Raises
        ------
        IdempotencyItemNotFoundError
            Exception raised if no record exists in persistence store with the idempotency key
        IdempotencyValidationError
            Payload doesn&#39;t match the stored record for the given idempotency key
        &#34;&#34;&#34;

        idempotency_key = self._get_hashed_idempotency_key(data=data)

        cached_record = self._retrieve_from_cache(idempotency_key=idempotency_key)
        if cached_record:
            logger.debug(f&#34;Idempotency record found in cache with idempotency key: {idempotency_key}&#34;)
            self._validate_payload(data=data, data_record=cached_record)
            return cached_record

        record = self._get_record(idempotency_key=idempotency_key)

        self._save_to_cache(data_record=record)

        self._validate_payload(data=data, data_record=record)
        return record

    @abstractmethod
    def _get_record(self, idempotency_key) -&gt; DataRecord:
        &#34;&#34;&#34;
        Retrieve item from persistence store using idempotency key and return it as a DataRecord instance.

        Parameters
        ----------
        idempotency_key

        Returns
        -------
        DataRecord
            DataRecord representation of existing record found in persistence store

        Raises
        ------
        IdempotencyItemNotFoundError
            Exception raised if no record exists in persistence store with the idempotency key
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def _put_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Add a DataRecord to persistence store if it does not already exist with that key. Raise ItemAlreadyExists
        if a non-expired entry already exists.

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError

    @abstractmethod
    def _update_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Update item in persistence store

        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError

    @abstractmethod
    def _delete_record(self, data_record: DataRecord) -&gt; None:
        &#34;&#34;&#34;
        Remove item from persistence store
        Parameters
        ----------
        data_record: DataRecord
            DataRecord instance
        &#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.idempotency.persistence.dynamodb.DynamoDBPersistenceLayer" href="dynamodb.html#aws_lambda_powertools.utilities.idempotency.persistence.dynamodb.DynamoDBPersistenceLayer">DynamoDBPersistenceLayer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.is_missing_idempotency_key"><code class="name flex">
<span>def <span class="ident">is_missing_idempotency_key</span></span>(<span>data) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_missing_idempotency_key(data) -&gt; bool:
    if type(data).__name__ in (&#34;tuple&#34;, &#34;list&#34;, &#34;dict&#34;):
        return all(x is None for x in data)
    return not data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, config: <a title="aws_lambda_powertools.utilities.idempotency.config.IdempotencyConfig" href="../config.html#aws_lambda_powertools.utilities.idempotency.config.IdempotencyConfig">IdempotencyConfig</a>, function_name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the base persistence layer from the configuration settings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>IdempotencyConfig</code></dt>
<dd>Idempotency configuration settings</dd>
<dt><strong><code>function_name</code></strong> :&ensp;<code>str, Optional</code></dt>
<dd>The name of the function being decorated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, config: IdempotencyConfig, function_name: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Initialize the base persistence layer from the configuration settings

    Parameters
    ----------
    config: IdempotencyConfig
        Idempotency configuration settings
    function_name: str, Optional
        The name of the function being decorated
    &#34;&#34;&#34;
    self.function_name = f&#34;{os.getenv(constants.LAMBDA_FUNCTION_NAME_ENV, &#39;test-func&#39;)}.{function_name or &#39;&#39;}&#34;

    if self.configured:
        # Prevent being reconfigured multiple times
        return
    self.configured = True

    self.event_key_jmespath = config.event_key_jmespath
    if config.event_key_jmespath:
        self.event_key_compiled_jmespath = jmespath.compile(config.event_key_jmespath)
    self.jmespath_options = config.jmespath_options
    if not self.jmespath_options:
        self.jmespath_options = {&#34;custom_functions&#34;: PowertoolsFunctions()}
    if config.payload_validation_jmespath:
        self.validation_key_jmespath = jmespath.compile(config.payload_validation_jmespath)
        self.payload_validation_enabled = True
    self.raise_on_no_idempotency_key = config.raise_on_no_idempotency_key
    self.expires_after_seconds = config.expires_after_seconds
    self.use_local_cache = config.use_local_cache
    if self.use_local_cache:
        self._cache = LRUDict(max_items=config.local_cache_max_items)
    self.hash_function = getattr(hashlib, config.hash_function)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.delete_record"><code class="name flex">
<span>def <span class="ident">delete_record</span></span>(<span>self, data: Dict[str, Any], exception: Exception)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete record from the persistence store</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Payload</dd>
<dt><strong><code>exception</code></strong></dt>
<dd>The exception raised by the function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_record(self, data: Dict[str, Any], exception: Exception):
    &#34;&#34;&#34;
    Delete record from the persistence store

    Parameters
    ----------
    data: Dict[str, Any]
        Payload
    exception
        The exception raised by the function
    &#34;&#34;&#34;
    data_record = DataRecord(idempotency_key=self._get_hashed_idempotency_key(data=data))

    logger.debug(
        f&#34;Function raised an exception ({type(exception).__name__}). Clearing in progress record in persistence &#34;
        f&#34;store for idempotency key: {data_record.idempotency_key}&#34;
    )
    self._delete_record(data_record=data_record)

    self._delete_from_cache(idempotency_key=data_record.idempotency_key)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.get_record"><code class="name flex">
<span>def <span class="ident">get_record</span></span>(<span>self, data: Dict[str, Any]) ‑> <a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord">DataRecord</a></span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve idempotency key for data provided, fetch from persistence store, and convert to DataRecord.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Payload</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord">DataRecord</a></code></dt>
<dd>DataRecord representation of existing record found in persistence store</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IdempotencyItemNotFoundError</code></dt>
<dd>Exception raised if no record exists in persistence store with the idempotency key</dd>
<dt><code>IdempotencyValidationError</code></dt>
<dd>Payload doesn't match the stored record for the given idempotency key</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_record(self, data: Dict[str, Any]) -&gt; DataRecord:
    &#34;&#34;&#34;
    Retrieve idempotency key for data provided, fetch from persistence store, and convert to DataRecord.

    Parameters
    ----------
    data: Dict[str, Any]
        Payload

    Returns
    -------
    DataRecord
        DataRecord representation of existing record found in persistence store

    Raises
    ------
    IdempotencyItemNotFoundError
        Exception raised if no record exists in persistence store with the idempotency key
    IdempotencyValidationError
        Payload doesn&#39;t match the stored record for the given idempotency key
    &#34;&#34;&#34;

    idempotency_key = self._get_hashed_idempotency_key(data=data)

    cached_record = self._retrieve_from_cache(idempotency_key=idempotency_key)
    if cached_record:
        logger.debug(f&#34;Idempotency record found in cache with idempotency key: {idempotency_key}&#34;)
        self._validate_payload(data=data, data_record=cached_record)
        return cached_record

    record = self._get_record(idempotency_key=idempotency_key)

    self._save_to_cache(data_record=record)

    self._validate_payload(data=data, data_record=record)
    return record</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_inprogress"><code class="name flex">
<span>def <span class="ident">save_inprogress</span></span>(<span>self, data: Dict[str, Any], remaining_time_in_millis: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save record of function's execution being in progress</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Payload</dd>
<dt><strong><code>remaining_time_in_millis</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>If expiry of in-progress invocations is enabled, this will contain the remaining time available in millis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_inprogress(self, data: Dict[str, Any], remaining_time_in_millis: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Save record of function&#39;s execution being in progress

    Parameters
    ----------
    data: Dict[str, Any]
        Payload
    remaining_time_in_millis: Optional[int]
        If expiry of in-progress invocations is enabled, this will contain the remaining time available in millis
    &#34;&#34;&#34;
    data_record = DataRecord(
        idempotency_key=self._get_hashed_idempotency_key(data=data),
        status=STATUS_CONSTANTS[&#34;INPROGRESS&#34;],
        expiry_timestamp=self._get_expiry_timestamp(),
        payload_hash=self._get_hashed_payload(data=data),
    )

    if remaining_time_in_millis:
        now = datetime.datetime.now()
        period = datetime.timedelta(milliseconds=remaining_time_in_millis)
        timestamp = (now + period).timestamp()

        data_record.in_progress_expiry_timestamp = int(timestamp * 1000)
    else:
        warnings.warn(
            &#34;Couldn&#39;t determine the remaining time left. &#34;
            &#34;Did you call register_lambda_context on IdempotencyConfig?&#34;,
            stacklevel=2,
        )

    logger.debug(f&#34;Saving in progress record for idempotency key: {data_record.idempotency_key}&#34;)

    if self._retrieve_from_cache(idempotency_key=data_record.idempotency_key):
        raise IdempotencyItemAlreadyExistsError

    self._put_record(data_record=data_record)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_success"><code class="name flex">
<span>def <span class="ident">save_success</span></span>(<span>self, data: Dict[str, Any], result: dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Save record of function's execution completing successfully</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Payload</dd>
<dt><strong><code>result</code></strong> :&ensp;<code>dict</code></dt>
<dd>The response from function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_success(self, data: Dict[str, Any], result: dict) -&gt; None:
    &#34;&#34;&#34;
    Save record of function&#39;s execution completing successfully

    Parameters
    ----------
    data: Dict[str, Any]
        Payload
    result: dict
        The response from function
    &#34;&#34;&#34;
    response_data = json.dumps(result, cls=Encoder, sort_keys=True)

    data_record = DataRecord(
        idempotency_key=self._get_hashed_idempotency_key(data=data),
        status=STATUS_CONSTANTS[&#34;COMPLETED&#34;],
        expiry_timestamp=self._get_expiry_timestamp(),
        response_data=response_data,
        payload_hash=self._get_hashed_payload(data=data),
    )
    logger.debug(
        f&#34;Function successfully executed. Saving record to persistence store with &#34;
        f&#34;idempotency key: {data_record.idempotency_key}&#34;
    )
    self._update_record(data_record=data_record)

    self._save_to_cache(data_record=data_record)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord"><code class="flex name class">
<span>class <span class="ident">DataRecord</span></span>
<span>(</span><span>idempotency_key: str, status: str = '', expiry_timestamp: Optional[int] = None, in_progress_expiry_timestamp: Optional[int] = None, response_data: str = '', payload_hash: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Data Class for idempotency records.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idempotency_key</code></strong> :&ensp;<code>str</code></dt>
<dd>hashed representation of the idempotent data</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>status of the idempotent record</dd>
<dt><strong><code>expiry_timestamp</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>time before the record should expire, in seconds</dd>
<dt><strong><code>in_progress_expiry_timestamp</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>time before the record should expire while in the INPROGRESS state, in seconds</dd>
<dt><strong><code>payload_hash</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>hashed representation of payload</dd>
<dt><strong><code>response_data</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>response data from previous executions using the record</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataRecord:
    &#34;&#34;&#34;
    Data Class for idempotency records.
    &#34;&#34;&#34;

    def __init__(
        self,
        idempotency_key: str,
        status: str = &#34;&#34;,
        expiry_timestamp: Optional[int] = None,
        in_progress_expiry_timestamp: Optional[int] = None,
        response_data: str = &#34;&#34;,
        payload_hash: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;

        Parameters
        ----------
        idempotency_key: str
            hashed representation of the idempotent data
        status: str, optional
            status of the idempotent record
        expiry_timestamp: int, optional
            time before the record should expire, in seconds
        in_progress_expiry_timestamp: int, optional
            time before the record should expire while in the INPROGRESS state, in seconds
        payload_hash: str, optional
            hashed representation of payload
        response_data: str, optional
            response data from previous executions using the record
        &#34;&#34;&#34;
        self.idempotency_key = idempotency_key
        self.payload_hash = payload_hash
        self.expiry_timestamp = expiry_timestamp
        self.in_progress_expiry_timestamp = in_progress_expiry_timestamp
        self._status = status
        self.response_data = response_data

    @property
    def is_expired(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if data record is expired

        Returns
        -------
        bool
            Whether the record is currently expired or not
        &#34;&#34;&#34;
        return bool(self.expiry_timestamp and int(datetime.datetime.now().timestamp()) &gt; self.expiry_timestamp)

    @property
    def status(self) -&gt; str:
        &#34;&#34;&#34;
        Get status of data record

        Returns
        -------
        str
        &#34;&#34;&#34;
        if self.is_expired:
            return STATUS_CONSTANTS[&#34;EXPIRED&#34;]
        elif self._status in STATUS_CONSTANTS.values():
            return self._status
        else:
            raise IdempotencyInvalidStatusError(self._status)

    def response_json_as_dict(self) -&gt; Optional[dict]:
        &#34;&#34;&#34;
        Get response data deserialized to python dict

        Returns
        -------
        Optional[dict]
            previous response data deserialized
        &#34;&#34;&#34;
        return json.loads(self.response_data) if self.response_data else None</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.is_expired"><code class="name">var <span class="ident">is_expired</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if data record is expired</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the record is currently expired or not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_expired(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if data record is expired

    Returns
    -------
    bool
        Whether the record is currently expired or not
    &#34;&#34;&#34;
    return bool(self.expiry_timestamp and int(datetime.datetime.now().timestamp()) &gt; self.expiry_timestamp)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.status"><code class="name">var <span class="ident">status</span> : str</code></dt>
<dd>
<div class="desc"><p>Get status of data record</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self) -&gt; str:
    &#34;&#34;&#34;
    Get status of data record

    Returns
    -------
    str
    &#34;&#34;&#34;
    if self.is_expired:
        return STATUS_CONSTANTS[&#34;EXPIRED&#34;]
    elif self._status in STATUS_CONSTANTS.values():
        return self._status
    else:
        raise IdempotencyInvalidStatusError(self._status)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.response_json_as_dict"><code class="name flex">
<span>def <span class="ident">response_json_as_dict</span></span>(<span>self) ‑> Optional[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Get response data deserialized to python dict</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[dict]</code></dt>
<dd>previous response data deserialized</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response_json_as_dict(self) -&gt; Optional[dict]:
    &#34;&#34;&#34;
    Get response data deserialized to python dict

    Returns
    -------
    Optional[dict]
        previous response data deserialized
    &#34;&#34;&#34;
    return json.loads(self.response_data) if self.response_data else None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence" href="index.html">aws_lambda_powertools.utilities.idempotency.persistence</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer">BasePersistenceLayer</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.configure" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.configure">configure</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.delete_record" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.delete_record">delete_record</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.get_record" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.get_record">get_record</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.is_missing_idempotency_key" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.is_missing_idempotency_key">is_missing_idempotency_key</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_inprogress" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_inprogress">save_inprogress</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_success" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.BasePersistenceLayer.save_success">save_success</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord">DataRecord</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.is_expired" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.is_expired">is_expired</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.response_json_as_dict" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.response_json_as_dict">response_json_as_dict</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.status" href="#aws_lambda_powertools.utilities.idempotency.persistence.base.DataRecord.status">status</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>