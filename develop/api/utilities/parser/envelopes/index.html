<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.utilities.parser.envelopes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.utilities.parser.envelopes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .apigw import ApiGatewayEnvelope
from .apigwv2 import ApiGatewayV2Envelope
from .base import BaseEnvelope
from .cloudwatch import CloudWatchLogsEnvelope
from .dynamodb import DynamoDBStreamEnvelope
from .event_bridge import EventBridgeEnvelope
from .kafka import KafkaEnvelope
from .kinesis import KinesisDataStreamEnvelope
from .kinesis_firehose import KinesisFirehoseEnvelope
from .lambda_function_url import LambdaFunctionUrlEnvelope
from .sns import SnsEnvelope, SnsSqsEnvelope
from .sqs import SqsEnvelope

__all__ = [
    &#34;ApiGatewayEnvelope&#34;,
    &#34;ApiGatewayV2Envelope&#34;,
    &#34;CloudWatchLogsEnvelope&#34;,
    &#34;DynamoDBStreamEnvelope&#34;,
    &#34;EventBridgeEnvelope&#34;,
    &#34;KinesisDataStreamEnvelope&#34;,
    &#34;KinesisFirehoseEnvelope&#34;,
    &#34;LambdaFunctionUrlEnvelope&#34;,
    &#34;SnsEnvelope&#34;,
    &#34;SnsSqsEnvelope&#34;,
    &#34;SqsEnvelope&#34;,
    &#34;KafkaEnvelope&#34;,
    &#34;BaseEnvelope&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.apigw" href="apigw.html">aws_lambda_powertools.utilities.parser.envelopes.apigw</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.apigwv2" href="apigwv2.html">aws_lambda_powertools.utilities.parser.envelopes.apigwv2</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.base" href="base.html">aws_lambda_powertools.utilities.parser.envelopes.base</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.cloudwatch" href="cloudwatch.html">aws_lambda_powertools.utilities.parser.envelopes.cloudwatch</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.dynamodb" href="dynamodb.html">aws_lambda_powertools.utilities.parser.envelopes.dynamodb</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.event_bridge" href="event_bridge.html">aws_lambda_powertools.utilities.parser.envelopes.event_bridge</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.kafka" href="kafka.html">aws_lambda_powertools.utilities.parser.envelopes.kafka</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis" href="kinesis.html">aws_lambda_powertools.utilities.parser.envelopes.kinesis</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose" href="kinesis_firehose.html">aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url" href="lambda_function_url.html">aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.sns" href="sns.html">aws_lambda_powertools.utilities.parser.envelopes.sns</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities.parser.envelopes.sqs" href="sqs.html">aws_lambda_powertools.utilities.parser.envelopes.sqs</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope"><code class="flex name class">
<span>class <span class="ident">ApiGatewayEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>API Gateway envelope to extract data within body key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApiGatewayEnvelope(BaseEnvelope):
    &#34;&#34;&#34;API Gateway envelope to extract data within body key&#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
        &#34;&#34;&#34;Parses data found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        Any
            Parsed detail payload with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with Api Gateway model {APIGatewayProxyEventModel}&#34;)
        parsed_envelope: APIGatewayProxyEventModel = APIGatewayProxyEventModel.parse_obj(data)
        logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
        return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> Optional[~Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Parsed detail payload with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
    &#34;&#34;&#34;Parses data found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    Any
        Parsed detail payload with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with Api Gateway model {APIGatewayProxyEventModel}&#34;)
    parsed_envelope: APIGatewayProxyEventModel = APIGatewayProxyEventModel.parse_obj(data)
    logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
    return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope"><code class="flex name class">
<span>class <span class="ident">ApiGatewayV2Envelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>API Gateway V2 envelope to extract data within body key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ApiGatewayV2Envelope(BaseEnvelope):
    &#34;&#34;&#34;API Gateway V2 envelope to extract data within body key&#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
        &#34;&#34;&#34;Parses data found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        Any
            Parsed detail payload with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with Api Gateway model V2 {APIGatewayProxyEventV2Model}&#34;)
        parsed_envelope: APIGatewayProxyEventV2Model = APIGatewayProxyEventV2Model.parse_obj(data)
        logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
        return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> Optional[~Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Parsed detail payload with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
    &#34;&#34;&#34;Parses data found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    Any
        Parsed detail payload with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with Api Gateway model V2 {APIGatewayProxyEventV2Model}&#34;)
    parsed_envelope: APIGatewayProxyEventV2Model = APIGatewayProxyEventV2Model.parse_obj(data)
    logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
    return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope"><code class="flex name class">
<span>class <span class="ident">BaseEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>ABC implementation for creating a supported Envelope</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseEnvelope(ABC):
    &#34;&#34;&#34;ABC implementation for creating a supported Envelope&#34;&#34;&#34;

    @staticmethod
    def _parse(data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Union[Model, None]:
        &#34;&#34;&#34;Parses envelope data against model provided

        Parameters
        ----------
        data : Dict
            Data to be parsed and validated
        model : Type[Model]
            Data model to parse and validate data against

        Returns
        -------
        Any
            Parsed data
        &#34;&#34;&#34;
        if data is None:
            logger.debug(&#34;Skipping parsing as event is None&#34;)
            return data

        logger.debug(&#34;parsing event against model&#34;)
        if isinstance(data, str):
            logger.debug(&#34;parsing event as string&#34;)
            return model.parse_raw(data)

        return model.parse_obj(data)

    @abstractmethod
    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]):
        &#34;&#34;&#34;Implementation to parse data against envelope model, then against the data model

        NOTE: Call `_parse` method to fully parse data with model provided.

        Example
        -------

        **EventBridge envelope implementation example**

        def parse(...):
            # 1. parses data against envelope model
            parsed_envelope = EventBridgeModel(**data)

            # 2. parses portion of data within the envelope against model
            return self._parse(data=parsed_envelope.detail, model=data_model)
        &#34;&#34;&#34;
        return NotImplemented  # pragma: no cover</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.apigw.ApiGatewayEnvelope" href="apigw.html#aws_lambda_powertools.utilities.parser.envelopes.apigw.ApiGatewayEnvelope">ApiGatewayEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.apigwv2.ApiGatewayV2Envelope" href="apigwv2.html#aws_lambda_powertools.utilities.parser.envelopes.apigwv2.ApiGatewayV2Envelope">ApiGatewayV2Envelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.cloudwatch.CloudWatchLogsEnvelope" href="cloudwatch.html#aws_lambda_powertools.utilities.parser.envelopes.cloudwatch.CloudWatchLogsEnvelope">CloudWatchLogsEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.dynamodb.DynamoDBStreamEnvelope" href="dynamodb.html#aws_lambda_powertools.utilities.parser.envelopes.dynamodb.DynamoDBStreamEnvelope">DynamoDBStreamEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.event_bridge.EventBridgeEnvelope" href="event_bridge.html#aws_lambda_powertools.utilities.parser.envelopes.event_bridge.EventBridgeEnvelope">EventBridgeEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.kafka.KafkaEnvelope" href="kafka.html#aws_lambda_powertools.utilities.parser.envelopes.kafka.KafkaEnvelope">KafkaEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis.KinesisDataStreamEnvelope" href="kinesis.html#aws_lambda_powertools.utilities.parser.envelopes.kinesis.KinesisDataStreamEnvelope">KinesisDataStreamEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose.KinesisFirehoseEnvelope" href="kinesis_firehose.html#aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose.KinesisFirehoseEnvelope">KinesisFirehoseEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url.LambdaFunctionUrlEnvelope" href="lambda_function_url.html#aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url.LambdaFunctionUrlEnvelope">LambdaFunctionUrlEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.sns.SnsEnvelope" href="sns.html#aws_lambda_powertools.utilities.parser.envelopes.sns.SnsEnvelope">SnsEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.sns.SnsSqsEnvelope" href="sns.html#aws_lambda_powertools.utilities.parser.envelopes.sns.SnsSqsEnvelope">SnsSqsEnvelope</a></li>
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.sqs.SqsEnvelope" href="sqs.html#aws_lambda_powertools.utilities.parser.envelopes.sqs.SqsEnvelope">SqsEnvelope</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model])</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation to parse data against envelope model, then against the data model</p>
<p>NOTE: Call <code>_parse</code> method to fully parse data with model provided.</p>
<h2 id="example">Example</h2>
<p><strong>EventBridge envelope implementation example</strong></p>
<p>def parse(&hellip;):
# 1. parses data against envelope model
parsed_envelope = EventBridgeModel(**data)</p>
<pre><code># 2. parses portion of data within the envelope against model
return self._parse(data=parsed_envelope.detail, model=data_model)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]):
    &#34;&#34;&#34;Implementation to parse data against envelope model, then against the data model

    NOTE: Call `_parse` method to fully parse data with model provided.

    Example
    -------

    **EventBridge envelope implementation example**

    def parse(...):
        # 1. parses data against envelope model
        parsed_envelope = EventBridgeModel(**data)

        # 2. parses portion of data within the envelope against model
        return self._parse(data=parsed_envelope.detail, model=data_model)
    &#34;&#34;&#34;
    return NotImplemented  # pragma: no cover</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope"><code class="flex name class">
<span>class <span class="ident">CloudWatchLogsEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>CloudWatch Envelope to extract a List of log records.</p>
<p>The record's body parameter is a string (after being base64 decoded and gzipped),
though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: The record will be parsed the same way so if model is str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CloudWatchLogsEnvelope(BaseEnvelope):
    &#34;&#34;&#34;CloudWatch Envelope to extract a List of log records.

    The record&#39;s body parameter is a string (after being base64 decoded and gzipped),
    though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: The record will be parsed the same way so if model is str
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with SNS model {CloudWatchLogsModel}&#34;)
        parsed_envelope = CloudWatchLogsModel.parse_obj(data)
        logger.debug(f&#34;Parsing CloudWatch records in `body` with {model}&#34;)
        return [
            self._parse(data=record.message, model=model) for record in parsed_envelope.awslogs.decoded_data.logEvents
        ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with SNS model {CloudWatchLogsModel}&#34;)
    parsed_envelope = CloudWatchLogsModel.parse_obj(data)
    logger.debug(f&#34;Parsing CloudWatch records in `body` with {model}&#34;)
    return [
        self._parse(data=record.message, model=model) for record in parsed_envelope.awslogs.decoded_data.logEvents
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope"><code class="flex name class">
<span>class <span class="ident">DynamoDBStreamEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>DynamoDB Stream Envelope to extract data within NewImage/OldImage</p>
<p>Note: Values are the parsed models. Images' values can also be None, and
length of the list is the record's amount in the original event.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamoDBStreamEnvelope(BaseEnvelope):
    &#34;&#34;&#34;DynamoDB Stream Envelope to extract data within NewImage/OldImage

    Note: Values are the parsed models. Images&#39; values can also be None, and
    length of the list is the record&#39;s amount in the original event.
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Dict[str, Optional[Model]]]:
        &#34;&#34;&#34;Parses DynamoDB Stream records found in either NewImage and OldImage with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of dictionaries with NewImage and OldImage records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with DynamoDB Stream model {DynamoDBStreamModel}&#34;)
        parsed_envelope = DynamoDBStreamModel.parse_obj(data)
        logger.debug(f&#34;Parsing DynamoDB Stream new and old records with {model}&#34;)
        return [
            {
                &#34;NewImage&#34;: self._parse(data=record.dynamodb.NewImage, model=model),
                &#34;OldImage&#34;: self._parse(data=record.dynamodb.OldImage, model=model),
            }
            for record in parsed_envelope.Records
        ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Dict[str, Optional[~Model]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses DynamoDB Stream records found in either NewImage and OldImage with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of dictionaries with NewImage and OldImage records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Dict[str, Optional[Model]]]:
    &#34;&#34;&#34;Parses DynamoDB Stream records found in either NewImage and OldImage with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of dictionaries with NewImage and OldImage records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with DynamoDB Stream model {DynamoDBStreamModel}&#34;)
    parsed_envelope = DynamoDBStreamModel.parse_obj(data)
    logger.debug(f&#34;Parsing DynamoDB Stream new and old records with {model}&#34;)
    return [
        {
            &#34;NewImage&#34;: self._parse(data=record.dynamodb.NewImage, model=model),
            &#34;OldImage&#34;: self._parse(data=record.dynamodb.OldImage, model=model),
        }
        for record in parsed_envelope.Records
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope"><code class="flex name class">
<span>class <span class="ident">EventBridgeEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>EventBridge envelope to extract data within detail key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventBridgeEnvelope(BaseEnvelope):
    &#34;&#34;&#34;EventBridge envelope to extract data within detail key&#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
        &#34;&#34;&#34;Parses data found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        Any
            Parsed detail payload with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with EventBridge model {EventBridgeModel}&#34;)
        parsed_envelope: EventBridgeModel = EventBridgeModel.parse_obj(data)
        logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
        return self._parse(data=parsed_envelope.detail, model=model)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> Optional[~Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Parsed detail payload with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
    &#34;&#34;&#34;Parses data found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    Any
        Parsed detail payload with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with EventBridge model {EventBridgeModel}&#34;)
    parsed_envelope: EventBridgeModel = EventBridgeModel.parse_obj(data)
    logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
    return self._parse(data=parsed_envelope.detail, model=model)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope"><code class="flex name class">
<span>class <span class="ident">KafkaEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>Kafka event envelope to extract data within body key
The record's body parameter is a string, though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: Records will be parsed the same way so if model is str,
all items in the list will be parsed as str and npt as JSON (and vice versa)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KafkaEnvelope(BaseEnvelope):
    &#34;&#34;&#34;Kafka event envelope to extract data within body key
    The record&#39;s body parameter is a string, though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: Records will be parsed the same way so if model is str,
    all items in the list will be parsed as str and npt as JSON (and vice versa)
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses data found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        event_source = cast(dict, data).get(&#34;eventSource&#34;)
        model_parse_event: Union[Type[KafkaMskEventModel], Type[KafkaSelfManagedEventModel]] = (
            KafkaMskEventModel if event_source == &#34;aws:kafka&#34; else KafkaSelfManagedEventModel
        )

        logger.debug(f&#34;Parsing incoming data with Kafka event model {model_parse_event}&#34;)
        parsed_envelope = model_parse_event.parse_obj(data)
        logger.debug(f&#34;Parsing Kafka event records in `value` with {model}&#34;)
        ret_list = []
        for records in parsed_envelope.records.values():
            ret_list += [self._parse(data=record.value, model=model) for record in records]
        return ret_list</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses data found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    event_source = cast(dict, data).get(&#34;eventSource&#34;)
    model_parse_event: Union[Type[KafkaMskEventModel], Type[KafkaSelfManagedEventModel]] = (
        KafkaMskEventModel if event_source == &#34;aws:kafka&#34; else KafkaSelfManagedEventModel
    )

    logger.debug(f&#34;Parsing incoming data with Kafka event model {model_parse_event}&#34;)
    parsed_envelope = model_parse_event.parse_obj(data)
    logger.debug(f&#34;Parsing Kafka event records in `value` with {model}&#34;)
    ret_list = []
    for records in parsed_envelope.records.values():
        ret_list += [self._parse(data=record.value, model=model) for record in records]
    return ret_list</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope"><code class="flex name class">
<span>class <span class="ident">KinesisDataStreamEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>Kinesis Data Stream Envelope to extract array of Records</p>
<p>The record's data parameter is a base64 encoded string which is parsed into a bytes array,
though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: Records will be parsed the same way so if model is str,
all items in the list will be parsed as str and not as JSON (and vice versa)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KinesisDataStreamEnvelope(BaseEnvelope):
    &#34;&#34;&#34;Kinesis Data Stream Envelope to extract array of Records

    The record&#39;s data parameter is a base64 encoded string which is parsed into a bytes array,
    though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: Records will be parsed the same way so if model is str,
    all items in the list will be parsed as str and not as JSON (and vice versa)
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with Kinesis model {KinesisDataStreamModel}&#34;)
        parsed_envelope: KinesisDataStreamModel = KinesisDataStreamModel.parse_obj(data)
        logger.debug(f&#34;Parsing Kinesis records in `body` with {model}&#34;)
        models = []
        for record in parsed_envelope.Records:
            # We allow either AWS expected contract (bytes) or a custom Model, see #943
            data = cast(bytes, record.kinesis.data)
            models.append(self._parse(data=data.decode(&#34;utf-8&#34;), model=model))
        return models</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with Kinesis model {KinesisDataStreamModel}&#34;)
    parsed_envelope: KinesisDataStreamModel = KinesisDataStreamModel.parse_obj(data)
    logger.debug(f&#34;Parsing Kinesis records in `body` with {model}&#34;)
    models = []
    for record in parsed_envelope.Records:
        # We allow either AWS expected contract (bytes) or a custom Model, see #943
        data = cast(bytes, record.kinesis.data)
        models.append(self._parse(data=data.decode(&#34;utf-8&#34;), model=model))
    return models</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope"><code class="flex name class">
<span>class <span class="ident">KinesisFirehoseEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>Kinesis Firehose Envelope to extract array of Records</p>
<p>The record's data parameter is a base64 encoded string which is parsed into a bytes array,
though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: Records will be parsed the same way so if model is str,
all items in the list will be parsed as str and not as JSON (and vice versa)</p>
<p><a href="https://docs.aws.amazon.com/lambda/latest/dg/services-kinesisfirehose.html">https://docs.aws.amazon.com/lambda/latest/dg/services-kinesisfirehose.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KinesisFirehoseEnvelope(BaseEnvelope):
    &#34;&#34;&#34;Kinesis Firehose Envelope to extract array of Records

    The record&#39;s data parameter is a base64 encoded string which is parsed into a bytes array,
    though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: Records will be parsed the same way so if model is str,
    all items in the list will be parsed as str and not as JSON (and vice versa)

    https://docs.aws.amazon.com/lambda/latest/dg/services-kinesisfirehose.html
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with Kinesis Firehose model {KinesisFirehoseModel}&#34;)
        parsed_envelope: KinesisFirehoseModel = KinesisFirehoseModel.parse_obj(data)
        logger.debug(f&#34;Parsing Kinesis Firehose records in `body` with {model}&#34;)
        models = []
        for record in parsed_envelope.records:
            # We allow either AWS expected contract (bytes) or a custom Model, see #943
            data = cast(bytes, record.data)
            models.append(self._parse(data=data.decode(&#34;utf-8&#34;), model=model))
        return models</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with Kinesis Firehose model {KinesisFirehoseModel}&#34;)
    parsed_envelope: KinesisFirehoseModel = KinesisFirehoseModel.parse_obj(data)
    logger.debug(f&#34;Parsing Kinesis Firehose records in `body` with {model}&#34;)
    models = []
    for record in parsed_envelope.records:
        # We allow either AWS expected contract (bytes) or a custom Model, see #943
        data = cast(bytes, record.data)
        models.append(self._parse(data=data.decode(&#34;utf-8&#34;), model=model))
    return models</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope"><code class="flex name class">
<span>class <span class="ident">LambdaFunctionUrlEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>Lambda function URL envelope to extract data within body key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LambdaFunctionUrlEnvelope(BaseEnvelope):
    &#34;&#34;&#34;Lambda function URL envelope to extract data within body key&#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
        &#34;&#34;&#34;Parses data found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        Any
            Parsed detail payload with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with Lambda function URL model {LambdaFunctionUrlModel}&#34;)
        parsed_envelope: LambdaFunctionUrlModel = LambdaFunctionUrlModel.parse_obj(data)
        logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
        return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> Optional[~Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Parsed detail payload with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; Optional[Model]:
    &#34;&#34;&#34;Parses data found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    Any
        Parsed detail payload with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with Lambda function URL model {LambdaFunctionUrlModel}&#34;)
    parsed_envelope: LambdaFunctionUrlModel = LambdaFunctionUrlModel.parse_obj(data)
    logger.debug(f&#34;Parsing event payload in `detail` with {model}&#34;)
    return self._parse(data=parsed_envelope.body, model=model)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope"><code class="flex name class">
<span>class <span class="ident">SnsEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>SNS Envelope to extract array of Records</p>
<p>The record's body parameter is a string, though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: Records will be parsed the same way so if model is str,
all items in the list will be parsed as str and npt as JSON (and vice versa)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnsEnvelope(BaseEnvelope):
    &#34;&#34;&#34;SNS Envelope to extract array of Records

    The record&#39;s body parameter is a string, though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: Records will be parsed the same way so if model is str,
    all items in the list will be parsed as str and npt as JSON (and vice versa)
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with SNS model {SnsModel}&#34;)
        parsed_envelope = SnsModel.parse_obj(data)
        logger.debug(f&#34;Parsing SNS records in `body` with {model}&#34;)
        return [self._parse(data=record.Sns.Message, model=model) for record in parsed_envelope.Records]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with SNS model {SnsModel}&#34;)
    parsed_envelope = SnsModel.parse_obj(data)
    logger.debug(f&#34;Parsing SNS records in `body` with {model}&#34;)
    return [self._parse(data=record.Sns.Message, model=model) for record in parsed_envelope.Records]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope"><code class="flex name class">
<span>class <span class="ident">SnsSqsEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>SNS plus SQS Envelope to extract array of Records</p>
<p>Published messages from SNS to SQS has a slightly different payload.
Since SNS payload is marshalled into <code>Record</code> key in SQS, we have to:</p>
<ol>
<li>Parse SQS schema with incoming data</li>
<li>Unmarshall SNS payload and parse against SNS Notification model not SNS/SNS Record</li>
<li>Finally, parse provided model against payload extracted</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnsSqsEnvelope(BaseEnvelope):
    &#34;&#34;&#34;SNS plus SQS Envelope to extract array of Records

    Published messages from SNS to SQS has a slightly different payload.
    Since SNS payload is marshalled into `Record` key in SQS, we have to:

    1. Parse SQS schema with incoming data
    2. Unmarshall SNS payload and parse against SNS Notification model not SNS/SNS Record
    3. Finally, parse provided model against payload extracted
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with SQS model {SqsModel}&#34;)
        parsed_envelope = SqsModel.parse_obj(data)
        output = []
        for record in parsed_envelope.Records:
            # We allow either AWS expected contract (str) or a custom Model, see #943
            body = cast(str, record.body)
            sns_notification = SnsNotificationModel.parse_raw(body)
            output.append(self._parse(data=sns_notification.Message, model=model))
        return output</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with SQS model {SqsModel}&#34;)
    parsed_envelope = SqsModel.parse_obj(data)
    output = []
    for record in parsed_envelope.Records:
        # We allow either AWS expected contract (str) or a custom Model, see #943
        body = cast(str, record.body)
        sns_notification = SnsNotificationModel.parse_raw(body)
        output.append(self._parse(data=sns_notification.Message, model=model))
    return output</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope"><code class="flex name class">
<span>class <span class="ident">SqsEnvelope</span></span>
</code></dt>
<dd>
<div class="desc"><p>SQS Envelope to extract array of Records</p>
<p>The record's body parameter is a string, though it can also be a JSON encoded string.
Regardless of its type it'll be parsed into a BaseModel object.</p>
<p>Note: Records will be parsed the same way so if model is str,
all items in the list will be parsed as str and npt as JSON (and vice versa)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SqsEnvelope(BaseEnvelope):
    &#34;&#34;&#34;SQS Envelope to extract array of Records

    The record&#39;s body parameter is a string, though it can also be a JSON encoded string.
    Regardless of its type it&#39;ll be parsed into a BaseModel object.

    Note: Records will be parsed the same way so if model is str,
    all items in the list will be parsed as str and npt as JSON (and vice versa)
    &#34;&#34;&#34;

    def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
        &#34;&#34;&#34;Parses records found with model provided

        Parameters
        ----------
        data : Dict
            Lambda event to be parsed
        model : Type[Model]
            Data model provided to parse after extracting data using envelope

        Returns
        -------
        List
            List of records parsed with model provided
        &#34;&#34;&#34;
        logger.debug(f&#34;Parsing incoming data with SQS model {SqsModel}&#34;)
        parsed_envelope = SqsModel.parse_obj(data)
        logger.debug(f&#34;Parsing SQS records in `body` with {model}&#34;)
        return [self._parse(data=record.body, model=model) for record in parsed_envelope.Records]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope" href="base.html#aws_lambda_powertools.utilities.parser.envelopes.base.BaseEnvelope">BaseEnvelope</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, data: Union[Dict[str, Any], Any, ForwardRef(None)], model: Type[~Model]) ‑> List[Optional[~Model]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses records found with model provided</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Lambda event to be parsed</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>Type[Model]</code></dt>
<dd>Data model provided to parse after extracting data using envelope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of records parsed with model provided</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, data: Optional[Union[Dict[str, Any], Any]], model: Type[Model]) -&gt; List[Optional[Model]]:
    &#34;&#34;&#34;Parses records found with model provided

    Parameters
    ----------
    data : Dict
        Lambda event to be parsed
    model : Type[Model]
        Data model provided to parse after extracting data using envelope

    Returns
    -------
    List
        List of records parsed with model provided
    &#34;&#34;&#34;
    logger.debug(f&#34;Parsing incoming data with SQS model {SqsModel}&#34;)
    parsed_envelope = SqsModel.parse_obj(data)
    logger.debug(f&#34;Parsing SQS records in `body` with {model}&#34;)
    return [self._parse(data=record.body, model=model) for record in parsed_envelope.Records]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.parser" href="../index.html">aws_lambda_powertools.utilities.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.apigw" href="apigw.html">aws_lambda_powertools.utilities.parser.envelopes.apigw</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.apigwv2" href="apigwv2.html">aws_lambda_powertools.utilities.parser.envelopes.apigwv2</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.base" href="base.html">aws_lambda_powertools.utilities.parser.envelopes.base</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.cloudwatch" href="cloudwatch.html">aws_lambda_powertools.utilities.parser.envelopes.cloudwatch</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.dynamodb" href="dynamodb.html">aws_lambda_powertools.utilities.parser.envelopes.dynamodb</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.event_bridge" href="event_bridge.html">aws_lambda_powertools.utilities.parser.envelopes.event_bridge</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.kafka" href="kafka.html">aws_lambda_powertools.utilities.parser.envelopes.kafka</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis" href="kinesis.html">aws_lambda_powertools.utilities.parser.envelopes.kinesis</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose" href="kinesis_firehose.html">aws_lambda_powertools.utilities.parser.envelopes.kinesis_firehose</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url" href="lambda_function_url.html">aws_lambda_powertools.utilities.parser.envelopes.lambda_function_url</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.sns" href="sns.html">aws_lambda_powertools.utilities.parser.envelopes.sns</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.sqs" href="sqs.html">aws_lambda_powertools.utilities.parser.envelopes.sqs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope">ApiGatewayEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope" href="#aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope">ApiGatewayV2Envelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.ApiGatewayV2Envelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope">BaseEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.BaseEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope">CloudWatchLogsEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.CloudWatchLogsEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope">DynamoDBStreamEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.DynamoDBStreamEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope">EventBridgeEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.EventBridgeEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope">KafkaEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.KafkaEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope">KinesisDataStreamEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.KinesisDataStreamEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope">KinesisFirehoseEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.KinesisFirehoseEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope">LambdaFunctionUrlEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.LambdaFunctionUrlEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope">SnsEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.SnsEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope">SnsSqsEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.SnsSqsEnvelope.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope" href="#aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope">SqsEnvelope</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope.parse" href="#aws_lambda_powertools.utilities.parser.envelopes.SqsEnvelope.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>