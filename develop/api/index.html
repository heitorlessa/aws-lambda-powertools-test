<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools API documentation</title>
<meta name="description" content="Top-level package for Lambda Python Powertools." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>aws_lambda_powertools</code></h1>
</header>
<section id="section-intro">
<p>Top-level package for Lambda Python Powertools.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;Top-level package for Lambda Python Powertools.&#34;&#34;&#34;

from pathlib import Path

from .logging import Logger
from .metrics import Metrics, single_metric
from .package_logger import set_package_logger_handler
from .tracing import Tracer

__author__ = &#34;&#34;&#34;Amazon Web Services&#34;&#34;&#34;
__all__ = [
    &#34;Logger&#34;,
    &#34;Metrics&#34;,
    &#34;single_metric&#34;,
    &#34;Tracer&#34;,
]

PACKAGE_PATH = Path(__file__).parent

set_package_logger_handler()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="aws_lambda_powertools.event_handler" href="event_handler/index.html">aws_lambda_powertools.event_handler</a></code></dt>
<dd>
<div class="desc"><p>Event handler decorators for common Lambda events</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.exceptions" href="exceptions/index.html">aws_lambda_powertools.exceptions</a></code></dt>
<dd>
<div class="desc"><p>Shared exceptions that don't belong to a single utility</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.logging" href="logging/index.html">aws_lambda_powertools.logging</a></code></dt>
<dd>
<div class="desc"><p>Logging utility</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.metrics" href="metrics/index.html">aws_lambda_powertools.metrics</a></code></dt>
<dd>
<div class="desc"><p>CloudWatch Embedded Metric Format utility</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.middleware_factory" href="middleware_factory/index.html">aws_lambda_powertools.middleware_factory</a></code></dt>
<dd>
<div class="desc"><p>Utilities to enhance middlewares</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.package_logger" href="package_logger.html">aws_lambda_powertools.package_logger</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.shared" href="shared/index.html">aws_lambda_powertools.shared</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.tracing" href="tracing/index.html">aws_lambda_powertools.tracing</a></code></dt>
<dd>
<div class="desc"><p>Tracing utility</p></div>
</dd>
<dt><code class="name"><a title="aws_lambda_powertools.utilities" href="utilities/index.html">aws_lambda_powertools.utilities</a></code></dt>
<dd>
<div class="desc"><p>General utilities for Powertools</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.single_metric"><code class="name flex">
<span>def <span class="ident">single_metric</span></span>(<span>name: str, unit: <a title="aws_lambda_powertools.metrics.base.MetricUnit" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a>, value: float, resolution: Union[<a title="aws_lambda_powertools.metrics.base.MetricResolution" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a>, int] = 60, namespace: Optional[str] = None, default_dimensions: Optional[Dict[str, str]] = None) ‑> Generator[<a title="aws_lambda_powertools.metrics.base.SingleMetric" href="metrics/base.html#aws_lambda_powertools.metrics.base.SingleMetric">SingleMetric</a>, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager to simplify creation of a single metric</p>
<h2 id="example">Example</h2>
<p><strong>Creates cold start metric with function_version as dimension</strong></p>
<pre><code>from aws_lambda_powertools import single_metric
from aws_lambda_powertools.metrics import MetricUnit
from aws_lambda_powertools.metrics import MetricResolution

with single_metric(name="ColdStart", unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard, namespace="ServerlessAirline") as metric: # noqa E501
    metric.add_dimension(name="function_version", value="47")
</code></pre>
<p><strong>Same as above but set namespace using environment variable</strong></p>
<pre><code>$ export POWERTOOLS_METRICS_NAMESPACE="ServerlessAirline"

from aws_lambda_powertools import single_metric
from aws_lambda_powertools.metrics import MetricUnit
from aws_lambda_powertools.metrics import MetricResolution

with single_metric(name="ColdStart", unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard) as metric: # noqa E501
    metric.add_dimension(name="function_version", value="47")
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Metric name</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>MetricUnit</code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricUnit</code></dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>MetricResolution</code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricResolution</code></dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Metric value</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code></dt>
<dd>Namespace for metrics</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>SingleMetric</code></dt>
<dd>SingleMetric class instance</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MetricUnitError</code></dt>
<dd>When metric metric isn't supported by CloudWatch</dd>
<dt><code>MetricResolutionError</code></dt>
<dd>When metric resolution isn't supported by CloudWatch</dd>
<dt><code>MetricValueError</code></dt>
<dd>When metric value isn't a number</dd>
<dt><code>SchemaValidationError</code></dt>
<dd>When metric object fails EMF schema validation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def single_metric(
    name: str,
    unit: MetricUnit,
    value: float,
    resolution: Union[MetricResolution, int] = 60,
    namespace: Optional[str] = None,
    default_dimensions: Optional[Dict[str, str]] = None,
) -&gt; Generator[SingleMetric, None, None]:
    &#34;&#34;&#34;Context manager to simplify creation of a single metric

    Example
    -------
    **Creates cold start metric with function_version as dimension**

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard, namespace=&#34;ServerlessAirline&#34;) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    **Same as above but set namespace using environment variable**

        $ export POWERTOOLS_METRICS_NAMESPACE=&#34;ServerlessAirline&#34;

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    Parameters
    ----------
    name : str
        Metric name
    unit : MetricUnit
        `aws_lambda_powertools.helper.models.MetricUnit`
    resolution : MetricResolution
        `aws_lambda_powertools.helper.models.MetricResolution`
    value : float
        Metric value
    namespace: str
        Namespace for metrics

    Yields
    -------
    SingleMetric
        SingleMetric class instance

    Raises
    ------
    MetricUnitError
        When metric metric isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;
    metric_set: Optional[Dict] = None
    try:
        metric: SingleMetric = SingleMetric(namespace=namespace)
        metric.add_metric(name=name, unit=unit, value=value, resolution=resolution)

        if default_dimensions:
            for dim_name, dim_value in default_dimensions.items():
                metric.add_dimension(name=dim_name, value=dim_value)

        yield metric
        metric_set = metric.serialize_metric_set()
    finally:
        print(json.dumps(metric_set, separators=(&#34;,&#34;, &#34;:&#34;)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.Logger"><code class="flex name class">
<span>class <span class="ident">Logger</span></span>
<span>(</span><span>service: Optional[str] = None, level: Union[str, int, None] = None, child: bool = False, sampling_rate: Optional[float] = None, stream: Optional[IO[str]] = None, logger_formatter: Optional[PowertoolsFormatter] = None, logger_handler: Optional[logging.Handler] = None, log_uncaught_exceptions: bool = False, json_serializer: Optional[Callable[[Dict], str]] = None, json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None, json_default: Optional[Callable[[Any], Any]] = None, datefmt: Optional[str] = None, use_datetime_directive: bool = False, log_record_order: Optional[List[str]] = None, utc: bool = False, use_rfc3339: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and setups a logger to format statements in JSON.</p>
<p>Includes service name and any additional key=value into logs
It also accepts both service name or level explicitly via env vars</p>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_SERVICE_NAME : str
service name
LOG_LEVEL: str
logging level (e.g. INFO, DEBUG)
POWERTOOLS_LOGGER_SAMPLE_RATE: float
sampling rate ranging from 0 to 1, 1 being 100% sampling</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name to be appended in logs, by default "service_undefined"</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str, int optional</code></dt>
<dd>logging.level, by default "INFO"</dd>
<dt><strong><code>child</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>create a child Logger named <service>.<caller_file_name>, False by default</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>sample rate for debug calls within execution context defaults to 0.0</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code>, optional</dt>
<dd>valid output for a logging stream, by default sys.stdout</dd>
<dt><strong><code>logger_formatter</code></strong> :&ensp;<code>PowertoolsFormatter</code>, optional</dt>
<dd>custom logging formatter that implements PowertoolsFormatter</dd>
<dt><strong><code>logger_handler</code></strong> :&ensp;<code>logging.Handler</code>, optional</dt>
<dd>custom logging handler e.g. logging.FileHandler("file.log")</dd>
<dt><strong><code>log_uncaught_exceptions</code></strong> :&ensp;<code>bool, by default False</code></dt>
<dd>
<p>logs uncaught exception using sys.excepthook</p>
<p>See: <a href="https://docs.python.org/3/library/sys.html#sys.excepthook">https://docs.python.org/3/library/sys.html#sys.excepthook</a></p>
</dd>
</dl>
<h2 id="parameters-propagated-to-lambdapowertoolsformatter">Parameters Propagated To Lambdapowertoolsformatter</h2>
<p>datefmt: str, optional
String directives (strftime) to format log timestamp using <code>time</code>, by default it uses 2021-05-03 11:47:12,494+0200. # noqa: E501
use_datetime_directive: bool, optional
Interpret <code>datefmt</code> as a format string for <code>datetime.datetime.strftime</code>, rather than
<code>time.strftime</code>.</p>
<pre><code>See &lt;https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior&gt; . This
also supports a custom %F directive for milliseconds.
</code></pre>
<p>use_rfc3339: bool, optional
Whether to use a popular date format that complies with both RFC3339 and ISO8601.
e.g., 2022-10-27T16:27:43.738+02:00.
json_serializer : Callable, optional
function to serialize <code>obj</code> to a JSON formatted <code>str</code>, by default json.dumps
json_deserializer : Callable, optional
function to deserialize <code>str</code>, <code>bytes</code>, bytearray<code> containing a JSON document to a Python </code>obj`,
by default json.loads
json_default : Callable, optional
function to coerce unserializable values, by default <code>str()</code></p>
<pre><code>Only used when no custom formatter is set
</code></pre>
<p>utc : bool, optional
set logging timestamp to UTC, by default False to continue to use local time as per stdlib
log_record_order : list, optional
set order of log keys when logging, by default ["level", "location", "message", "timestamp"]</p>
<h2 id="example">Example</h2>
<p><strong>Setups structured logging in JSON for Lambda functions with explicit service name</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Setups structured logging in JSON for Lambda functions using env vars</strong></p>
<pre><code>$ export POWERTOOLS_SERVICE_NAME="payment"
$ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger()
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Append payment_id to previously setup logger</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.append_keys(payment_id=event["payment_id"])
        logger.info("Hello")
</code></pre>
<p><strong>Create child Logger using logging inheritance via child param</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import another_file
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; # another_file.py
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment", child=True)
</code></pre>
<p><strong>Logging in UTC timezone</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", utc=True)
</code></pre>
<p><strong>Brings message as the first key in log statements</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", log_record_order=["message"])
</code></pre>
<p><strong>Logging to a file instead of standard output for testing</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", logger_handler=logging.FileHandler("log.json"))
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidLoggerSamplingRateError</code></dt>
<dd>When sampling rate provided is not a float</dd>
</dl>
<p>Initialize the logger with a name and an optional level.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Logger(logging.Logger):  # lgtm [py/missing-call-to-init]
    &#34;&#34;&#34;Creates and setups a logger to format statements in JSON.

    Includes service name and any additional key=value into logs
    It also accepts both service name or level explicitly via env vars

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME : str
        service name
    LOG_LEVEL: str
        logging level (e.g. INFO, DEBUG)
    POWERTOOLS_LOGGER_SAMPLE_RATE: float
        sampling rate ranging from 0 to 1, 1 being 100% sampling

    Parameters
    ----------
    service : str, optional
        service name to be appended in logs, by default &#34;service_undefined&#34;
    level : str, int optional
        logging.level, by default &#34;INFO&#34;
    child: bool, optional
        create a child Logger named &lt;service&gt;.&lt;caller_file_name&gt;, False by default
    sample_rate: float, optional
        sample rate for debug calls within execution context defaults to 0.0
    stream: sys.stdout, optional
        valid output for a logging stream, by default sys.stdout
    logger_formatter: PowertoolsFormatter, optional
        custom logging formatter that implements PowertoolsFormatter
    logger_handler: logging.Handler, optional
        custom logging handler e.g. logging.FileHandler(&#34;file.log&#34;)
    log_uncaught_exceptions: bool, by default False
        logs uncaught exception using sys.excepthook

        See: https://docs.python.org/3/library/sys.html#sys.excepthook


    Parameters propagated to LambdaPowertoolsFormatter
    --------------------------------------------------
    datefmt: str, optional
        String directives (strftime) to format log timestamp using `time`, by default it uses 2021-05-03 11:47:12,494+0200. # noqa: E501
    use_datetime_directive: bool, optional
        Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
        `time.strftime`.

        See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
        also supports a custom %F directive for milliseconds.
    use_rfc3339: bool, optional
        Whether to use a popular date format that complies with both RFC3339 and ISO8601.
        e.g., 2022-10-27T16:27:43.738+02:00.
    json_serializer : Callable, optional
        function to serialize `obj` to a JSON formatted `str`, by default json.dumps
    json_deserializer : Callable, optional
        function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
        by default json.loads
    json_default : Callable, optional
        function to coerce unserializable values, by default `str()`

        Only used when no custom formatter is set
    utc : bool, optional
        set logging timestamp to UTC, by default False to continue to use local time as per stdlib
    log_record_order : list, optional
        set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]

    Example
    -------
    **Setups structured logging in JSON for Lambda functions with explicit service name**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Setups structured logging in JSON for Lambda functions using env vars**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        $ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger()
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Append payment_id to previously setup logger**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.append_keys(payment_id=event[&#34;payment_id&#34;])
                logger.info(&#34;Hello&#34;)

    **Create child Logger using logging inheritance via child param**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import another_file
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # another_file.py
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, child=True)

    **Logging in UTC timezone**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, utc=True)

    **Brings message as the first key in log statements**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, log_record_order=[&#34;message&#34;])

    **Logging to a file instead of standard output for testing**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, logger_handler=logging.FileHandler(&#34;log.json&#34;))

    Raises
    ------
    InvalidLoggerSamplingRateError
        When sampling rate provided is not a float
    &#34;&#34;&#34;

    def __init__(
        self,
        service: Optional[str] = None,
        level: Union[str, int, None] = None,
        child: bool = False,
        sampling_rate: Optional[float] = None,
        stream: Optional[IO[str]] = None,
        logger_formatter: Optional[PowertoolsFormatter] = None,
        logger_handler: Optional[logging.Handler] = None,
        log_uncaught_exceptions: bool = False,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        self.service = resolve_env_var_choice(
            choice=service, env=os.getenv(constants.SERVICE_NAME_ENV, &#34;service_undefined&#34;)
        )
        self.sampling_rate = resolve_env_var_choice(
            choice=sampling_rate, env=os.getenv(constants.LOGGER_LOG_SAMPLING_RATE)
        )
        self.child = child
        self.logger_formatter = logger_formatter
        self.logger_handler = logger_handler or logging.StreamHandler(stream)
        self.log_uncaught_exceptions = log_uncaught_exceptions

        self.log_level = self._get_log_level(level)
        self._is_deduplication_disabled = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_DEDUPLICATION_ENV, &#34;false&#34;)
        )
        self._default_log_keys = {&#34;service&#34;: self.service, &#34;sampling_rate&#34;: self.sampling_rate}
        self._logger = self._get_logger()

        # NOTE: This is primarily to improve UX, so IDEs can autocomplete LambdaPowertoolsFormatter options
        # previously, we masked all of them as kwargs thus limiting feature discovery
        formatter_options = {
            &#34;json_serializer&#34;: json_serializer,
            &#34;json_deserializer&#34;: json_deserializer,
            &#34;json_default&#34;: json_default,
            &#34;datefmt&#34;: datefmt,
            &#34;use_datetime_directive&#34;: use_datetime_directive,
            &#34;log_record_order&#34;: log_record_order,
            &#34;utc&#34;: utc,
            &#34;use_rfc3339&#34;: use_rfc3339,
        }

        self._init_logger(formatter_options=formatter_options, **kwargs)

        if self.log_uncaught_exceptions:
            logger.debug(&#34;Replacing exception hook&#34;)
            sys.excepthook = functools.partial(log_uncaught_exception_hook, logger=self)

    # Prevent __getattr__ from shielding unknown attribute errors in type checkers
    # https://github.com/awslabs/aws-lambda-powertools-python/issues/1660
    if not TYPE_CHECKING:

        def __getattr__(self, name):
            # Proxy attributes not found to actual logger to support backward compatibility
            # https://github.com/awslabs/aws-lambda-powertools-python/issues/97
            return getattr(self._logger, name)

    def _get_logger(self):
        &#34;&#34;&#34;Returns a Logger named {self.service}, or {self.service.filename} for child loggers&#34;&#34;&#34;
        logger_name = self.service
        if self.child:
            logger_name = f&#34;{self.service}.{self._get_caller_filename()}&#34;

        return logging.getLogger(logger_name)

    def _init_logger(self, formatter_options: Optional[Dict] = None, **kwargs):
        &#34;&#34;&#34;Configures new logger&#34;&#34;&#34;

        # Skip configuration if it&#39;s a child logger or a pre-configured logger
        # to prevent the following:
        #   a) multiple handlers being attached
        #   b) different sampling mechanisms
        #   c) multiple messages from being logged as handlers can be duplicated
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if self.child or is_logger_preconfigured:
            return

        self._configure_sampling()
        self._logger.setLevel(self.log_level)
        self._logger.addHandler(self.logger_handler)
        self.structure_logs(formatter_options=formatter_options, **kwargs)

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        self._logger.findCaller = self.findCaller

        # Pytest Live Log feature duplicates log records for colored output
        # but we explicitly add a filter for log deduplication.
        # This flag disables this protection when you explicit want logs to be duplicated (#262)
        if not self._is_deduplication_disabled:
            logger.debug(&#34;Adding filter in root logger to suppress child logger records to bubble up&#34;)
            for handler in logging.root.handlers:
                # It&#39;ll add a filter to suppress any child logger from self.service
                # Example: `Logger(service=&#34;order&#34;)`, where service is Order
                # It&#39;ll reject all loggers starting with `order` e.g. order.checkout, order.shared
                handler.addFilter(SuppressFilter(self.service))

        # as per bug in #249, we should not be pre-configuring an existing logger
        # therefore we set a custom attribute in the Logger that will be returned
        # std logging will return the same Logger with our attribute if name is reused
        logger.debug(f&#34;Marking logger {self.service} as preconfigured&#34;)
        self._logger.init = True

    def _configure_sampling(self):
        &#34;&#34;&#34;Dynamically set log level based on sampling rate

        Raises
        ------
        InvalidLoggerSamplingRateError
            When sampling rate provided is not a float
        &#34;&#34;&#34;
        try:
            if self.sampling_rate and random.random() &lt;= float(self.sampling_rate):
                logger.debug(&#34;Setting log level to Debug due to sampling rate&#34;)
                self.log_level = logging.DEBUG
        except ValueError:
            raise InvalidLoggerSamplingRateError(
                f&#34;Expected a float value ranging 0 to 1, but received {self.sampling_rate} instead.&#34;
                f&#34;Please review POWERTOOLS_LOGGER_SAMPLE_RATE environment variable.&#34;
            )

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: AnyCallableT,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; AnyCallableT:
        ...

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: None = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Callable[[AnyCallableT], AnyCallableT]:
        ...

    def inject_lambda_context(
        self,
        lambda_handler: Optional[AnyCallableT] = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into logger

        Parameters
        ----------
        clear_state : bool, optional
            Instructs logger to remove any custom keys previously added
        lambda_handler : Callable
            Method to inject the lambda context
        log_event : bool, optional
            Instructs logger to log Lambda Event, by default False
        correlation_id_path: str, optional
            Optional JMESPath for the correlation_id

        Environment variables
        ---------------------
        POWERTOOLS_LOGGER_LOG_EVENT : str
            instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

        Example
        -------
        **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        **Captures Lambda contextual runtime info and logs incoming request**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context(log_event=True)
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        Returns
        -------
        decorate : Callable
            Decorated lambda handler
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.inject_lambda_context,
                log_event=log_event,
                correlation_id_path=correlation_id_path,
                clear_state=clear_state,
            )

        log_event = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_EVENT_ENV, &#34;false&#34;), choice=log_event
        )

        @functools.wraps(lambda_handler)
        def decorate(event, context, *args, **kwargs):
            lambda_context = build_lambda_context_model(context)
            cold_start = _is_cold_start()

            if clear_state:
                self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
            else:
                self.append_keys(cold_start=cold_start, **lambda_context.__dict__)

            if correlation_id_path:
                self.set_correlation_id(jmespath.search(correlation_id_path, event))

            if log_event:
                logger.debug(&#34;Event received&#34;)
                self.info(extract_event_from_common_models(event))

            return lambda_handler(event, context, *args, **kwargs)

        return decorate

    def info(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.info(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.info(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def error(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.error(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.error(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def exception(
        self,
        msg: object,
        *args,
        exc_info=True,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.exception(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.exception(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def critical(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.critical(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.critical(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def warning(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.warning(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.warning(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def debug(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.debug(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.debug(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def append_keys(self, **additional_keys):
        self.registered_formatter.append_keys(**additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        self.registered_formatter.remove_keys(keys)

    @property
    def registered_handler(self) -&gt; logging.Handler:
        &#34;&#34;&#34;Convenience property to access logger handler&#34;&#34;&#34;
        handlers = self._logger.parent.handlers if self.child else self._logger.handlers
        return handlers[0]

    @property
    def registered_formatter(self) -&gt; BasePowertoolsFormatter:
        &#34;&#34;&#34;Convenience property to access logger formatter&#34;&#34;&#34;
        return self.registered_handler.formatter  # type: ignore

    def structure_logs(self, append: bool = False, formatter_options: Optional[Dict] = None, **keys):
        &#34;&#34;&#34;Sets logging formatting to JSON.

        Optionally, it can append keyword arguments
        to an existing logger, so it is available across future log statements.

        Last keyword argument and value wins if duplicated.

        Parameters
        ----------
        append : bool, optional
            append keys provided to logger formatter, by default False
        formatter_options : dict, optional
            LambdaPowertoolsFormatter options to be propagated, by default {}
        &#34;&#34;&#34;
        formatter_options = formatter_options or {}

        # There are 3 operational modes for this method
        ## 1. Register a Powertools Formatter for the first time
        ## 2. Append new keys to the current logger formatter; deprecated in favour of append_keys
        ## 3. Add new keys and discard existing to the registered formatter

        # Mode 1
        log_keys = {**self._default_log_keys, **keys}
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if not is_logger_preconfigured:
            formatter = self.logger_formatter or LambdaPowertoolsFormatter(**formatter_options, **log_keys)  # type: ignore # noqa: E501
            self.registered_handler.setFormatter(formatter)

            # when using a custom Lambda Powertools Formatter
            # standard and custom keys that are not Powertools Formatter parameters should be appended
            # and custom keys that might happen to be Powertools Formatter parameters should be discarded
            # this prevents adding them as custom keys, for example, `json_default=&lt;callable&gt;`
            # see https://github.com/awslabs/aws-lambda-powertools-python/issues/1263
            custom_keys = {k: v for k, v in log_keys.items() if k not in RESERVED_FORMATTER_CUSTOM_KEYS}
            return self.registered_formatter.append_keys(**custom_keys)

        # Mode 2 (legacy)
        if append:
            # Maintenance: Add deprecation warning for major version
            return self.append_keys(**keys)

        # Mode 3
        self.registered_formatter.clear_state()
        self.registered_formatter.append_keys(**log_keys)

    def set_correlation_id(self, value: Optional[str]):
        &#34;&#34;&#34;Sets the correlation_id in the logging json

        Parameters
        ----------
        value : str, optional
            Value for the correlation id. None will remove the correlation_id
        &#34;&#34;&#34;
        self.append_keys(correlation_id=value)

    def get_correlation_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Gets the correlation_id in the logging json

        Returns
        -------
        str, optional
            Value for the correlation id
        &#34;&#34;&#34;
        if isinstance(self.registered_formatter, LambdaPowertoolsFormatter):
            return self.registered_formatter.log_format.get(&#34;correlation_id&#34;)
        return None

    @staticmethod
    def _get_log_level(level: Union[str, int, None]) -&gt; Union[str, int]:
        &#34;&#34;&#34;Returns preferred log level set by the customer in upper case&#34;&#34;&#34;
        if isinstance(level, int):
            return level

        log_level: Optional[str] = level or os.getenv(&#34;LOG_LEVEL&#34;)
        if log_level is None:
            return logging.INFO

        return log_level.upper()

    @staticmethod
    def _get_caller_filename():
        &#34;&#34;&#34;Return caller filename by finding the caller frame&#34;&#34;&#34;
        # Current frame         =&gt; _get_logger()
        # Previous frame        =&gt; logger.py
        # Before previous frame =&gt; Caller
        frame = inspect.currentframe()
        caller_frame = frame.f_back.f_back.f_back
        return caller_frame.f_globals[&#34;__name__&#34;]

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    def findCaller(self, stack_info=False, stacklevel=2):  # pragma: no cover
        &#34;&#34;&#34;
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        &#34;&#34;&#34;
        f = logging.currentframe()  # noqa: VNE001
        # On some versions of IronPython, currentframe() returns None if
        # IronPython isn&#39;t run with -X:Frames.
        if f is None:
            return &#34;(unknown file)&#34;, 0, &#34;(unknown function)&#34;, None
        while stacklevel &gt; 0:
            next_f = f.f_back
            if next_f is None:
                ## We&#39;ve got options here.
                ## If we want to use the last (deepest) frame:
                break
                ## If we want to mimic the warnings module:
                # return (&#34;sys&#34;, 1, &#34;(unknown function)&#34;, None) # noqa: E800
                ## If we want to be pedantic:  # noqa: E800
                # raise ValueError(&#34;call stack is not deep enough&#34;) # noqa: E800
            f = next_f  # noqa: VNE001
            if not _is_internal_frame(f):
                stacklevel -= 1
        co = f.f_code
        sinfo = None
        if stack_info:
            with io.StringIO() as sio:
                sio.write(&#34;Stack (most recent call last):\n&#34;)
                traceback.print_stack(f, file=sio)
                sinfo = sio.getvalue()
                if sinfo[-1] == &#34;\n&#34;:
                    sinfo = sinfo[:-1]
        return co.co_filename, f.f_lineno, co.co_name, sinfo</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.Logger" href="logging/index.html#aws_lambda_powertools.logging.Logger">Logger</a></li>
<li>logging.Filterer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.Logger.append_keys"><code class="name flex">
<span>def <span class="ident">append_keys</span></span>(<span>self, **additional_keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_keys(self, **additional_keys):
    self.registered_formatter.append_keys(**additional_keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Logger.remove_keys"><code class="name flex">
<span>def <span class="ident">remove_keys</span></span>(<span>self, keys: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keys(self, keys: Iterable[str]):
    self.registered_formatter.remove_keys(keys)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aws_lambda_powertools.logging.Logger" href="logging/index.html#aws_lambda_powertools.logging.Logger">Logger</a></b></code>:
<ul class="hlist">
<li><code><a title="aws_lambda_powertools.logging.Logger.critical" href="logging/index.html#aws_lambda_powertools.logging.Logger.critical">critical</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.debug" href="logging/index.html#aws_lambda_powertools.logging.Logger.debug">debug</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.error" href="logging/index.html#aws_lambda_powertools.logging.Logger.error">error</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.exception" href="logging/index.html#aws_lambda_powertools.logging.Logger.exception">exception</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.findCaller" href="logging/index.html#aws_lambda_powertools.logging.Logger.findCaller">findCaller</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.get_correlation_id" href="logging/index.html#aws_lambda_powertools.logging.Logger.get_correlation_id">get_correlation_id</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.info" href="logging/index.html#aws_lambda_powertools.logging.Logger.info">info</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.inject_lambda_context" href="logging/index.html#aws_lambda_powertools.logging.Logger.inject_lambda_context">inject_lambda_context</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.registered_formatter" href="logging/index.html#aws_lambda_powertools.logging.Logger.registered_formatter">registered_formatter</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.registered_handler" href="logging/index.html#aws_lambda_powertools.logging.Logger.registered_handler">registered_handler</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.set_correlation_id" href="logging/index.html#aws_lambda_powertools.logging.Logger.set_correlation_id">set_correlation_id</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.structure_logs" href="logging/index.html#aws_lambda_powertools.logging.Logger.structure_logs">structure_logs</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.Logger.warning" href="logging/index.html#aws_lambda_powertools.logging.Logger.warning">warning</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="aws_lambda_powertools.Metrics"><code class="flex name class">
<span>class <span class="ident">Metrics</span></span>
<span>(</span><span>service: Optional[str] = None, namespace: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Metrics create an EMF object with up to 100 metrics</p>
<p>Use Metrics when you need to create multiple metrics that have
dimensions in common (e.g. service_name="payment").</p>
<p>Metrics up to 100 metrics in memory and are shared across
all its instances. That means it can be safely instantiated outside
of a Lambda function, or anywhere else.</p>
<p>A decorator (log_metrics) is provided so metrics are published at the end of its execution.
If more than 100 metrics are added at a given function execution,
these metrics are serialized and published before adding a given metric
to prevent metric truncation.</p>
<h2 id="example">Example</h2>
<p><strong>Creates a few metrics and publish at the end of a function execution</strong></p>
<pre><code>from aws_lambda_powertools import Metrics

metrics = Metrics(namespace="ServerlessAirline", service="payment")

@metrics.log_metrics(capture_cold_start_metric=True)
def lambda_handler():
    metrics.add_metric(name="BookingConfirmation", unit="Count", value=1)
    metrics.add_dimension(name="function_version", value="$LATEST")

    return True
</code></pre>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_METRICS_NAMESPACE : str
metric namespace
POWERTOOLS_SERVICE_NAME : str
service name used for default dimension</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name to be used as metric dimension, by default "service_undefined"</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace for metrics</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MetricUnitError</code></dt>
<dd>When metric unit isn't supported by CloudWatch</dd>
<dt><code>MetricResolutionError</code></dt>
<dd>When metric resolution isn't supported by CloudWatch</dd>
<dt><code>MetricValueError</code></dt>
<dd>When metric value isn't a number</dd>
<dt><code>SchemaValidationError</code></dt>
<dd>When metric object fails EMF schema validation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metrics(MetricManager):
    &#34;&#34;&#34;Metrics create an EMF object with up to 100 metrics

    Use Metrics when you need to create multiple metrics that have
    dimensions in common (e.g. service_name=&#34;payment&#34;).

    Metrics up to 100 metrics in memory and are shared across
    all its instances. That means it can be safely instantiated outside
    of a Lambda function, or anywhere else.

    A decorator (log_metrics) is provided so metrics are published at the end of its execution.
    If more than 100 metrics are added at a given function execution,
    these metrics are serialized and published before adding a given metric
    to prevent metric truncation.

    Example
    -------
    **Creates a few metrics and publish at the end of a function execution**

        from aws_lambda_powertools import Metrics

        metrics = Metrics(namespace=&#34;ServerlessAirline&#34;, service=&#34;payment&#34;)

        @metrics.log_metrics(capture_cold_start_metric=True)
        def lambda_handler():
            metrics.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1)
            metrics.add_dimension(name=&#34;function_version&#34;, value=&#34;$LATEST&#34;)

            return True

    Environment variables
    ---------------------
    POWERTOOLS_METRICS_NAMESPACE : str
        metric namespace
    POWERTOOLS_SERVICE_NAME : str
        service name used for default dimension

    Parameters
    ----------
    service : str, optional
        service name to be used as metric dimension, by default &#34;service_undefined&#34;
    namespace : str, optional
        Namespace for metrics

    Raises
    ------
    MetricUnitError
        When metric unit isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;

    # NOTE: We use class attrs to share metrics data across instances
    # this allows customers to initialize Metrics() throughout their code base (and middlewares)
    # and not get caught by accident with metrics data loss, or data deduplication
    # e.g., m1 and m2 add metric ProductCreated, however m1 has &#39;version&#39; dimension  but m2 doesn&#39;t
    # Result: ProductCreated is created twice as we now have 2 different EMF blobs
    _metrics: Dict[str, Any] = {}
    _dimensions: Dict[str, str] = {}
    _metadata: Dict[str, Any] = {}
    _default_dimensions: Dict[str, Any] = {}

    def __init__(self, service: Optional[str] = None, namespace: Optional[str] = None):
        self.metric_set = self._metrics
        self.metadata_set = self._metadata
        self.default_dimensions = self._default_dimensions
        self.dimension_set = self._dimensions

        self.dimension_set.update(**self._default_dimensions)
        return super().__init__(
            namespace=namespace,
            service=service,
            metric_set=self.metric_set,
            dimension_set=self.dimension_set,
            metadata_set=self.metadata_set,
        )

    def set_default_dimensions(self, **dimensions) -&gt; None:
        &#34;&#34;&#34;Persist dimensions across Lambda invocations

        Parameters
        ----------
        dimensions : Dict[str, Any], optional
            metric dimensions as key=value

        Example
        -------
        **Sets some default dimensions that will always be present across metrics and invocations**

            from aws_lambda_powertools import Metrics

            metrics = Metrics(namespace=&#34;ServerlessAirline&#34;, service=&#34;payment&#34;)
            metrics.set_default_dimensions(environment=&#34;demo&#34;, another=&#34;one&#34;)

            @metrics.log_metrics()
            def lambda_handler():
                return True
        &#34;&#34;&#34;
        for name, value in dimensions.items():
            self.add_dimension(name, value)

        self.default_dimensions.update(**dimensions)

    def clear_default_dimensions(self) -&gt; None:
        self.default_dimensions.clear()

    def clear_metrics(self) -&gt; None:
        super().clear_metrics()
        # re-add default dimensions
        self.set_default_dimensions(**self.default_dimensions)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.metrics.base.MetricManager" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.Metrics.clear_default_dimensions"><code class="name flex">
<span>def <span class="ident">clear_default_dimensions</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_default_dimensions(self) -&gt; None:
    self.default_dimensions.clear()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Metrics.clear_metrics"><code class="name flex">
<span>def <span class="ident">clear_metrics</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_metrics(self) -&gt; None:
    super().clear_metrics()
    # re-add default dimensions
    self.set_default_dimensions(**self.default_dimensions)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Metrics.set_default_dimensions"><code class="name flex">
<span>def <span class="ident">set_default_dimensions</span></span>(<span>self, **dimensions) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Persist dimensions across Lambda invocations</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>Dict[str, Any]</code>, optional</dt>
<dd>metric dimensions as key=value</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Sets some default dimensions that will always be present across metrics and invocations</strong></p>
<pre><code>from aws_lambda_powertools import Metrics

metrics = Metrics(namespace="ServerlessAirline", service="payment")
metrics.set_default_dimensions(environment="demo", another="one")

@metrics.log_metrics()
def lambda_handler():
    return True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_dimensions(self, **dimensions) -&gt; None:
    &#34;&#34;&#34;Persist dimensions across Lambda invocations

    Parameters
    ----------
    dimensions : Dict[str, Any], optional
        metric dimensions as key=value

    Example
    -------
    **Sets some default dimensions that will always be present across metrics and invocations**

        from aws_lambda_powertools import Metrics

        metrics = Metrics(namespace=&#34;ServerlessAirline&#34;, service=&#34;payment&#34;)
        metrics.set_default_dimensions(environment=&#34;demo&#34;, another=&#34;one&#34;)

        @metrics.log_metrics()
        def lambda_handler():
            return True
    &#34;&#34;&#34;
    for name, value in dimensions.items():
        self.add_dimension(name, value)

    self.default_dimensions.update(**dimensions)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aws_lambda_powertools.metrics.base.MetricManager" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></b></code>:
<ul class="hlist">
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_dimension" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.add_dimension">add_dimension</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_metadata" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.add_metadata">add_metadata</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_metric" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.add_metric">add_metric</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.flush_metrics" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.flush_metrics">flush_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.log_metrics" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.log_metrics">log_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set" href="metrics/base.html#aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set">serialize_metric_set</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="aws_lambda_powertools.Tracer"><code class="flex name class">
<span>class <span class="ident">Tracer</span></span>
<span>(</span><span>service: Optional[str] = None, disabled: Optional[bool] = None, auto_patch: Optional[bool] = None, patch_modules: Optional[Sequence[str]] = None, provider: Optional[<a title="aws_lambda_powertools.tracing.base.BaseProvider" href="tracing/base.html#aws_lambda_powertools.tracing.base.BaseProvider">BaseProvider</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracer using AWS-XRay to provide decorators with known defaults for Lambda functions</p>
<p>When running locally, it detects whether it's running via SAM CLI,
and if it is it returns dummy segments/subsegments instead.</p>
<p>By default, it patches all available libraries supported by X-Ray SDK. Patching is
automatically disabled when running locally via SAM CLI or by any other means. </p>
<p>Ref: <a href="https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html">https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html</a></p>
<p>Tracer keeps a copy of its configuration as it can be instantiated more than once. This
is useful when you are using your own middlewares and want to utilize an existing Tracer.
Make sure to set <code>auto_patch=False</code> in subsequent Tracer instances to avoid double patching.</p>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_TRACE_DISABLED : str
disable tracer (e.g. <code>"true", "True", "TRUE"</code>)
POWERTOOLS_SERVICE_NAME : str
service name
POWERTOOLS_TRACER_CAPTURE_RESPONSE : str
disable auto-capture response as metadata (e.g. <code>"true", "True", "TRUE"</code>)
POWERTOOLS_TRACER_CAPTURE_ERROR : str
disable auto-capture error as metadata (e.g. <code>"true", "True", "TRUE"</code>)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code></dt>
<dd>Service name that will be appended in all tracing metadata</dd>
<dt><strong><code>auto_patch</code></strong> :&ensp;<code>bool</code></dt>
<dd>Patch existing imported modules during initialization, by default True</dd>
<dt><strong><code>disabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to explicitly disable tracing, useful when running/testing locally
<code>Env POWERTOOLS_TRACE_DISABLED="true"</code></dd>
<dt><strong><code>patch_modules</code></strong> :&ensp;<code>Optional[Sequence[str]]</code></dt>
<dd>Tuple of modules supported by tracing provider to patch, by default all modules are patched</dd>
<dt><strong><code>provider</code></strong> :&ensp;<code>BaseProvider</code></dt>
<dd>Tracing provider, by default it is aws_xray_sdk.core.xray_recorder</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="aws_lambda_powertools.Tracer" href="#aws_lambda_powertools.Tracer">Tracer</a></code></dt>
<dd>Tracer instance with imported modules patched</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>A Lambda function using Tracer</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="greeting")

@tracer.capture_method
def greeting(name: str) -&gt; Dict:
    return {
        "name": name
    }

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    response = greeting(name="Heitor")
    return response
</code></pre>
<p><strong>Booking Lambda function using Tracer that adds additional annotation/metadata</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
def confirm_booking(booking_id: str) -&gt; Dict:
        resp = add_confirmation(booking_id)

        tracer.put_annotation("BookingConfirmation", resp["requestId"])
        tracer.put_metadata("Booking confirmation", resp)

        return resp

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    booking_id = event.get("booking_id")
    response = confirm_booking(booking_id=booking_id)
    return response
</code></pre>
<p><strong>A Lambda function using service name via POWERTOOLS_SERVICE_NAME</strong></p>
<pre><code>export POWERTOOLS_SERVICE_NAME="booking"
from aws_lambda_powertools import Tracer
tracer = Tracer()

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    response = greeting(name="Lessa")
    return response
</code></pre>
<p><strong>Reuse an existing instance of Tracer anywhere in the code</strong></p>
<pre><code># lambda_handler.py
from aws_lambda_powertools import Tracer
tracer = Tracer()

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    ...

# utils.py
from aws_lambda_powertools import Tracer
tracer = Tracer()
...
</code></pre>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Async handler not supported</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tracer:
    &#34;&#34;&#34;Tracer using AWS-XRay to provide decorators with known defaults for Lambda functions

    When running locally, it detects whether it&#39;s running via SAM CLI,
    and if it is it returns dummy segments/subsegments instead.

    By default, it patches all available libraries supported by X-Ray SDK. Patching is
    automatically disabled when running locally via SAM CLI or by any other means. \n
    Ref: https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html

    Tracer keeps a copy of its configuration as it can be instantiated more than once. This
    is useful when you are using your own middlewares and want to utilize an existing Tracer.
    Make sure to set `auto_patch=False` in subsequent Tracer instances to avoid double patching.

    Environment variables
    ---------------------
    POWERTOOLS_TRACE_DISABLED : str
        disable tracer (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)
    POWERTOOLS_SERVICE_NAME : str
        service name
    POWERTOOLS_TRACER_CAPTURE_RESPONSE : str
        disable auto-capture response as metadata (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)
    POWERTOOLS_TRACER_CAPTURE_ERROR : str
        disable auto-capture error as metadata (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

    Parameters
    ----------
    service: str
        Service name that will be appended in all tracing metadata
    auto_patch: bool
        Patch existing imported modules during initialization, by default True
    disabled: bool
        Flag to explicitly disable tracing, useful when running/testing locally
        `Env POWERTOOLS_TRACE_DISABLED=&#34;true&#34;`
    patch_modules: Optional[Sequence[str]]
        Tuple of modules supported by tracing provider to patch, by default all modules are patched
    provider: BaseProvider
        Tracing provider, by default it is aws_xray_sdk.core.xray_recorder

    Returns
    -------
    Tracer
        Tracer instance with imported modules patched

    Example
    -------
    **A Lambda function using Tracer**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;greeting&#34;)

        @tracer.capture_method
        def greeting(name: str) -&gt; Dict:
            return {
                &#34;name&#34;: name
            }

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Heitor&#34;)
            return response

    **Booking Lambda function using Tracer that adds additional annotation/metadata**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        def confirm_booking(booking_id: str) -&gt; Dict:
                resp = add_confirmation(booking_id)

                tracer.put_annotation(&#34;BookingConfirmation&#34;, resp[&#34;requestId&#34;])
                tracer.put_metadata(&#34;Booking confirmation&#34;, resp)

                return resp

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            booking_id = event.get(&#34;booking_id&#34;)
            response = confirm_booking(booking_id=booking_id)
            return response

    **A Lambda function using service name via POWERTOOLS_SERVICE_NAME**

        export POWERTOOLS_SERVICE_NAME=&#34;booking&#34;
        from aws_lambda_powertools import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Lessa&#34;)
            return response

    **Reuse an existing instance of Tracer anywhere in the code**

        # lambda_handler.py
        from aws_lambda_powertools import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            ...

        # utils.py
        from aws_lambda_powertools import Tracer
        tracer = Tracer()
        ...

    Limitations
    -----------
    * Async handler not supported
    &#34;&#34;&#34;

    _default_config: Dict[str, Any] = {
        &#34;service&#34;: &#34;&#34;,
        &#34;disabled&#34;: False,
        &#34;auto_patch&#34;: True,
        &#34;patch_modules&#34;: None,
        &#34;provider&#34;: None,
    }
    _config = copy.copy(_default_config)

    def __init__(
        self,
        service: Optional[str] = None,
        disabled: Optional[bool] = None,
        auto_patch: Optional[bool] = None,
        patch_modules: Optional[Sequence[str]] = None,
        provider: Optional[BaseProvider] = None,
    ):
        self.__build_config(
            service=service, disabled=disabled, auto_patch=auto_patch, patch_modules=patch_modules, provider=provider
        )
        self.provider: BaseProvider = self._config[&#34;provider&#34;]
        self.disabled = self._config[&#34;disabled&#34;]
        self.service = self._config[&#34;service&#34;]
        self.auto_patch = self._config[&#34;auto_patch&#34;]

        if self.disabled:
            self._disable_tracer_provider()

        if self.auto_patch:
            self.patch(modules=patch_modules)

        if self._is_xray_provider():
            self._disable_xray_trace_batching()

    def put_annotation(self, key: str, value: Union[str, numbers.Number, bool]):
        &#34;&#34;&#34;Adds annotation to existing segment or subsegment

        Parameters
        ----------
        key : str
            Annotation key
        value : Union[str, numbers.Number, bool]
            Value for annotation

        Example
        -------
        Custom annotation for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            tracer.put_annotation(&#34;PaymentStatus&#34;, &#34;CONFIRMED&#34;)
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting put_annotation&#34;)
            return

        logger.debug(f&#34;Annotating on key &#39;{key}&#39; with &#39;{value}&#39;&#34;)
        self.provider.put_annotation(key=key, value=value)

    def put_metadata(self, key: str, value: Any, namespace: Optional[str] = None):
        &#34;&#34;&#34;Adds metadata to existing segment or subsegment

        Parameters
        ----------
        key : str
            Metadata key
        value : any
            Value for metadata
        namespace : str, optional
            Namespace that metadata will lie under, by default None

        Example
        -------
        Custom metadata for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            response = collect_payment()
            tracer.put_metadata(&#34;Payment collection&#34;, response)
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting put_metadata&#34;)
            return

        namespace = namespace or self.service
        logger.debug(f&#34;Adding metadata on key &#39;{key}&#39; with &#39;{value}&#39; at namespace &#39;{namespace}&#39;&#34;)
        self.provider.put_metadata(key=key, value=value, namespace=namespace)

    def patch(self, modules: Optional[Sequence[str]] = None):
        &#34;&#34;&#34;Patch modules for instrumentation.

        Patches all supported modules by default if none are given.

        Parameters
        ----------
        modules : Optional[Sequence[str]]
            List of modules to be patched, optional by default
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting patch&#34;)
            return

        if modules is None:
            self.provider.patch_all()
        else:
            self.provider.patch(modules)

    def capture_lambda_handler(
        self,
        lambda_handler: Union[Callable[[Dict, Any], Any], Optional[Callable[[Dict, Any, Optional[Dict]], Any]]] = None,
        capture_response: Optional[bool] = None,
        capture_error: Optional[bool] = None,
    ):
        &#34;&#34;&#34;Decorator to create subsegment for lambda handlers

        As Lambda follows (event, context) signature we can remove some of the boilerplate
        and also capture any exception any Lambda function throws or its response as metadata

        Parameters
        ----------
        lambda_handler : Callable
            Method to annotate on
        capture_response : bool, optional
            Instructs tracer to not include handler&#39;s response as metadata
        capture_error : bool, optional
            Instructs tracer to not include handler&#39;s error as metadata, by default True

        Example
        -------
        **Lambda function using capture_lambda_handler decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_lambda_handler
            def handler(event, context):
                ...

        **Preventing Tracer to log response as metadata**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_lambda_handler(capture_response=False)
            def handler(event, context):
                ...

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;
        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.capture_lambda_handler, capture_response=capture_response, capture_error=capture_error
            )

        lambda_handler_name = lambda_handler.__name__
        capture_response = resolve_truthy_env_var_choice(
            env=os.getenv(constants.TRACER_CAPTURE_RESPONSE_ENV, &#34;true&#34;), choice=capture_response
        )
        capture_error = resolve_truthy_env_var_choice(
            env=os.getenv(constants.TRACER_CAPTURE_ERROR_ENV, &#34;true&#34;), choice=capture_error
        )

        @functools.wraps(lambda_handler)
        def decorate(event, context, **kwargs):
            with self.provider.in_subsegment(name=f&#34;## {lambda_handler_name}&#34;) as subsegment:
                try:
                    logger.debug(&#34;Calling lambda handler&#34;)
                    response = lambda_handler(event, context, **kwargs)
                    logger.debug(&#34;Received lambda handler response successfully&#34;)
                    self._add_response_as_metadata(
                        method_name=lambda_handler_name,
                        data=response,
                        subsegment=subsegment,
                        capture_response=capture_response,
                    )
                except Exception as err:
                    logger.exception(f&#34;Exception received from {lambda_handler_name}&#34;)
                    self._add_full_exception_as_metadata(
                        method_name=lambda_handler_name, error=err, subsegment=subsegment, capture_error=capture_error
                    )

                    raise
                finally:
                    global is_cold_start
                    logger.debug(&#34;Annotating cold start&#34;)
                    subsegment.put_annotation(key=&#34;ColdStart&#34;, value=is_cold_start)

                    if is_cold_start:
                        is_cold_start = False

                    if self.service:
                        subsegment.put_annotation(key=&#34;Service&#34;, value=self.service)

                return response

        return decorate

    # see #465
    @overload
    def capture_method(self, method: &#34;AnyCallableT&#34;) -&gt; &#34;AnyCallableT&#34;:
        ...  # pragma: no cover

    @overload
    def capture_method(
        self,
        method: None = None,
        capture_response: Optional[bool] = None,
        capture_error: Optional[bool] = None,
    ) -&gt; Callable[[&#34;AnyCallableT&#34;], &#34;AnyCallableT&#34;]:
        ...  # pragma: no cover

    def capture_method(
        self,
        method: Optional[AnyCallableT] = None,
        capture_response: Optional[bool] = None,
        capture_error: Optional[bool] = None,
    ) -&gt; AnyCallableT:
        &#34;&#34;&#34;Decorator to create subsegment for arbitrary functions

        It also captures both response and exceptions as metadata
        and creates a subsegment named `## &lt;method_module.method_qualifiedname&gt;`
        # see here: [Qualified name for classes and functions](https://peps.python.org/pep-3155/)

        When running [async functions concurrently](https://docs.python.org/3/library/asyncio-task.html#id6),
        methods may impact each others subsegment, and can trigger
        and AlreadyEndedException from X-Ray due to async nature.

        For this use case, either use `capture_method` only where
        `async.gather` is called, or use `in_subsegment_async`
        context manager via our escape hatch mechanism - See examples.

        Parameters
        ----------
        method : Callable
            Method to annotate on
        capture_response : bool, optional
            Instructs tracer to not include method&#39;s response as metadata
        capture_error : bool, optional
            Instructs tracer to not include handler&#39;s error as metadata, by default True

        Example
        -------
        **Custom function using capture_method decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_method
            def some_function()

        **Custom async method using capture_method decorator**

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            @tracer.capture_method
            async def confirm_booking(booking_id: str) -&gt; Dict:
                resp = call_to_booking_service()

                tracer.put_annotation(&#34;BookingConfirmation&#34;, resp[&#34;requestId&#34;])
                tracer.put_metadata(&#34;Booking confirmation&#34;, resp)

                return resp

            def lambda_handler(event: dict, context: Any) -&gt; Dict:
                booking_id = event.get(&#34;booking_id&#34;)
                asyncio.run(confirm_booking(booking_id=booking_id))

        **Custom generator function using capture_method decorator**

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            @tracer.capture_method
            def bookings_generator(booking_id):
                resp = call_to_booking_service()
                yield resp[0]
                yield resp[1]

            def lambda_handler(event: dict, context: Any) -&gt; Dict:
                gen = bookings_generator(booking_id=booking_id)
                result = list(gen)

        **Custom generator context manager using capture_method decorator**

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            @tracer.capture_method
            @contextlib.contextmanager
            def booking_actions(booking_id):
                resp = call_to_booking_service()
                yield &#34;example result&#34;
                cleanup_stuff()

            def lambda_handler(event: dict, context: Any) -&gt; Dict:
                booking_id = event.get(&#34;booking_id&#34;)

                with booking_actions(booking_id=booking_id) as booking:
                    result = booking

        **Tracing nested async calls**

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            @tracer.capture_method
            async def get_identity():
                ...

            @tracer.capture_method
            async def long_async_call():
                ...

            @tracer.capture_method
            async def async_tasks():
                await get_identity()
                ret = await long_async_call()

                return { &#34;task&#34;: &#34;done&#34;, **ret }

        **Safely tracing concurrent async calls with decorator**

        This may not needed once [this bug is closed](https://github.com/aws/aws-xray-sdk-python/issues/164)

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            async def get_identity():
                async with aioboto3.client(&#34;sts&#34;) as sts:
                    account = await sts.get_caller_identity()
                    return account

            async def long_async_call():
                ...

            @tracer.capture_method
            async def async_tasks():
                _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

                return { &#34;task&#34;: &#34;done&#34;, **ret }

        **Safely tracing each concurrent async calls with escape hatch**

        This may not needed once [this bug is closed](https://github.com/aws/aws-xray-sdk-python/issues/164)

            from aws_lambda_powertools import Tracer
            tracer = Tracer(service=&#34;booking&#34;)

            async def get_identity():
                async tracer.provider.in_subsegment_async(&#34;## get_identity&#34;):
                    ...

            async def long_async_call():
                async tracer.provider.in_subsegment_async(&#34;## long_async_call&#34;):
                    ...

            @tracer.capture_method
            async def async_tasks():
                _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

                return { &#34;task&#34;: &#34;done&#34;, **ret }

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;
        # If method is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if method is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return cast(
                AnyCallableT,
                functools.partial(self.capture_method, capture_response=capture_response, capture_error=capture_error),
            )

        # Example: app.ClassA.get_all  # noqa E800
        method_name = f&#34;{method.__module__}.{method.__qualname__}&#34;

        capture_response = resolve_truthy_env_var_choice(
            env=os.getenv(constants.TRACER_CAPTURE_RESPONSE_ENV, &#34;true&#34;), choice=capture_response
        )
        capture_error = resolve_truthy_env_var_choice(
            env=os.getenv(constants.TRACER_CAPTURE_ERROR_ENV, &#34;true&#34;), choice=capture_error
        )

        # Maintenance: Need a factory/builder here to simplify this now
        if inspect.iscoroutinefunction(method):
            return self._decorate_async_function(
                method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
            )
        elif inspect.isgeneratorfunction(method):
            return self._decorate_generator_function(
                method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
            )
        elif hasattr(method, &#34;__wrapped__&#34;) and inspect.isgeneratorfunction(method.__wrapped__):
            return self._decorate_generator_function_with_context_manager(
                method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
            )
        else:
            return self._decorate_sync_function(
                method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
            )

    def _decorate_async_function(
        self,
        method: Callable,
        capture_response: Optional[Union[bool, str]] = None,
        capture_error: Optional[Union[bool, str]] = None,
        method_name: Optional[str] = None,
    ):
        @functools.wraps(method)
        async def decorate(*args, **kwargs):
            async with self.provider.in_subsegment_async(name=f&#34;## {method_name}&#34;) as subsegment:
                try:
                    logger.debug(f&#34;Calling method: {method_name}&#34;)
                    response = await method(*args, **kwargs)
                    self._add_response_as_metadata(
                        method_name=method_name, data=response, subsegment=subsegment, capture_response=capture_response
                    )
                except Exception as err:
                    logger.exception(f&#34;Exception received from &#39;{method_name}&#39; method&#34;)
                    self._add_full_exception_as_metadata(
                        method_name=method_name, error=err, subsegment=subsegment, capture_error=capture_error
                    )
                    raise

                return response

        return decorate

    def _decorate_generator_function(
        self,
        method: Callable,
        capture_response: Optional[Union[bool, str]] = None,
        capture_error: Optional[Union[bool, str]] = None,
        method_name: Optional[str] = None,
    ):
        @functools.wraps(method)
        def decorate(*args, **kwargs):
            with self.provider.in_subsegment(name=f&#34;## {method_name}&#34;) as subsegment:
                try:
                    logger.debug(f&#34;Calling method: {method_name}&#34;)
                    result = yield from method(*args, **kwargs)
                    self._add_response_as_metadata(
                        method_name=method_name, data=result, subsegment=subsegment, capture_response=capture_response
                    )
                except Exception as err:
                    logger.exception(f&#34;Exception received from &#39;{method_name}&#39; method&#34;)
                    self._add_full_exception_as_metadata(
                        method_name=method_name, error=err, subsegment=subsegment, capture_error=capture_error
                    )
                    raise

                return result

        return decorate

    def _decorate_generator_function_with_context_manager(
        self,
        method: Callable,
        capture_response: Optional[Union[bool, str]] = None,
        capture_error: Optional[Union[bool, str]] = None,
        method_name: Optional[str] = None,
    ):
        @functools.wraps(method)
        @contextlib.contextmanager
        def decorate(*args, **kwargs):
            with self.provider.in_subsegment(name=f&#34;## {method_name}&#34;) as subsegment:
                try:
                    logger.debug(f&#34;Calling method: {method_name}&#34;)
                    with method(*args, **kwargs) as return_val:
                        result = return_val
                        yield result
                    self._add_response_as_metadata(
                        method_name=method_name, data=result, subsegment=subsegment, capture_response=capture_response
                    )
                except Exception as err:
                    logger.exception(f&#34;Exception received from &#39;{method_name}&#39; method&#34;)
                    self._add_full_exception_as_metadata(
                        method_name=method_name, error=err, subsegment=subsegment, capture_error=capture_error
                    )
                    raise

        return decorate

    def _decorate_sync_function(
        self,
        method: AnyCallableT,
        capture_response: Optional[Union[bool, str]] = None,
        capture_error: Optional[Union[bool, str]] = None,
        method_name: Optional[str] = None,
    ) -&gt; AnyCallableT:
        @functools.wraps(method)
        def decorate(*args, **kwargs):
            with self.provider.in_subsegment(name=f&#34;## {method_name}&#34;) as subsegment:
                try:
                    logger.debug(f&#34;Calling method: {method_name}&#34;)
                    response = method(*args, **kwargs)
                    self._add_response_as_metadata(
                        method_name=method_name,
                        data=response,
                        subsegment=subsegment,
                        capture_response=capture_response,
                    )
                except Exception as err:
                    logger.exception(f&#34;Exception received from &#39;{method_name}&#39; method&#34;)
                    self._add_full_exception_as_metadata(
                        method_name=method_name, error=err, subsegment=subsegment, capture_error=capture_error
                    )
                    raise

                return response

        return cast(AnyCallableT, decorate)

    def _add_response_as_metadata(
        self,
        method_name: Optional[str] = None,
        data: Optional[Any] = None,
        subsegment: Optional[BaseSegment] = None,
        capture_response: Optional[Union[bool, str]] = None,
    ):
        &#34;&#34;&#34;Add response as metadata for given subsegment

        Parameters
        ----------
        method_name : str, optional
            method name to add as metadata key, by default None
        data : Any, optional
            data to add as subsegment metadata, by default None
        subsegment : BaseSegment, optional
            existing subsegment to add metadata on, by default None
        capture_response : bool, optional
            Do not include response as metadata
        &#34;&#34;&#34;
        if data is None or not capture_response or subsegment is None:
            return

        subsegment.put_metadata(key=f&#34;{method_name} response&#34;, value=data, namespace=self.service)

    def _add_full_exception_as_metadata(
        self,
        method_name: str,
        error: Exception,
        subsegment: BaseSegment,
        capture_error: Optional[bool] = None,
    ):
        &#34;&#34;&#34;Add full exception object as metadata for given subsegment

        Parameters
        ----------
        method_name : str
            method name to add as metadata key, by default None
        error : Exception
            error to add as subsegment metadata, by default None
        subsegment : BaseSegment
            existing subsegment to add metadata on, by default None
        capture_error : bool, optional
            Do not include error as metadata, by default True
        &#34;&#34;&#34;
        if not capture_error:
            return

        subsegment.put_metadata(key=f&#34;{method_name} error&#34;, value=error, namespace=self.service)

    @staticmethod
    def _disable_tracer_provider():
        &#34;&#34;&#34;Forcefully disables tracing&#34;&#34;&#34;
        logger.debug(&#34;Disabling tracer provider...&#34;)
        aws_xray_sdk.global_sdk_config.set_sdk_enabled(False)

    @staticmethod
    def _is_tracer_disabled() -&gt; Union[bool, str]:
        &#34;&#34;&#34;Detects whether trace has been disabled

        Tracing is automatically disabled in the following conditions:

        1. Explicitly disabled via `TRACE_DISABLED` environment variable
        2. Running in Lambda Emulators, or locally where X-Ray Daemon will not be listening
        3. Explicitly disabled via constructor e.g `Tracer(disabled=True)`

        Returns
        -------
        Union[bool, str]
        &#34;&#34;&#34;
        logger.debug(&#34;Verifying whether Tracing has been disabled&#34;)
        is_lambda_env = os.getenv(constants.LAMBDA_TASK_ROOT_ENV)
        is_disabled = resolve_truthy_env_var_choice(env=os.getenv(constants.TRACER_DISABLED_ENV, &#34;false&#34;))

        if is_disabled:
            logger.debug(&#34;Tracing has been disabled via env var POWERTOOLS_TRACE_DISABLED&#34;)
            return is_disabled

        if not is_lambda_env:
            logger.debug(&#34;Running outside Lambda env; disabling Tracing&#34;)
            return True

        return False

    def __build_config(
        self,
        service: Optional[str] = None,
        disabled: Optional[bool] = None,
        auto_patch: Optional[bool] = None,
        patch_modules: Optional[Sequence[str]] = None,
        provider: Optional[BaseProvider] = None,
    ):
        &#34;&#34;&#34;Populates Tracer config for new and existing initializations&#34;&#34;&#34;
        is_disabled = disabled if disabled is not None else self._is_tracer_disabled()
        is_service = resolve_env_var_choice(choice=service, env=os.getenv(constants.SERVICE_NAME_ENV))

        # Logic: Choose overridden option first, previously cached config, or default if available
        self._config[&#34;provider&#34;] = provider or self._config[&#34;provider&#34;] or self._patch_xray_provider()
        self._config[&#34;auto_patch&#34;] = auto_patch if auto_patch is not None else self._config[&#34;auto_patch&#34;]
        self._config[&#34;service&#34;] = is_service or self._config[&#34;service&#34;]
        self._config[&#34;disabled&#34;] = is_disabled or self._config[&#34;disabled&#34;]
        self._config[&#34;patch_modules&#34;] = patch_modules or self._config[&#34;patch_modules&#34;]

    @classmethod
    def _reset_config(cls):
        cls._config = copy.copy(cls._default_config)

    def _patch_xray_provider(self):
        # Due to Lazy Import, we need to activate `core` attrib via import
        # we also need to include `patch`, `patch_all` methods
        # to ensure patch calls are done via the provider
        from aws_xray_sdk.core import xray_recorder  # type: ignore

        provider = xray_recorder
        provider.patch = aws_xray_sdk.core.patch
        provider.patch_all = aws_xray_sdk.core.patch_all

        return provider

    def _disable_xray_trace_batching(self):
        &#34;&#34;&#34;Configure X-Ray SDK to send subsegment individually over batching
        Known issue: https://github.com/awslabs/aws-lambda-powertools-python/issues/283
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting streaming override&#34;)
            return

        aws_xray_sdk.core.xray_recorder.configure(streaming_threshold=0)

    def _is_xray_provider(self):
        return &#34;aws_xray_sdk&#34; in self.provider.__module__

    def ignore_endpoint(self, hostname: Optional[str] = None, urls: Optional[List[str]] = None):
        &#34;&#34;&#34;If you want to ignore certain httplib requests you can do so based on the hostname or URL that is being
        requested.

        &gt; NOTE: If the provider is not xray, nothing will be added to ignore list

        Documentation
        --------------
        - https://github.com/aws/aws-xray-sdk-python#ignoring-httplib-requests

        Parameters
        ----------
        hostname : Optional, str
            The hostname is matched using the Python fnmatch library which does Unix glob style matching.
        urls: Optional, List[str]
            List of urls to ignore. Example `tracer.ignore_endpoint(urls=[&#34;/ignored-url&#34;])`
        &#34;&#34;&#34;
        if not self._is_xray_provider():
            return

        from aws_xray_sdk.ext.httplib import add_ignored  # type: ignore

        add_ignored(hostname=hostname, urls=urls)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.Tracer.capture_lambda_handler"><code class="name flex">
<span>def <span class="ident">capture_lambda_handler</span></span>(<span>self, lambda_handler: Union[Callable[[Dict, Any], Any], Callable[[Dict, Any, Optional[Dict]], Any], ForwardRef(None)] = None, capture_response: Optional[bool] = None, capture_error: Optional[bool] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to create subsegment for lambda handlers</p>
<p>As Lambda follows (event, context) signature we can remove some of the boilerplate
and also capture any exception any Lambda function throws or its response as metadata</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lambda_handler</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method to annotate on</dd>
<dt><strong><code>capture_response</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs tracer to not include handler's response as metadata</dd>
<dt><strong><code>capture_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs tracer to not include handler's error as metadata, by default True</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Lambda function using capture_lambda_handler decorator</strong></p>
<pre><code>tracer = Tracer(service="payment")
@tracer.capture_lambda_handler
def handler(event, context):
    ...
</code></pre>
<p><strong>Preventing Tracer to log response as metadata</strong></p>
<pre><code>tracer = Tracer(service="payment")
@tracer.capture_lambda_handler(capture_response=False)
def handler(event, context):
    ...
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>err</code></dt>
<dd>Exception raised by method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_lambda_handler(
    self,
    lambda_handler: Union[Callable[[Dict, Any], Any], Optional[Callable[[Dict, Any, Optional[Dict]], Any]]] = None,
    capture_response: Optional[bool] = None,
    capture_error: Optional[bool] = None,
):
    &#34;&#34;&#34;Decorator to create subsegment for lambda handlers

    As Lambda follows (event, context) signature we can remove some of the boilerplate
    and also capture any exception any Lambda function throws or its response as metadata

    Parameters
    ----------
    lambda_handler : Callable
        Method to annotate on
    capture_response : bool, optional
        Instructs tracer to not include handler&#39;s response as metadata
    capture_error : bool, optional
        Instructs tracer to not include handler&#39;s error as metadata, by default True

    Example
    -------
    **Lambda function using capture_lambda_handler decorator**

        tracer = Tracer(service=&#34;payment&#34;)
        @tracer.capture_lambda_handler
        def handler(event, context):
            ...

    **Preventing Tracer to log response as metadata**

        tracer = Tracer(service=&#34;payment&#34;)
        @tracer.capture_lambda_handler(capture_response=False)
        def handler(event, context):
            ...

    Raises
    ------
    err
        Exception raised by method
    &#34;&#34;&#34;
    # If handler is None we&#39;ve been called with parameters
    # Return a partial function with args filled
    if lambda_handler is None:
        logger.debug(&#34;Decorator called with parameters&#34;)
        return functools.partial(
            self.capture_lambda_handler, capture_response=capture_response, capture_error=capture_error
        )

    lambda_handler_name = lambda_handler.__name__
    capture_response = resolve_truthy_env_var_choice(
        env=os.getenv(constants.TRACER_CAPTURE_RESPONSE_ENV, &#34;true&#34;), choice=capture_response
    )
    capture_error = resolve_truthy_env_var_choice(
        env=os.getenv(constants.TRACER_CAPTURE_ERROR_ENV, &#34;true&#34;), choice=capture_error
    )

    @functools.wraps(lambda_handler)
    def decorate(event, context, **kwargs):
        with self.provider.in_subsegment(name=f&#34;## {lambda_handler_name}&#34;) as subsegment:
            try:
                logger.debug(&#34;Calling lambda handler&#34;)
                response = lambda_handler(event, context, **kwargs)
                logger.debug(&#34;Received lambda handler response successfully&#34;)
                self._add_response_as_metadata(
                    method_name=lambda_handler_name,
                    data=response,
                    subsegment=subsegment,
                    capture_response=capture_response,
                )
            except Exception as err:
                logger.exception(f&#34;Exception received from {lambda_handler_name}&#34;)
                self._add_full_exception_as_metadata(
                    method_name=lambda_handler_name, error=err, subsegment=subsegment, capture_error=capture_error
                )

                raise
            finally:
                global is_cold_start
                logger.debug(&#34;Annotating cold start&#34;)
                subsegment.put_annotation(key=&#34;ColdStart&#34;, value=is_cold_start)

                if is_cold_start:
                    is_cold_start = False

                if self.service:
                    subsegment.put_annotation(key=&#34;Service&#34;, value=self.service)

            return response

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Tracer.capture_method"><code class="name flex">
<span>def <span class="ident">capture_method</span></span>(<span>self, method: Optional[~AnyCallableT] = None, capture_response: Optional[bool] = None, capture_error: Optional[bool] = None) ‑> ~AnyCallableT</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to create subsegment for arbitrary functions</p>
<p>It also captures both response and exceptions as metadata
and creates a subsegment named <code>## &lt;method_module.method_qualifiedname&gt;</code></p>
<h1 id="see-here-qualified-name-for-classes-and-functions">see here: <a href="https://peps.python.org/pep-3155/">Qualified name for classes and functions</a></h1>
<p>When running <a href="https://docs.python.org/3/library/asyncio-task.html#id6">async functions concurrently</a>,
methods may impact each others subsegment, and can trigger
and AlreadyEndedException from X-Ray due to async nature.</p>
<p>For this use case, either use <code>capture_method</code> only where
<code>async.gather</code> is called, or use <code>in_subsegment_async</code>
context manager via our escape hatch mechanism - See examples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method to annotate on</dd>
<dt><strong><code>capture_response</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs tracer to not include method's response as metadata</dd>
<dt><strong><code>capture_error</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs tracer to not include handler's error as metadata, by default True</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Custom function using capture_method decorator</strong></p>
<pre><code>tracer = Tracer(service="payment")
@tracer.capture_method
def some_function()
</code></pre>
<p><strong>Custom async method using capture_method decorator</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
async def confirm_booking(booking_id: str) -&gt; Dict:
    resp = call_to_booking_service()

    tracer.put_annotation("BookingConfirmation", resp["requestId"])
    tracer.put_metadata("Booking confirmation", resp)

    return resp

def lambda_handler(event: dict, context: Any) -&gt; Dict:
    booking_id = event.get("booking_id")
    asyncio.run(confirm_booking(booking_id=booking_id))
</code></pre>
<p><strong>Custom generator function using capture_method decorator</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
def bookings_generator(booking_id):
    resp = call_to_booking_service()
    yield resp[0]
    yield resp[1]

def lambda_handler(event: dict, context: Any) -&gt; Dict:
    gen = bookings_generator(booking_id=booking_id)
    result = list(gen)
</code></pre>
<p><strong>Custom generator context manager using capture_method decorator</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
@contextlib.contextmanager
def booking_actions(booking_id):
    resp = call_to_booking_service()
    yield "example result"
    cleanup_stuff()

def lambda_handler(event: dict, context: Any) -&gt; Dict:
    booking_id = event.get("booking_id")

    with booking_actions(booking_id=booking_id) as booking:
        result = booking
</code></pre>
<p><strong>Tracing nested async calls</strong></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
async def get_identity():
    ...

@tracer.capture_method
async def long_async_call():
    ...

@tracer.capture_method
async def async_tasks():
    await get_identity()
    ret = await long_async_call()

    return { "task": "done", **ret }
</code></pre>
<p><strong>Safely tracing concurrent async calls with decorator</strong></p>
<p>This may not needed once <a href="https://github.com/aws/aws-xray-sdk-python/issues/164">this bug is closed</a></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

async def get_identity():
    async with aioboto3.client("sts") as sts:
        account = await sts.get_caller_identity()
        return account

async def long_async_call():
    ...

@tracer.capture_method
async def async_tasks():
    _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

    return { "task": "done", **ret }
</code></pre>
<p><strong>Safely tracing each concurrent async calls with escape hatch</strong></p>
<p>This may not needed once <a href="https://github.com/aws/aws-xray-sdk-python/issues/164">this bug is closed</a></p>
<pre><code>from aws_lambda_powertools import Tracer
tracer = Tracer(service="booking")

async def get_identity():
    async tracer.provider.in_subsegment_async("## get_identity"):
        ...

async def long_async_call():
    async tracer.provider.in_subsegment_async("## long_async_call"):
        ...

@tracer.capture_method
async def async_tasks():
    _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

    return { "task": "done", **ret }
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>err</code></dt>
<dd>Exception raised by method</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_method(
    self,
    method: Optional[AnyCallableT] = None,
    capture_response: Optional[bool] = None,
    capture_error: Optional[bool] = None,
) -&gt; AnyCallableT:
    &#34;&#34;&#34;Decorator to create subsegment for arbitrary functions

    It also captures both response and exceptions as metadata
    and creates a subsegment named `## &lt;method_module.method_qualifiedname&gt;`
    # see here: [Qualified name for classes and functions](https://peps.python.org/pep-3155/)

    When running [async functions concurrently](https://docs.python.org/3/library/asyncio-task.html#id6),
    methods may impact each others subsegment, and can trigger
    and AlreadyEndedException from X-Ray due to async nature.

    For this use case, either use `capture_method` only where
    `async.gather` is called, or use `in_subsegment_async`
    context manager via our escape hatch mechanism - See examples.

    Parameters
    ----------
    method : Callable
        Method to annotate on
    capture_response : bool, optional
        Instructs tracer to not include method&#39;s response as metadata
    capture_error : bool, optional
        Instructs tracer to not include handler&#39;s error as metadata, by default True

    Example
    -------
    **Custom function using capture_method decorator**

        tracer = Tracer(service=&#34;payment&#34;)
        @tracer.capture_method
        def some_function()

    **Custom async method using capture_method decorator**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        async def confirm_booking(booking_id: str) -&gt; Dict:
            resp = call_to_booking_service()

            tracer.put_annotation(&#34;BookingConfirmation&#34;, resp[&#34;requestId&#34;])
            tracer.put_metadata(&#34;Booking confirmation&#34;, resp)

            return resp

        def lambda_handler(event: dict, context: Any) -&gt; Dict:
            booking_id = event.get(&#34;booking_id&#34;)
            asyncio.run(confirm_booking(booking_id=booking_id))

    **Custom generator function using capture_method decorator**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        def bookings_generator(booking_id):
            resp = call_to_booking_service()
            yield resp[0]
            yield resp[1]

        def lambda_handler(event: dict, context: Any) -&gt; Dict:
            gen = bookings_generator(booking_id=booking_id)
            result = list(gen)

    **Custom generator context manager using capture_method decorator**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        @contextlib.contextmanager
        def booking_actions(booking_id):
            resp = call_to_booking_service()
            yield &#34;example result&#34;
            cleanup_stuff()

        def lambda_handler(event: dict, context: Any) -&gt; Dict:
            booking_id = event.get(&#34;booking_id&#34;)

            with booking_actions(booking_id=booking_id) as booking:
                result = booking

    **Tracing nested async calls**

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        async def get_identity():
            ...

        @tracer.capture_method
        async def long_async_call():
            ...

        @tracer.capture_method
        async def async_tasks():
            await get_identity()
            ret = await long_async_call()

            return { &#34;task&#34;: &#34;done&#34;, **ret }

    **Safely tracing concurrent async calls with decorator**

    This may not needed once [this bug is closed](https://github.com/aws/aws-xray-sdk-python/issues/164)

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        async def get_identity():
            async with aioboto3.client(&#34;sts&#34;) as sts:
                account = await sts.get_caller_identity()
                return account

        async def long_async_call():
            ...

        @tracer.capture_method
        async def async_tasks():
            _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

            return { &#34;task&#34;: &#34;done&#34;, **ret }

    **Safely tracing each concurrent async calls with escape hatch**

    This may not needed once [this bug is closed](https://github.com/aws/aws-xray-sdk-python/issues/164)

        from aws_lambda_powertools import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        async def get_identity():
            async tracer.provider.in_subsegment_async(&#34;## get_identity&#34;):
                ...

        async def long_async_call():
            async tracer.provider.in_subsegment_async(&#34;## long_async_call&#34;):
                ...

        @tracer.capture_method
        async def async_tasks():
            _, ret = await asyncio.gather(get_identity(), long_async_call(), return_exceptions=True)

            return { &#34;task&#34;: &#34;done&#34;, **ret }

    Raises
    ------
    err
        Exception raised by method
    &#34;&#34;&#34;
    # If method is None we&#39;ve been called with parameters
    # Return a partial function with args filled
    if method is None:
        logger.debug(&#34;Decorator called with parameters&#34;)
        return cast(
            AnyCallableT,
            functools.partial(self.capture_method, capture_response=capture_response, capture_error=capture_error),
        )

    # Example: app.ClassA.get_all  # noqa E800
    method_name = f&#34;{method.__module__}.{method.__qualname__}&#34;

    capture_response = resolve_truthy_env_var_choice(
        env=os.getenv(constants.TRACER_CAPTURE_RESPONSE_ENV, &#34;true&#34;), choice=capture_response
    )
    capture_error = resolve_truthy_env_var_choice(
        env=os.getenv(constants.TRACER_CAPTURE_ERROR_ENV, &#34;true&#34;), choice=capture_error
    )

    # Maintenance: Need a factory/builder here to simplify this now
    if inspect.iscoroutinefunction(method):
        return self._decorate_async_function(
            method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
        )
    elif inspect.isgeneratorfunction(method):
        return self._decorate_generator_function(
            method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
        )
    elif hasattr(method, &#34;__wrapped__&#34;) and inspect.isgeneratorfunction(method.__wrapped__):
        return self._decorate_generator_function_with_context_manager(
            method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
        )
    else:
        return self._decorate_sync_function(
            method=method, capture_response=capture_response, capture_error=capture_error, method_name=method_name
        )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Tracer.ignore_endpoint"><code class="name flex">
<span>def <span class="ident">ignore_endpoint</span></span>(<span>self, hostname: Optional[str] = None, urls: Optional[List[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>If you want to ignore certain httplib requests you can do so based on the hostname or URL that is being
requested.</p>
<blockquote>
<p>NOTE: If the provider is not xray, nothing will be added to ignore list</p>
</blockquote>
<h2 id="documentation">Documentation</h2>
<ul>
<li><a href="https://github.com/aws/aws-xray-sdk-python#ignoring-httplib-requests">https://github.com/aws/aws-xray-sdk-python#ignoring-httplib-requests</a></li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>Optional, str</code></dt>
<dd>The hostname is matched using the Python fnmatch library which does Unix glob style matching.</dd>
<dt><strong><code>urls</code></strong> :&ensp;<code>Optional, List[str]</code></dt>
<dd>List of urls to ignore. Example <code>tracer.ignore_endpoint(urls=["/ignored-url"])</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore_endpoint(self, hostname: Optional[str] = None, urls: Optional[List[str]] = None):
    &#34;&#34;&#34;If you want to ignore certain httplib requests you can do so based on the hostname or URL that is being
    requested.

    &gt; NOTE: If the provider is not xray, nothing will be added to ignore list

    Documentation
    --------------
    - https://github.com/aws/aws-xray-sdk-python#ignoring-httplib-requests

    Parameters
    ----------
    hostname : Optional, str
        The hostname is matched using the Python fnmatch library which does Unix glob style matching.
    urls: Optional, List[str]
        List of urls to ignore. Example `tracer.ignore_endpoint(urls=[&#34;/ignored-url&#34;])`
    &#34;&#34;&#34;
    if not self._is_xray_provider():
        return

    from aws_xray_sdk.ext.httplib import add_ignored  # type: ignore

    add_ignored(hostname=hostname, urls=urls)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Tracer.patch"><code class="name flex">
<span>def <span class="ident">patch</span></span>(<span>self, modules: Optional[Sequence[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Patch modules for instrumentation.</p>
<p>Patches all supported modules by default if none are given.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modules</code></strong> :&ensp;<code>Optional[Sequence[str]]</code></dt>
<dd>List of modules to be patched, optional by default</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patch(self, modules: Optional[Sequence[str]] = None):
    &#34;&#34;&#34;Patch modules for instrumentation.

    Patches all supported modules by default if none are given.

    Parameters
    ----------
    modules : Optional[Sequence[str]]
        List of modules to be patched, optional by default
    &#34;&#34;&#34;
    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, aborting patch&#34;)
        return

    if modules is None:
        self.provider.patch_all()
    else:
        self.provider.patch(modules)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Tracer.put_annotation"><code class="name flex">
<span>def <span class="ident">put_annotation</span></span>(<span>self, key: str, value: Union[str, numbers.Number, bool])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds annotation to existing segment or subsegment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Annotation key</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[str, numbers.Number, bool]</code></dt>
<dd>Value for annotation</dd>
</dl>
<h2 id="example">Example</h2>
<p>Custom annotation for a pseudo service named payment</p>
<pre><code>tracer = Tracer(service="payment")
tracer.put_annotation("PaymentStatus", "CONFIRMED")
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_annotation(self, key: str, value: Union[str, numbers.Number, bool]):
    &#34;&#34;&#34;Adds annotation to existing segment or subsegment

    Parameters
    ----------
    key : str
        Annotation key
    value : Union[str, numbers.Number, bool]
        Value for annotation

    Example
    -------
    Custom annotation for a pseudo service named payment

        tracer = Tracer(service=&#34;payment&#34;)
        tracer.put_annotation(&#34;PaymentStatus&#34;, &#34;CONFIRMED&#34;)
    &#34;&#34;&#34;
    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, aborting put_annotation&#34;)
        return

    logger.debug(f&#34;Annotating on key &#39;{key}&#39; with &#39;{value}&#39;&#34;)
    self.provider.put_annotation(key=key, value=value)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.Tracer.put_metadata"><code class="name flex">
<span>def <span class="ident">put_metadata</span></span>(<span>self, key: str, value: Any, namespace: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds metadata to existing segment or subsegment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Metadata key</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>any</code></dt>
<dd>Value for metadata</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace that metadata will lie under, by default None</dd>
</dl>
<h2 id="example">Example</h2>
<p>Custom metadata for a pseudo service named payment</p>
<pre><code>tracer = Tracer(service="payment")
response = collect_payment()
tracer.put_metadata("Payment collection", response)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_metadata(self, key: str, value: Any, namespace: Optional[str] = None):
    &#34;&#34;&#34;Adds metadata to existing segment or subsegment

    Parameters
    ----------
    key : str
        Metadata key
    value : any
        Value for metadata
    namespace : str, optional
        Namespace that metadata will lie under, by default None

    Example
    -------
    Custom metadata for a pseudo service named payment

        tracer = Tracer(service=&#34;payment&#34;)
        response = collect_payment()
        tracer.put_metadata(&#34;Payment collection&#34;, response)
    &#34;&#34;&#34;
    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, aborting put_metadata&#34;)
        return

    namespace = namespace or self.service
    logger.debug(f&#34;Adding metadata on key &#39;{key}&#39; with &#39;{value}&#39; at namespace &#39;{namespace}&#39;&#34;)
    self.provider.put_metadata(key=key, value=value, namespace=namespace)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="aws_lambda_powertools.event_handler" href="event_handler/index.html">aws_lambda_powertools.event_handler</a></code></li>
<li><code><a title="aws_lambda_powertools.exceptions" href="exceptions/index.html">aws_lambda_powertools.exceptions</a></code></li>
<li><code><a title="aws_lambda_powertools.logging" href="logging/index.html">aws_lambda_powertools.logging</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics" href="metrics/index.html">aws_lambda_powertools.metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.middleware_factory" href="middleware_factory/index.html">aws_lambda_powertools.middleware_factory</a></code></li>
<li><code><a title="aws_lambda_powertools.package_logger" href="package_logger.html">aws_lambda_powertools.package_logger</a></code></li>
<li><code><a title="aws_lambda_powertools.shared" href="shared/index.html">aws_lambda_powertools.shared</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing" href="tracing/index.html">aws_lambda_powertools.tracing</a></code></li>
<li><code><a title="aws_lambda_powertools.utilities" href="utilities/index.html">aws_lambda_powertools.utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.single_metric" href="#aws_lambda_powertools.single_metric">single_metric</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.Logger" href="#aws_lambda_powertools.Logger">Logger</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.Logger.append_keys" href="#aws_lambda_powertools.Logger.append_keys">append_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.Logger.remove_keys" href="#aws_lambda_powertools.Logger.remove_keys">remove_keys</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.Metrics" href="#aws_lambda_powertools.Metrics">Metrics</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.Metrics.clear_default_dimensions" href="#aws_lambda_powertools.Metrics.clear_default_dimensions">clear_default_dimensions</a></code></li>
<li><code><a title="aws_lambda_powertools.Metrics.clear_metrics" href="#aws_lambda_powertools.Metrics.clear_metrics">clear_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.Metrics.set_default_dimensions" href="#aws_lambda_powertools.Metrics.set_default_dimensions">set_default_dimensions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.Tracer" href="#aws_lambda_powertools.Tracer">Tracer</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.Tracer.capture_lambda_handler" href="#aws_lambda_powertools.Tracer.capture_lambda_handler">capture_lambda_handler</a></code></li>
<li><code><a title="aws_lambda_powertools.Tracer.capture_method" href="#aws_lambda_powertools.Tracer.capture_method">capture_method</a></code></li>
<li><code><a title="aws_lambda_powertools.Tracer.ignore_endpoint" href="#aws_lambda_powertools.Tracer.ignore_endpoint">ignore_endpoint</a></code></li>
<li><code><a title="aws_lambda_powertools.Tracer.patch" href="#aws_lambda_powertools.Tracer.patch">patch</a></code></li>
<li><code><a title="aws_lambda_powertools.Tracer.put_annotation" href="#aws_lambda_powertools.Tracer.put_annotation">put_annotation</a></code></li>
<li><code><a title="aws_lambda_powertools.Tracer.put_metadata" href="#aws_lambda_powertools.Tracer.put_metadata">put_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>