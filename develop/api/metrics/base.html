<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.metrics.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.metrics.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import functools
import json
import logging
import numbers
import os
import warnings
from collections import defaultdict
from contextlib import contextmanager
from enum import Enum
from typing import Any, Callable, Dict, Generator, List, Optional, Union

from ..shared import constants
from ..shared.functions import resolve_env_var_choice
from .exceptions import (
    MetricResolutionError,
    MetricUnitError,
    MetricValueError,
    SchemaValidationError,
)
from .types import MetricNameUnitResolution

logger = logging.getLogger(__name__)

MAX_METRICS = 100
MAX_DIMENSIONS = 29

is_cold_start = True


class MetricResolution(Enum):
    Standard = 60
    High = 1


class MetricUnit(Enum):
    Seconds = &#34;Seconds&#34;
    Microseconds = &#34;Microseconds&#34;
    Milliseconds = &#34;Milliseconds&#34;
    Bytes = &#34;Bytes&#34;
    Kilobytes = &#34;Kilobytes&#34;
    Megabytes = &#34;Megabytes&#34;
    Gigabytes = &#34;Gigabytes&#34;
    Terabytes = &#34;Terabytes&#34;
    Bits = &#34;Bits&#34;
    Kilobits = &#34;Kilobits&#34;
    Megabits = &#34;Megabits&#34;
    Gigabits = &#34;Gigabits&#34;
    Terabits = &#34;Terabits&#34;
    Percent = &#34;Percent&#34;
    Count = &#34;Count&#34;
    BytesPerSecond = &#34;Bytes/Second&#34;
    KilobytesPerSecond = &#34;Kilobytes/Second&#34;
    MegabytesPerSecond = &#34;Megabytes/Second&#34;
    GigabytesPerSecond = &#34;Gigabytes/Second&#34;
    TerabytesPerSecond = &#34;Terabytes/Second&#34;
    BitsPerSecond = &#34;Bits/Second&#34;
    KilobitsPerSecond = &#34;Kilobits/Second&#34;
    MegabitsPerSecond = &#34;Megabits/Second&#34;
    GigabitsPerSecond = &#34;Gigabits/Second&#34;
    TerabitsPerSecond = &#34;Terabits/Second&#34;
    CountPerSecond = &#34;Count/Second&#34;


class MetricManager:
    &#34;&#34;&#34;Base class for metric functionality (namespace, metric, dimension, serialization)

    MetricManager creates metrics asynchronously thanks to CloudWatch Embedded Metric Format (EMF).
    CloudWatch EMF can create up to 100 metrics per EMF object
    and metrics, dimensions, and namespace created via MetricManager
    will adhere to the schema, will be serialized and validated against EMF Schema.

    **Use `aws_lambda_powertools.metrics.metrics.Metrics` or
    `aws_lambda_powertools.metrics.metric.single_metric` to create EMF metrics.**

    Environment variables
    ---------------------
    POWERTOOLS_METRICS_NAMESPACE : str
        metric namespace to be set for all metrics
    POWERTOOLS_SERVICE_NAME : str
        service name used for default dimension

    Raises
    ------
    MetricUnitError
        When metric unit isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;

    def __init__(
        self,
        metric_set: Optional[Dict[str, Any]] = None,
        dimension_set: Optional[Dict] = None,
        namespace: Optional[str] = None,
        metadata_set: Optional[Dict[str, Any]] = None,
        service: Optional[str] = None,
    ):
        self.metric_set = metric_set if metric_set is not None else {}
        self.dimension_set = dimension_set if dimension_set is not None else {}
        self.namespace = resolve_env_var_choice(choice=namespace, env=os.getenv(constants.METRICS_NAMESPACE_ENV))
        self.service = resolve_env_var_choice(choice=service, env=os.getenv(constants.SERVICE_NAME_ENV))
        self.metadata_set = metadata_set if metadata_set is not None else {}
        self._metric_units = [unit.value for unit in MetricUnit]
        self._metric_unit_valid_options = list(MetricUnit.__members__)
        self._metric_resolutions = [resolution.value for resolution in MetricResolution]

    def add_metric(
        self,
        name: str,
        unit: Union[MetricUnit, str],
        value: float,
        resolution: Union[MetricResolution, int] = 60,
    ) -&gt; None:
        &#34;&#34;&#34;Adds given metric

        Example
        -------
        **Add given metric using MetricUnit enum**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=MetricUnit.Count, value=1)

        **Add given metric using plain string as value unit**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1)

        **Add given metric with MetricResolution non default value**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1, resolution=MetricResolution.High)

        Parameters
        ----------
        name : str
            Metric name
        unit : Union[MetricUnit, str]
            `aws_lambda_powertools.helper.models.MetricUnit`
        value : float
            Metric value
        resolution : Union[MetricResolution, int]
            `aws_lambda_powertools.helper.models.MetricResolution`

        Raises
        ------
        MetricUnitError
            When metric unit is not supported by CloudWatch
        MetricResolutionError
            When metric resolution is not supported by CloudWatch
        &#34;&#34;&#34;
        if not isinstance(value, numbers.Number):
            raise MetricValueError(f&#34;{value} is not a valid number&#34;)

        unit = self._extract_metric_unit_value(unit=unit)
        resolution = self._extract_metric_resolution_value(resolution=resolution)
        metric: Dict = self.metric_set.get(name, defaultdict(list))
        metric[&#34;Unit&#34;] = unit
        metric[&#34;StorageResolution&#34;] = resolution
        metric[&#34;Value&#34;].append(float(value))
        logger.debug(f&#34;Adding metric: {name} with {metric}&#34;)
        self.metric_set[name] = metric

        if len(self.metric_set) == MAX_METRICS or len(metric[&#34;Value&#34;]) == MAX_METRICS:
            logger.debug(f&#34;Exceeded maximum of {MAX_METRICS} metrics - Publishing existing metric set&#34;)
            metrics = self.serialize_metric_set()
            print(json.dumps(metrics))

            # clear metric set only as opposed to metrics and dimensions set
            # since we could have more than 100 metrics
            self.metric_set.clear()

    def serialize_metric_set(
        self, metrics: Optional[Dict] = None, dimensions: Optional[Dict] = None, metadata: Optional[Dict] = None
    ) -&gt; Dict:
        &#34;&#34;&#34;Serializes metric and dimensions set

        Parameters
        ----------
        metrics : Dict, optional
            Dictionary of metrics to serialize, by default None
        dimensions : Dict, optional
            Dictionary of dimensions to serialize, by default None
        metadata: Dict, optional
            Dictionary of metadata to serialize, by default None

        Example
        -------
        **Serialize metrics into EMF format**

            metrics = MetricManager()
            # ...add metrics, dimensions, namespace
            ret = metrics.serialize_metric_set()

        Returns
        -------
        Dict
            Serialized metrics following EMF specification

        Raises
        ------
        SchemaValidationError
            Raised when serialization fail schema validation
        &#34;&#34;&#34;
        if metrics is None:  # pragma: no cover
            metrics = self.metric_set

        if dimensions is None:  # pragma: no cover
            dimensions = self.dimension_set

        if metadata is None:  # pragma: no cover
            metadata = self.metadata_set

        if self.service and not self.dimension_set.get(&#34;service&#34;):
            # self.service won&#39;t be a float
            self.add_dimension(name=&#34;service&#34;, value=self.service)

        if len(metrics) == 0:
            raise SchemaValidationError(&#34;Must contain at least one metric.&#34;)

        if self.namespace is None:
            raise SchemaValidationError(&#34;Must contain a metric namespace.&#34;)

        logger.debug({&#34;details&#34;: &#34;Serializing metrics&#34;, &#34;metrics&#34;: metrics, &#34;dimensions&#34;: dimensions})

        # For standard resolution metrics, don&#39;t add StorageResolution field to avoid unnecessary ingestion of data into cloudwatch # noqa E501
        # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;} ] # noqa E800
        #
        # In case using high-resolution metrics, add StorageResolution field
        # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;, &#34;StorageResolution&#34;: 1 } ] # noqa E800
        metric_definition: List[MetricNameUnitResolution] = []
        metric_names_and_values: Dict[str, float] = {}  # { &#34;metric_name&#34;: 1.0 }

        for metric_name in metrics:
            metric: dict = metrics[metric_name]
            metric_value: int = metric.get(&#34;Value&#34;, 0)
            metric_unit: str = metric.get(&#34;Unit&#34;, &#34;&#34;)
            metric_resolution: int = metric.get(&#34;StorageResolution&#34;, 60)

            metric_definition_data: MetricNameUnitResolution = {&#34;Name&#34;: metric_name, &#34;Unit&#34;: metric_unit}

            # high-resolution metrics
            if metric_resolution == 1:
                metric_definition_data[&#34;StorageResolution&#34;] = metric_resolution

            metric_definition.append(metric_definition_data)

            metric_names_and_values.update({metric_name: metric_value})

        return {
            &#34;_aws&#34;: {
                &#34;Timestamp&#34;: int(datetime.datetime.now().timestamp() * 1000),  # epoch
                &#34;CloudWatchMetrics&#34;: [
                    {
                        &#34;Namespace&#34;: self.namespace,  # &#34;test_namespace&#34;
                        &#34;Dimensions&#34;: [list(dimensions.keys())],  # [ &#34;service&#34; ]
                        &#34;Metrics&#34;: metric_definition,
                    }
                ],
            },
            **dimensions,  # &#34;service&#34;: &#34;test_service&#34;
            **metadata,  # &#34;username&#34;: &#34;test&#34;
            **metric_names_and_values,  # &#34;single_metric&#34;: 1.0
        }

    def add_dimension(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Adds given dimension to all metrics

        Example
        -------
        **Add a metric dimensions**

            metric.add_dimension(name=&#34;operation&#34;, value=&#34;confirm_booking&#34;)

        Parameters
        ----------
        name : str
            Dimension name
        value : str
            Dimension value
        &#34;&#34;&#34;
        logger.debug(f&#34;Adding dimension: {name}:{value}&#34;)
        if len(self.dimension_set) == MAX_DIMENSIONS:
            raise SchemaValidationError(
                f&#34;Maximum number of dimensions exceeded ({MAX_DIMENSIONS}): Unable to add dimension {name}.&#34;
            )
        # Cast value to str according to EMF spec
        # Majority of values are expected to be string already, so
        # checking before casting improves performance in most cases
        self.dimension_set[name] = value if isinstance(value, str) else str(value)

    def add_metadata(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Adds high cardinal metadata for metrics object

        This will not be available during metrics visualization.
        Instead, this will be searchable through logs.

        If you&#39;re looking to add metadata to filter metrics, then
        use add_dimensions method.

        Example
        -------
        **Add metrics metadata**

            metric.add_metadata(key=&#34;booking_id&#34;, value=&#34;booking_id&#34;)

        Parameters
        ----------
        key : str
            Metadata key
        value : any
            Metadata value
        &#34;&#34;&#34;
        logger.debug(f&#34;Adding metadata: {key}:{value}&#34;)

        # Cast key to str according to EMF spec
        # Majority of keys are expected to be string already, so
        # checking before casting improves performance in most cases
        if isinstance(key, str):
            self.metadata_set[key] = value
        else:
            self.metadata_set[str(key)] = value

    def clear_metrics(self) -&gt; None:
        logger.debug(&#34;Clearing out existing metric set from memory&#34;)
        self.metric_set.clear()
        self.dimension_set.clear()
        self.metadata_set.clear()

    def flush_metrics(self, raise_on_empty_metrics: bool = False) -&gt; None:
        &#34;&#34;&#34;Manually flushes the metrics. This is normally not necessary,
        unless you&#39;re running on other runtimes besides Lambda, where the @log_metrics
        decorator already handles things for you.

        Parameters
        ----------
        raise_on_empty_metrics : bool, optional
            raise exception if no metrics are emitted, by default False
        &#34;&#34;&#34;
        if not raise_on_empty_metrics and not self.metric_set:
            warnings.warn(
                &#34;No application metrics to publish. The cold-start metric may be published if enabled. &#34;
                &#34;If application metrics should never be empty, consider using &#39;raise_on_empty_metrics&#39;&#34;,
                stacklevel=2,
            )
        else:
            logger.debug(&#34;Flushing existing metrics&#34;)
            metrics = self.serialize_metric_set()
            print(json.dumps(metrics, separators=(&#34;,&#34;, &#34;:&#34;)))
            self.clear_metrics()

    def log_metrics(
        self,
        lambda_handler: Union[Callable[[Dict, Any], Any], Optional[Callable[[Dict, Any, Optional[Dict]], Any]]] = None,
        capture_cold_start_metric: bool = False,
        raise_on_empty_metrics: bool = False,
        default_dimensions: Optional[Dict[str, str]] = None,
    ):
        &#34;&#34;&#34;Decorator to serialize and publish metrics at the end of a function execution.

        Be aware that the log_metrics **does call* the decorated function (e.g. lambda_handler).

        Example
        -------
        **Lambda function using tracer and metrics decorators**

            from aws_lambda_powertools import Metrics, Tracer

            metrics = Metrics(service=&#34;payment&#34;)
            tracer = Tracer(service=&#34;payment&#34;)

            @tracer.capture_lambda_handler
            @metrics.log_metrics
            def handler(event, context):
                    ...

        Parameters
        ----------
        lambda_handler : Callable[[Any, Any], Any], optional
            lambda function handler, by default None
        capture_cold_start_metric : bool, optional
            captures cold start metric, by default False
        raise_on_empty_metrics : bool, optional
            raise exception if no metrics are emitted, by default False
        default_dimensions: Dict[str, str], optional
            metric dimensions as key=value that will always be present

        Raises
        ------
        e
            Propagate error received
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.log_metrics,
                capture_cold_start_metric=capture_cold_start_metric,
                raise_on_empty_metrics=raise_on_empty_metrics,
                default_dimensions=default_dimensions,
            )

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            try:
                if default_dimensions:
                    self.set_default_dimensions(**default_dimensions)
                response = lambda_handler(event, context)
                if capture_cold_start_metric:
                    self._add_cold_start_metric(context=context)
            finally:
                self.flush_metrics(raise_on_empty_metrics=raise_on_empty_metrics)

            return response

        return decorate

    def _extract_metric_resolution_value(self, resolution: Union[int, MetricResolution]) -&gt; int:
        &#34;&#34;&#34;Return metric value from metric unit whether that&#39;s str or MetricResolution enum

        Parameters
        ----------
        unit : Union[int, MetricResolution]
            Metric resolution

        Returns
        -------
        int
            Metric resolution value must be 1 or 60

        Raises
        ------
        MetricResolutionError
            When metric resolution is not supported by CloudWatch
        &#34;&#34;&#34;
        if isinstance(resolution, MetricResolution):
            return resolution.value

        if isinstance(resolution, int) and resolution in self._metric_resolutions:
            return resolution

        raise MetricResolutionError(
            f&#34;Invalid metric resolution &#39;{resolution}&#39;, expected either option: {self._metric_resolutions}&#34;  # noqa: E501
        )

    def _extract_metric_unit_value(self, unit: Union[str, MetricUnit]) -&gt; str:
        &#34;&#34;&#34;Return metric value from metric unit whether that&#39;s str or MetricUnit enum

        Parameters
        ----------
        unit : Union[str, MetricUnit]
            Metric unit

        Returns
        -------
        str
            Metric unit value (e.g. &#34;Seconds&#34;, &#34;Count/Second&#34;)

        Raises
        ------
        MetricUnitError
            When metric unit is not supported by CloudWatch
        &#34;&#34;&#34;

        if isinstance(unit, str):
            if unit in self._metric_unit_valid_options:
                unit = MetricUnit[unit].value

            if unit not in self._metric_units:
                raise MetricUnitError(
                    f&#34;Invalid metric unit &#39;{unit}&#39;, expected either option: {self._metric_unit_valid_options}&#34;
                )

        if isinstance(unit, MetricUnit):
            unit = unit.value

        return unit

    def _add_cold_start_metric(self, context: Any) -&gt; None:
        &#34;&#34;&#34;Add cold start metric and function_name dimension

        Parameters
        ----------
        context : Any
            Lambda context
        &#34;&#34;&#34;
        global is_cold_start
        if is_cold_start:
            logger.debug(&#34;Adding cold start metric and function_name dimension&#34;)
            with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, namespace=self.namespace) as metric:
                metric.add_dimension(name=&#34;function_name&#34;, value=context.function_name)
                if self.service:
                    metric.add_dimension(name=&#34;service&#34;, value=str(self.service))
                is_cold_start = False


class SingleMetric(MetricManager):
    &#34;&#34;&#34;SingleMetric creates an EMF object with a single metric.

    EMF specification doesn&#39;t allow metrics with different dimensions.
    SingleMetric overrides MetricManager&#39;s add_metric method to do just that.

    Use `single_metric` when you need to create metrics with different dimensions,
    otherwise `aws_lambda_powertools.metrics.metrics.Metrics` is
    a more cost effective option

    Environment variables
    ---------------------
    POWERTOOLS_METRICS_NAMESPACE : str
        metric namespace

    Example
    -------
    **Creates cold start metric with function_version as dimension**

        import json
        from aws_lambda_powertools.metrics import single_metric, MetricUnit, MetricResolution
        metric = single_metric(namespace=&#34;ServerlessAirline&#34;)

        metric.add_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard)
        metric.add_dimension(name=&#34;function_version&#34;, value=47)

        print(json.dumps(metric.serialize_metric_set(), indent=4))

    Parameters
    ----------
    MetricManager : MetricManager
        Inherits from `aws_lambda_powertools.metrics.base.MetricManager`
    &#34;&#34;&#34;

    def add_metric(
        self,
        name: str,
        unit: Union[MetricUnit, str],
        value: float,
        resolution: Union[MetricResolution, int] = 60,
    ) -&gt; None:
        &#34;&#34;&#34;Method to prevent more than one metric being created

        Parameters
        ----------
        name : str
            Metric name (e.g. BookingConfirmation)
        unit : MetricUnit
            Metric unit (e.g. &#34;Seconds&#34;, MetricUnit.Seconds)
        value : float
            Metric value
        resolution : MetricResolution
            Metric resolution (e.g. 60, MetricResolution.Standard)
        &#34;&#34;&#34;
        if len(self.metric_set) &gt; 0:
            logger.debug(f&#34;Metric {name} already set, skipping...&#34;)
            return
        return super().add_metric(name, unit, value, resolution)


@contextmanager
def single_metric(
    name: str,
    unit: MetricUnit,
    value: float,
    resolution: Union[MetricResolution, int] = 60,
    namespace: Optional[str] = None,
    default_dimensions: Optional[Dict[str, str]] = None,
) -&gt; Generator[SingleMetric, None, None]:
    &#34;&#34;&#34;Context manager to simplify creation of a single metric

    Example
    -------
    **Creates cold start metric with function_version as dimension**

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard, namespace=&#34;ServerlessAirline&#34;) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    **Same as above but set namespace using environment variable**

        $ export POWERTOOLS_METRICS_NAMESPACE=&#34;ServerlessAirline&#34;

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    Parameters
    ----------
    name : str
        Metric name
    unit : MetricUnit
        `aws_lambda_powertools.helper.models.MetricUnit`
    resolution : MetricResolution
        `aws_lambda_powertools.helper.models.MetricResolution`
    value : float
        Metric value
    namespace: str
        Namespace for metrics

    Yields
    -------
    SingleMetric
        SingleMetric class instance

    Raises
    ------
    MetricUnitError
        When metric metric isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;
    metric_set: Optional[Dict] = None
    try:
        metric: SingleMetric = SingleMetric(namespace=namespace)
        metric.add_metric(name=name, unit=unit, value=value, resolution=resolution)

        if default_dimensions:
            for dim_name, dim_value in default_dimensions.items():
                metric.add_dimension(name=dim_name, value=dim_value)

        yield metric
        metric_set = metric.serialize_metric_set()
    finally:
        print(json.dumps(metric_set, separators=(&#34;,&#34;, &#34;:&#34;)))


def reset_cold_start_flag():
    global is_cold_start
    if not is_cold_start:
        is_cold_start = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.metrics.base.reset_cold_start_flag"><code class="name flex">
<span>def <span class="ident">reset_cold_start_flag</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_cold_start_flag():
    global is_cold_start
    if not is_cold_start:
        is_cold_start = True</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.single_metric"><code class="name flex">
<span>def <span class="ident">single_metric</span></span>(<span>name: str, unit: <a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a>, value: float, resolution: Union[<a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a>, int] = 60, namespace: Optional[str] = None, default_dimensions: Optional[Dict[str, str]] = None) ‑> Generator[<a title="aws_lambda_powertools.metrics.base.SingleMetric" href="#aws_lambda_powertools.metrics.base.SingleMetric">SingleMetric</a>, None, None]</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager to simplify creation of a single metric</p>
<h2 id="example">Example</h2>
<p><strong>Creates cold start metric with function_version as dimension</strong></p>
<pre><code>from aws_lambda_powertools import single_metric
from aws_lambda_powertools.metrics import MetricUnit
from aws_lambda_powertools.metrics import MetricResolution

with single_metric(name="ColdStart", unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard, namespace="ServerlessAirline") as metric: # noqa E501
    metric.add_dimension(name="function_version", value="47")
</code></pre>
<p><strong>Same as above but set namespace using environment variable</strong></p>
<pre><code>$ export POWERTOOLS_METRICS_NAMESPACE="ServerlessAirline"

from aws_lambda_powertools import single_metric
from aws_lambda_powertools.metrics import MetricUnit
from aws_lambda_powertools.metrics import MetricResolution

with single_metric(name="ColdStart", unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard) as metric: # noqa E501
    metric.add_dimension(name="function_version", value="47")
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Metric name</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a></code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricUnit</code></dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code><a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a></code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricResolution</code></dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Metric value</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code></dt>
<dd>Namespace for metrics</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="aws_lambda_powertools.metrics.base.SingleMetric" href="#aws_lambda_powertools.metrics.base.SingleMetric">SingleMetric</a></code></dt>
<dd>SingleMetric class instance</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MetricUnitError</code></dt>
<dd>When metric metric isn't supported by CloudWatch</dd>
<dt><code>MetricResolutionError</code></dt>
<dd>When metric resolution isn't supported by CloudWatch</dd>
<dt><code>MetricValueError</code></dt>
<dd>When metric value isn't a number</dd>
<dt><code>SchemaValidationError</code></dt>
<dd>When metric object fails EMF schema validation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def single_metric(
    name: str,
    unit: MetricUnit,
    value: float,
    resolution: Union[MetricResolution, int] = 60,
    namespace: Optional[str] = None,
    default_dimensions: Optional[Dict[str, str]] = None,
) -&gt; Generator[SingleMetric, None, None]:
    &#34;&#34;&#34;Context manager to simplify creation of a single metric

    Example
    -------
    **Creates cold start metric with function_version as dimension**

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard, namespace=&#34;ServerlessAirline&#34;) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    **Same as above but set namespace using environment variable**

        $ export POWERTOOLS_METRICS_NAMESPACE=&#34;ServerlessAirline&#34;

        from aws_lambda_powertools import single_metric
        from aws_lambda_powertools.metrics import MetricUnit
        from aws_lambda_powertools.metrics import MetricResolution

        with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard) as metric: # noqa E501
            metric.add_dimension(name=&#34;function_version&#34;, value=&#34;47&#34;)

    Parameters
    ----------
    name : str
        Metric name
    unit : MetricUnit
        `aws_lambda_powertools.helper.models.MetricUnit`
    resolution : MetricResolution
        `aws_lambda_powertools.helper.models.MetricResolution`
    value : float
        Metric value
    namespace: str
        Namespace for metrics

    Yields
    -------
    SingleMetric
        SingleMetric class instance

    Raises
    ------
    MetricUnitError
        When metric metric isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;
    metric_set: Optional[Dict] = None
    try:
        metric: SingleMetric = SingleMetric(namespace=namespace)
        metric.add_metric(name=name, unit=unit, value=value, resolution=resolution)

        if default_dimensions:
            for dim_name, dim_value in default_dimensions.items():
                metric.add_dimension(name=dim_name, value=dim_value)

        yield metric
        metric_set = metric.serialize_metric_set()
    finally:
        print(json.dumps(metric_set, separators=(&#34;,&#34;, &#34;:&#34;)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.metrics.base.MetricManager"><code class="flex name class">
<span>class <span class="ident">MetricManager</span></span>
<span>(</span><span>metric_set: Optional[Dict[str, Any]] = None, dimension_set: Optional[Dict] = None, namespace: Optional[str] = None, metadata_set: Optional[Dict[str, Any]] = None, service: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for metric functionality (namespace, metric, dimension, serialization)</p>
<p>MetricManager creates metrics asynchronously thanks to CloudWatch Embedded Metric Format (EMF).
CloudWatch EMF can create up to 100 metrics per EMF object
and metrics, dimensions, and namespace created via MetricManager
will adhere to the schema, will be serialized and validated against EMF Schema.</p>
<p><strong>Use <code><a title="aws_lambda_powertools.metrics.metrics.Metrics" href="metrics.html#aws_lambda_powertools.metrics.metrics.Metrics">Metrics</a></code> or
<code><a title="aws_lambda_powertools.metrics.metric.single_metric" href="metric.html#aws_lambda_powertools.metrics.metric.single_metric">single_metric()</a></code> to create EMF metrics.</strong></p>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_METRICS_NAMESPACE : str
metric namespace to be set for all metrics
POWERTOOLS_SERVICE_NAME : str
service name used for default dimension</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MetricUnitError</code></dt>
<dd>When metric unit isn't supported by CloudWatch</dd>
<dt><code>MetricResolutionError</code></dt>
<dd>When metric resolution isn't supported by CloudWatch</dd>
<dt><code>MetricValueError</code></dt>
<dd>When metric value isn't a number</dd>
<dt><code>SchemaValidationError</code></dt>
<dd>When metric object fails EMF schema validation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricManager:
    &#34;&#34;&#34;Base class for metric functionality (namespace, metric, dimension, serialization)

    MetricManager creates metrics asynchronously thanks to CloudWatch Embedded Metric Format (EMF).
    CloudWatch EMF can create up to 100 metrics per EMF object
    and metrics, dimensions, and namespace created via MetricManager
    will adhere to the schema, will be serialized and validated against EMF Schema.

    **Use `aws_lambda_powertools.metrics.metrics.Metrics` or
    `aws_lambda_powertools.metrics.metric.single_metric` to create EMF metrics.**

    Environment variables
    ---------------------
    POWERTOOLS_METRICS_NAMESPACE : str
        metric namespace to be set for all metrics
    POWERTOOLS_SERVICE_NAME : str
        service name used for default dimension

    Raises
    ------
    MetricUnitError
        When metric unit isn&#39;t supported by CloudWatch
    MetricResolutionError
        When metric resolution isn&#39;t supported by CloudWatch
    MetricValueError
        When metric value isn&#39;t a number
    SchemaValidationError
        When metric object fails EMF schema validation
    &#34;&#34;&#34;

    def __init__(
        self,
        metric_set: Optional[Dict[str, Any]] = None,
        dimension_set: Optional[Dict] = None,
        namespace: Optional[str] = None,
        metadata_set: Optional[Dict[str, Any]] = None,
        service: Optional[str] = None,
    ):
        self.metric_set = metric_set if metric_set is not None else {}
        self.dimension_set = dimension_set if dimension_set is not None else {}
        self.namespace = resolve_env_var_choice(choice=namespace, env=os.getenv(constants.METRICS_NAMESPACE_ENV))
        self.service = resolve_env_var_choice(choice=service, env=os.getenv(constants.SERVICE_NAME_ENV))
        self.metadata_set = metadata_set if metadata_set is not None else {}
        self._metric_units = [unit.value for unit in MetricUnit]
        self._metric_unit_valid_options = list(MetricUnit.__members__)
        self._metric_resolutions = [resolution.value for resolution in MetricResolution]

    def add_metric(
        self,
        name: str,
        unit: Union[MetricUnit, str],
        value: float,
        resolution: Union[MetricResolution, int] = 60,
    ) -&gt; None:
        &#34;&#34;&#34;Adds given metric

        Example
        -------
        **Add given metric using MetricUnit enum**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=MetricUnit.Count, value=1)

        **Add given metric using plain string as value unit**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1)

        **Add given metric with MetricResolution non default value**

            metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1, resolution=MetricResolution.High)

        Parameters
        ----------
        name : str
            Metric name
        unit : Union[MetricUnit, str]
            `aws_lambda_powertools.helper.models.MetricUnit`
        value : float
            Metric value
        resolution : Union[MetricResolution, int]
            `aws_lambda_powertools.helper.models.MetricResolution`

        Raises
        ------
        MetricUnitError
            When metric unit is not supported by CloudWatch
        MetricResolutionError
            When metric resolution is not supported by CloudWatch
        &#34;&#34;&#34;
        if not isinstance(value, numbers.Number):
            raise MetricValueError(f&#34;{value} is not a valid number&#34;)

        unit = self._extract_metric_unit_value(unit=unit)
        resolution = self._extract_metric_resolution_value(resolution=resolution)
        metric: Dict = self.metric_set.get(name, defaultdict(list))
        metric[&#34;Unit&#34;] = unit
        metric[&#34;StorageResolution&#34;] = resolution
        metric[&#34;Value&#34;].append(float(value))
        logger.debug(f&#34;Adding metric: {name} with {metric}&#34;)
        self.metric_set[name] = metric

        if len(self.metric_set) == MAX_METRICS or len(metric[&#34;Value&#34;]) == MAX_METRICS:
            logger.debug(f&#34;Exceeded maximum of {MAX_METRICS} metrics - Publishing existing metric set&#34;)
            metrics = self.serialize_metric_set()
            print(json.dumps(metrics))

            # clear metric set only as opposed to metrics and dimensions set
            # since we could have more than 100 metrics
            self.metric_set.clear()

    def serialize_metric_set(
        self, metrics: Optional[Dict] = None, dimensions: Optional[Dict] = None, metadata: Optional[Dict] = None
    ) -&gt; Dict:
        &#34;&#34;&#34;Serializes metric and dimensions set

        Parameters
        ----------
        metrics : Dict, optional
            Dictionary of metrics to serialize, by default None
        dimensions : Dict, optional
            Dictionary of dimensions to serialize, by default None
        metadata: Dict, optional
            Dictionary of metadata to serialize, by default None

        Example
        -------
        **Serialize metrics into EMF format**

            metrics = MetricManager()
            # ...add metrics, dimensions, namespace
            ret = metrics.serialize_metric_set()

        Returns
        -------
        Dict
            Serialized metrics following EMF specification

        Raises
        ------
        SchemaValidationError
            Raised when serialization fail schema validation
        &#34;&#34;&#34;
        if metrics is None:  # pragma: no cover
            metrics = self.metric_set

        if dimensions is None:  # pragma: no cover
            dimensions = self.dimension_set

        if metadata is None:  # pragma: no cover
            metadata = self.metadata_set

        if self.service and not self.dimension_set.get(&#34;service&#34;):
            # self.service won&#39;t be a float
            self.add_dimension(name=&#34;service&#34;, value=self.service)

        if len(metrics) == 0:
            raise SchemaValidationError(&#34;Must contain at least one metric.&#34;)

        if self.namespace is None:
            raise SchemaValidationError(&#34;Must contain a metric namespace.&#34;)

        logger.debug({&#34;details&#34;: &#34;Serializing metrics&#34;, &#34;metrics&#34;: metrics, &#34;dimensions&#34;: dimensions})

        # For standard resolution metrics, don&#39;t add StorageResolution field to avoid unnecessary ingestion of data into cloudwatch # noqa E501
        # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;} ] # noqa E800
        #
        # In case using high-resolution metrics, add StorageResolution field
        # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;, &#34;StorageResolution&#34;: 1 } ] # noqa E800
        metric_definition: List[MetricNameUnitResolution] = []
        metric_names_and_values: Dict[str, float] = {}  # { &#34;metric_name&#34;: 1.0 }

        for metric_name in metrics:
            metric: dict = metrics[metric_name]
            metric_value: int = metric.get(&#34;Value&#34;, 0)
            metric_unit: str = metric.get(&#34;Unit&#34;, &#34;&#34;)
            metric_resolution: int = metric.get(&#34;StorageResolution&#34;, 60)

            metric_definition_data: MetricNameUnitResolution = {&#34;Name&#34;: metric_name, &#34;Unit&#34;: metric_unit}

            # high-resolution metrics
            if metric_resolution == 1:
                metric_definition_data[&#34;StorageResolution&#34;] = metric_resolution

            metric_definition.append(metric_definition_data)

            metric_names_and_values.update({metric_name: metric_value})

        return {
            &#34;_aws&#34;: {
                &#34;Timestamp&#34;: int(datetime.datetime.now().timestamp() * 1000),  # epoch
                &#34;CloudWatchMetrics&#34;: [
                    {
                        &#34;Namespace&#34;: self.namespace,  # &#34;test_namespace&#34;
                        &#34;Dimensions&#34;: [list(dimensions.keys())],  # [ &#34;service&#34; ]
                        &#34;Metrics&#34;: metric_definition,
                    }
                ],
            },
            **dimensions,  # &#34;service&#34;: &#34;test_service&#34;
            **metadata,  # &#34;username&#34;: &#34;test&#34;
            **metric_names_and_values,  # &#34;single_metric&#34;: 1.0
        }

    def add_dimension(self, name: str, value: str) -&gt; None:
        &#34;&#34;&#34;Adds given dimension to all metrics

        Example
        -------
        **Add a metric dimensions**

            metric.add_dimension(name=&#34;operation&#34;, value=&#34;confirm_booking&#34;)

        Parameters
        ----------
        name : str
            Dimension name
        value : str
            Dimension value
        &#34;&#34;&#34;
        logger.debug(f&#34;Adding dimension: {name}:{value}&#34;)
        if len(self.dimension_set) == MAX_DIMENSIONS:
            raise SchemaValidationError(
                f&#34;Maximum number of dimensions exceeded ({MAX_DIMENSIONS}): Unable to add dimension {name}.&#34;
            )
        # Cast value to str according to EMF spec
        # Majority of values are expected to be string already, so
        # checking before casting improves performance in most cases
        self.dimension_set[name] = value if isinstance(value, str) else str(value)

    def add_metadata(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Adds high cardinal metadata for metrics object

        This will not be available during metrics visualization.
        Instead, this will be searchable through logs.

        If you&#39;re looking to add metadata to filter metrics, then
        use add_dimensions method.

        Example
        -------
        **Add metrics metadata**

            metric.add_metadata(key=&#34;booking_id&#34;, value=&#34;booking_id&#34;)

        Parameters
        ----------
        key : str
            Metadata key
        value : any
            Metadata value
        &#34;&#34;&#34;
        logger.debug(f&#34;Adding metadata: {key}:{value}&#34;)

        # Cast key to str according to EMF spec
        # Majority of keys are expected to be string already, so
        # checking before casting improves performance in most cases
        if isinstance(key, str):
            self.metadata_set[key] = value
        else:
            self.metadata_set[str(key)] = value

    def clear_metrics(self) -&gt; None:
        logger.debug(&#34;Clearing out existing metric set from memory&#34;)
        self.metric_set.clear()
        self.dimension_set.clear()
        self.metadata_set.clear()

    def flush_metrics(self, raise_on_empty_metrics: bool = False) -&gt; None:
        &#34;&#34;&#34;Manually flushes the metrics. This is normally not necessary,
        unless you&#39;re running on other runtimes besides Lambda, where the @log_metrics
        decorator already handles things for you.

        Parameters
        ----------
        raise_on_empty_metrics : bool, optional
            raise exception if no metrics are emitted, by default False
        &#34;&#34;&#34;
        if not raise_on_empty_metrics and not self.metric_set:
            warnings.warn(
                &#34;No application metrics to publish. The cold-start metric may be published if enabled. &#34;
                &#34;If application metrics should never be empty, consider using &#39;raise_on_empty_metrics&#39;&#34;,
                stacklevel=2,
            )
        else:
            logger.debug(&#34;Flushing existing metrics&#34;)
            metrics = self.serialize_metric_set()
            print(json.dumps(metrics, separators=(&#34;,&#34;, &#34;:&#34;)))
            self.clear_metrics()

    def log_metrics(
        self,
        lambda_handler: Union[Callable[[Dict, Any], Any], Optional[Callable[[Dict, Any, Optional[Dict]], Any]]] = None,
        capture_cold_start_metric: bool = False,
        raise_on_empty_metrics: bool = False,
        default_dimensions: Optional[Dict[str, str]] = None,
    ):
        &#34;&#34;&#34;Decorator to serialize and publish metrics at the end of a function execution.

        Be aware that the log_metrics **does call* the decorated function (e.g. lambda_handler).

        Example
        -------
        **Lambda function using tracer and metrics decorators**

            from aws_lambda_powertools import Metrics, Tracer

            metrics = Metrics(service=&#34;payment&#34;)
            tracer = Tracer(service=&#34;payment&#34;)

            @tracer.capture_lambda_handler
            @metrics.log_metrics
            def handler(event, context):
                    ...

        Parameters
        ----------
        lambda_handler : Callable[[Any, Any], Any], optional
            lambda function handler, by default None
        capture_cold_start_metric : bool, optional
            captures cold start metric, by default False
        raise_on_empty_metrics : bool, optional
            raise exception if no metrics are emitted, by default False
        default_dimensions: Dict[str, str], optional
            metric dimensions as key=value that will always be present

        Raises
        ------
        e
            Propagate error received
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.log_metrics,
                capture_cold_start_metric=capture_cold_start_metric,
                raise_on_empty_metrics=raise_on_empty_metrics,
                default_dimensions=default_dimensions,
            )

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            try:
                if default_dimensions:
                    self.set_default_dimensions(**default_dimensions)
                response = lambda_handler(event, context)
                if capture_cold_start_metric:
                    self._add_cold_start_metric(context=context)
            finally:
                self.flush_metrics(raise_on_empty_metrics=raise_on_empty_metrics)

            return response

        return decorate

    def _extract_metric_resolution_value(self, resolution: Union[int, MetricResolution]) -&gt; int:
        &#34;&#34;&#34;Return metric value from metric unit whether that&#39;s str or MetricResolution enum

        Parameters
        ----------
        unit : Union[int, MetricResolution]
            Metric resolution

        Returns
        -------
        int
            Metric resolution value must be 1 or 60

        Raises
        ------
        MetricResolutionError
            When metric resolution is not supported by CloudWatch
        &#34;&#34;&#34;
        if isinstance(resolution, MetricResolution):
            return resolution.value

        if isinstance(resolution, int) and resolution in self._metric_resolutions:
            return resolution

        raise MetricResolutionError(
            f&#34;Invalid metric resolution &#39;{resolution}&#39;, expected either option: {self._metric_resolutions}&#34;  # noqa: E501
        )

    def _extract_metric_unit_value(self, unit: Union[str, MetricUnit]) -&gt; str:
        &#34;&#34;&#34;Return metric value from metric unit whether that&#39;s str or MetricUnit enum

        Parameters
        ----------
        unit : Union[str, MetricUnit]
            Metric unit

        Returns
        -------
        str
            Metric unit value (e.g. &#34;Seconds&#34;, &#34;Count/Second&#34;)

        Raises
        ------
        MetricUnitError
            When metric unit is not supported by CloudWatch
        &#34;&#34;&#34;

        if isinstance(unit, str):
            if unit in self._metric_unit_valid_options:
                unit = MetricUnit[unit].value

            if unit not in self._metric_units:
                raise MetricUnitError(
                    f&#34;Invalid metric unit &#39;{unit}&#39;, expected either option: {self._metric_unit_valid_options}&#34;
                )

        if isinstance(unit, MetricUnit):
            unit = unit.value

        return unit

    def _add_cold_start_metric(self, context: Any) -&gt; None:
        &#34;&#34;&#34;Add cold start metric and function_name dimension

        Parameters
        ----------
        context : Any
            Lambda context
        &#34;&#34;&#34;
        global is_cold_start
        if is_cold_start:
            logger.debug(&#34;Adding cold start metric and function_name dimension&#34;)
            with single_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, namespace=self.namespace) as metric:
                metric.add_dimension(name=&#34;function_name&#34;, value=context.function_name)
                if self.service:
                    metric.add_dimension(name=&#34;service&#34;, value=str(self.service))
                is_cold_start = False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.metrics.base.SingleMetric" href="#aws_lambda_powertools.metrics.base.SingleMetric">SingleMetric</a></li>
<li><a title="aws_lambda_powertools.metrics.metrics.EphemeralMetrics" href="metrics.html#aws_lambda_powertools.metrics.metrics.EphemeralMetrics">EphemeralMetrics</a></li>
<li><a title="aws_lambda_powertools.metrics.metrics.Metrics" href="metrics.html#aws_lambda_powertools.metrics.metrics.Metrics">Metrics</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.add_dimension"><code class="name flex">
<span>def <span class="ident">add_dimension</span></span>(<span>self, name: str, value: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds given dimension to all metrics</p>
<h2 id="example">Example</h2>
<p><strong>Add a metric dimensions</strong></p>
<pre><code>metric.add_dimension(name="operation", value="confirm_booking")
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Dimension name</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Dimension value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dimension(self, name: str, value: str) -&gt; None:
    &#34;&#34;&#34;Adds given dimension to all metrics

    Example
    -------
    **Add a metric dimensions**

        metric.add_dimension(name=&#34;operation&#34;, value=&#34;confirm_booking&#34;)

    Parameters
    ----------
    name : str
        Dimension name
    value : str
        Dimension value
    &#34;&#34;&#34;
    logger.debug(f&#34;Adding dimension: {name}:{value}&#34;)
    if len(self.dimension_set) == MAX_DIMENSIONS:
        raise SchemaValidationError(
            f&#34;Maximum number of dimensions exceeded ({MAX_DIMENSIONS}): Unable to add dimension {name}.&#34;
        )
    # Cast value to str according to EMF spec
    # Majority of values are expected to be string already, so
    # checking before casting improves performance in most cases
    self.dimension_set[name] = value if isinstance(value, str) else str(value)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.add_metadata"><code class="name flex">
<span>def <span class="ident">add_metadata</span></span>(<span>self, key: str, value: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds high cardinal metadata for metrics object</p>
<p>This will not be available during metrics visualization.
Instead, this will be searchable through logs.</p>
<p>If you're looking to add metadata to filter metrics, then
use add_dimensions method.</p>
<h2 id="example">Example</h2>
<p><strong>Add metrics metadata</strong></p>
<pre><code>metric.add_metadata(key="booking_id", value="booking_id")
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Metadata key</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>any</code></dt>
<dd>Metadata value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metadata(self, key: str, value: Any) -&gt; None:
    &#34;&#34;&#34;Adds high cardinal metadata for metrics object

    This will not be available during metrics visualization.
    Instead, this will be searchable through logs.

    If you&#39;re looking to add metadata to filter metrics, then
    use add_dimensions method.

    Example
    -------
    **Add metrics metadata**

        metric.add_metadata(key=&#34;booking_id&#34;, value=&#34;booking_id&#34;)

    Parameters
    ----------
    key : str
        Metadata key
    value : any
        Metadata value
    &#34;&#34;&#34;
    logger.debug(f&#34;Adding metadata: {key}:{value}&#34;)

    # Cast key to str according to EMF spec
    # Majority of keys are expected to be string already, so
    # checking before casting improves performance in most cases
    if isinstance(key, str):
        self.metadata_set[key] = value
    else:
        self.metadata_set[str(key)] = value</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self, name: str, unit: Union[<a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a>, str], value: float, resolution: Union[<a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a>, int] = 60) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds given metric</p>
<h2 id="example">Example</h2>
<p><strong>Add given metric using MetricUnit enum</strong></p>
<pre><code>metric.add_metric(name="BookingConfirmation", unit=MetricUnit.Count, value=1)
</code></pre>
<p><strong>Add given metric using plain string as value unit</strong></p>
<pre><code>metric.add_metric(name="BookingConfirmation", unit="Count", value=1)
</code></pre>
<p><strong>Add given metric with MetricResolution non default value</strong></p>
<pre><code>metric.add_metric(name="BookingConfirmation", unit="Count", value=1, resolution=MetricResolution.High)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Metric name</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>Union[<a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a>, str]</code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricUnit</code></dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Metric value</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>Union[<a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a>, int]</code></dt>
<dd><code>aws_lambda_powertools.helper.models.MetricResolution</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MetricUnitError</code></dt>
<dd>When metric unit is not supported by CloudWatch</dd>
<dt><code>MetricResolutionError</code></dt>
<dd>When metric resolution is not supported by CloudWatch</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(
    self,
    name: str,
    unit: Union[MetricUnit, str],
    value: float,
    resolution: Union[MetricResolution, int] = 60,
) -&gt; None:
    &#34;&#34;&#34;Adds given metric

    Example
    -------
    **Add given metric using MetricUnit enum**

        metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=MetricUnit.Count, value=1)

    **Add given metric using plain string as value unit**

        metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1)

    **Add given metric with MetricResolution non default value**

        metric.add_metric(name=&#34;BookingConfirmation&#34;, unit=&#34;Count&#34;, value=1, resolution=MetricResolution.High)

    Parameters
    ----------
    name : str
        Metric name
    unit : Union[MetricUnit, str]
        `aws_lambda_powertools.helper.models.MetricUnit`
    value : float
        Metric value
    resolution : Union[MetricResolution, int]
        `aws_lambda_powertools.helper.models.MetricResolution`

    Raises
    ------
    MetricUnitError
        When metric unit is not supported by CloudWatch
    MetricResolutionError
        When metric resolution is not supported by CloudWatch
    &#34;&#34;&#34;
    if not isinstance(value, numbers.Number):
        raise MetricValueError(f&#34;{value} is not a valid number&#34;)

    unit = self._extract_metric_unit_value(unit=unit)
    resolution = self._extract_metric_resolution_value(resolution=resolution)
    metric: Dict = self.metric_set.get(name, defaultdict(list))
    metric[&#34;Unit&#34;] = unit
    metric[&#34;StorageResolution&#34;] = resolution
    metric[&#34;Value&#34;].append(float(value))
    logger.debug(f&#34;Adding metric: {name} with {metric}&#34;)
    self.metric_set[name] = metric

    if len(self.metric_set) == MAX_METRICS or len(metric[&#34;Value&#34;]) == MAX_METRICS:
        logger.debug(f&#34;Exceeded maximum of {MAX_METRICS} metrics - Publishing existing metric set&#34;)
        metrics = self.serialize_metric_set()
        print(json.dumps(metrics))

        # clear metric set only as opposed to metrics and dimensions set
        # since we could have more than 100 metrics
        self.metric_set.clear()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.clear_metrics"><code class="name flex">
<span>def <span class="ident">clear_metrics</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_metrics(self) -&gt; None:
    logger.debug(&#34;Clearing out existing metric set from memory&#34;)
    self.metric_set.clear()
    self.dimension_set.clear()
    self.metadata_set.clear()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.flush_metrics"><code class="name flex">
<span>def <span class="ident">flush_metrics</span></span>(<span>self, raise_on_empty_metrics: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Manually flushes the metrics. This is normally not necessary,
unless you're running on other runtimes besides Lambda, where the @log_metrics
decorator already handles things for you.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>raise_on_empty_metrics</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>raise exception if no metrics are emitted, by default False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_metrics(self, raise_on_empty_metrics: bool = False) -&gt; None:
    &#34;&#34;&#34;Manually flushes the metrics. This is normally not necessary,
    unless you&#39;re running on other runtimes besides Lambda, where the @log_metrics
    decorator already handles things for you.

    Parameters
    ----------
    raise_on_empty_metrics : bool, optional
        raise exception if no metrics are emitted, by default False
    &#34;&#34;&#34;
    if not raise_on_empty_metrics and not self.metric_set:
        warnings.warn(
            &#34;No application metrics to publish. The cold-start metric may be published if enabled. &#34;
            &#34;If application metrics should never be empty, consider using &#39;raise_on_empty_metrics&#39;&#34;,
            stacklevel=2,
        )
    else:
        logger.debug(&#34;Flushing existing metrics&#34;)
        metrics = self.serialize_metric_set()
        print(json.dumps(metrics, separators=(&#34;,&#34;, &#34;:&#34;)))
        self.clear_metrics()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.log_metrics"><code class="name flex">
<span>def <span class="ident">log_metrics</span></span>(<span>self, lambda_handler: Union[Callable[[Dict, Any], Any], Callable[[Dict, Any, Optional[Dict]], Any], ForwardRef(None)] = None, capture_cold_start_metric: bool = False, raise_on_empty_metrics: bool = False, default_dimensions: Optional[Dict[str, str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to serialize and publish metrics at the end of a function execution.</p>
<p>Be aware that the log_metrics *<em>does call</em> the decorated function (e.g. lambda_handler).</p>
<h2 id="example">Example</h2>
<p><strong>Lambda function using tracer and metrics decorators</strong></p>
<pre><code>from aws_lambda_powertools import Metrics, Tracer

metrics = Metrics(service="payment")
tracer = Tracer(service="payment")

@tracer.capture_lambda_handler
@metrics.log_metrics
def handler(event, context):
        ...
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lambda_handler</code></strong> :&ensp;<code>Callable[[Any, Any], Any]</code>, optional</dt>
<dd>lambda function handler, by default None</dd>
<dt><strong><code>capture_cold_start_metric</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>captures cold start metric, by default False</dd>
<dt><strong><code>raise_on_empty_metrics</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>raise exception if no metrics are emitted, by default False</dd>
<dt><strong><code>default_dimensions</code></strong> :&ensp;<code>Dict[str, str]</code>, optional</dt>
<dd>metric dimensions as key=value that will always be present</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>e</code></dt>
<dd>Propagate error received</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_metrics(
    self,
    lambda_handler: Union[Callable[[Dict, Any], Any], Optional[Callable[[Dict, Any, Optional[Dict]], Any]]] = None,
    capture_cold_start_metric: bool = False,
    raise_on_empty_metrics: bool = False,
    default_dimensions: Optional[Dict[str, str]] = None,
):
    &#34;&#34;&#34;Decorator to serialize and publish metrics at the end of a function execution.

    Be aware that the log_metrics **does call* the decorated function (e.g. lambda_handler).

    Example
    -------
    **Lambda function using tracer and metrics decorators**

        from aws_lambda_powertools import Metrics, Tracer

        metrics = Metrics(service=&#34;payment&#34;)
        tracer = Tracer(service=&#34;payment&#34;)

        @tracer.capture_lambda_handler
        @metrics.log_metrics
        def handler(event, context):
                ...

    Parameters
    ----------
    lambda_handler : Callable[[Any, Any], Any], optional
        lambda function handler, by default None
    capture_cold_start_metric : bool, optional
        captures cold start metric, by default False
    raise_on_empty_metrics : bool, optional
        raise exception if no metrics are emitted, by default False
    default_dimensions: Dict[str, str], optional
        metric dimensions as key=value that will always be present

    Raises
    ------
    e
        Propagate error received
    &#34;&#34;&#34;

    # If handler is None we&#39;ve been called with parameters
    # Return a partial function with args filled
    if lambda_handler is None:
        logger.debug(&#34;Decorator called with parameters&#34;)
        return functools.partial(
            self.log_metrics,
            capture_cold_start_metric=capture_cold_start_metric,
            raise_on_empty_metrics=raise_on_empty_metrics,
            default_dimensions=default_dimensions,
        )

    @functools.wraps(lambda_handler)
    def decorate(event, context):
        try:
            if default_dimensions:
                self.set_default_dimensions(**default_dimensions)
            response = lambda_handler(event, context)
            if capture_cold_start_metric:
                self._add_cold_start_metric(context=context)
        finally:
            self.flush_metrics(raise_on_empty_metrics=raise_on_empty_metrics)

        return response

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set"><code class="name flex">
<span>def <span class="ident">serialize_metric_set</span></span>(<span>self, metrics: Optional[Dict] = None, dimensions: Optional[Dict] = None, metadata: Optional[Dict] = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Serializes metric and dimensions set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metrics</code></strong> :&ensp;<code>Dict</code>, optional</dt>
<dd>Dictionary of metrics to serialize, by default None</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>Dict</code>, optional</dt>
<dd>Dictionary of dimensions to serialize, by default None</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Dict</code>, optional</dt>
<dd>Dictionary of metadata to serialize, by default None</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Serialize metrics into EMF format</strong></p>
<pre><code>metrics = MetricManager()
# ...add metrics, dimensions, namespace
ret = metrics.serialize_metric_set()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>Serialized metrics following EMF specification</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SchemaValidationError</code></dt>
<dd>Raised when serialization fail schema validation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_metric_set(
    self, metrics: Optional[Dict] = None, dimensions: Optional[Dict] = None, metadata: Optional[Dict] = None
) -&gt; Dict:
    &#34;&#34;&#34;Serializes metric and dimensions set

    Parameters
    ----------
    metrics : Dict, optional
        Dictionary of metrics to serialize, by default None
    dimensions : Dict, optional
        Dictionary of dimensions to serialize, by default None
    metadata: Dict, optional
        Dictionary of metadata to serialize, by default None

    Example
    -------
    **Serialize metrics into EMF format**

        metrics = MetricManager()
        # ...add metrics, dimensions, namespace
        ret = metrics.serialize_metric_set()

    Returns
    -------
    Dict
        Serialized metrics following EMF specification

    Raises
    ------
    SchemaValidationError
        Raised when serialization fail schema validation
    &#34;&#34;&#34;
    if metrics is None:  # pragma: no cover
        metrics = self.metric_set

    if dimensions is None:  # pragma: no cover
        dimensions = self.dimension_set

    if metadata is None:  # pragma: no cover
        metadata = self.metadata_set

    if self.service and not self.dimension_set.get(&#34;service&#34;):
        # self.service won&#39;t be a float
        self.add_dimension(name=&#34;service&#34;, value=self.service)

    if len(metrics) == 0:
        raise SchemaValidationError(&#34;Must contain at least one metric.&#34;)

    if self.namespace is None:
        raise SchemaValidationError(&#34;Must contain a metric namespace.&#34;)

    logger.debug({&#34;details&#34;: &#34;Serializing metrics&#34;, &#34;metrics&#34;: metrics, &#34;dimensions&#34;: dimensions})

    # For standard resolution metrics, don&#39;t add StorageResolution field to avoid unnecessary ingestion of data into cloudwatch # noqa E501
    # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;} ] # noqa E800
    #
    # In case using high-resolution metrics, add StorageResolution field
    # Example: [ { &#34;Name&#34;: &#34;metric_name&#34;, &#34;Unit&#34;: &#34;Count&#34;, &#34;StorageResolution&#34;: 1 } ] # noqa E800
    metric_definition: List[MetricNameUnitResolution] = []
    metric_names_and_values: Dict[str, float] = {}  # { &#34;metric_name&#34;: 1.0 }

    for metric_name in metrics:
        metric: dict = metrics[metric_name]
        metric_value: int = metric.get(&#34;Value&#34;, 0)
        metric_unit: str = metric.get(&#34;Unit&#34;, &#34;&#34;)
        metric_resolution: int = metric.get(&#34;StorageResolution&#34;, 60)

        metric_definition_data: MetricNameUnitResolution = {&#34;Name&#34;: metric_name, &#34;Unit&#34;: metric_unit}

        # high-resolution metrics
        if metric_resolution == 1:
            metric_definition_data[&#34;StorageResolution&#34;] = metric_resolution

        metric_definition.append(metric_definition_data)

        metric_names_and_values.update({metric_name: metric_value})

    return {
        &#34;_aws&#34;: {
            &#34;Timestamp&#34;: int(datetime.datetime.now().timestamp() * 1000),  # epoch
            &#34;CloudWatchMetrics&#34;: [
                {
                    &#34;Namespace&#34;: self.namespace,  # &#34;test_namespace&#34;
                    &#34;Dimensions&#34;: [list(dimensions.keys())],  # [ &#34;service&#34; ]
                    &#34;Metrics&#34;: metric_definition,
                }
            ],
        },
        **dimensions,  # &#34;service&#34;: &#34;test_service&#34;
        **metadata,  # &#34;username&#34;: &#34;test&#34;
        **metric_names_and_values,  # &#34;single_metric&#34;: 1.0
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricResolution"><code class="flex name class">
<span>class <span class="ident">MetricResolution</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricResolution(Enum):
    Standard = 60
    High = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.metrics.base.MetricResolution.High"><code class="name">var <span class="ident">High</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricResolution.Standard"><code class="name">var <span class="ident">Standard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit"><code class="flex name class">
<span>class <span class="ident">MetricUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricUnit(Enum):
    Seconds = &#34;Seconds&#34;
    Microseconds = &#34;Microseconds&#34;
    Milliseconds = &#34;Milliseconds&#34;
    Bytes = &#34;Bytes&#34;
    Kilobytes = &#34;Kilobytes&#34;
    Megabytes = &#34;Megabytes&#34;
    Gigabytes = &#34;Gigabytes&#34;
    Terabytes = &#34;Terabytes&#34;
    Bits = &#34;Bits&#34;
    Kilobits = &#34;Kilobits&#34;
    Megabits = &#34;Megabits&#34;
    Gigabits = &#34;Gigabits&#34;
    Terabits = &#34;Terabits&#34;
    Percent = &#34;Percent&#34;
    Count = &#34;Count&#34;
    BytesPerSecond = &#34;Bytes/Second&#34;
    KilobytesPerSecond = &#34;Kilobytes/Second&#34;
    MegabytesPerSecond = &#34;Megabytes/Second&#34;
    GigabytesPerSecond = &#34;Gigabytes/Second&#34;
    TerabytesPerSecond = &#34;Terabytes/Second&#34;
    BitsPerSecond = &#34;Bits/Second&#34;
    KilobitsPerSecond = &#34;Kilobits/Second&#34;
    MegabitsPerSecond = &#34;Megabits/Second&#34;
    GigabitsPerSecond = &#34;Gigabits/Second&#34;
    TerabitsPerSecond = &#34;Terabits/Second&#34;
    CountPerSecond = &#34;Count/Second&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Bits"><code class="name">var <span class="ident">Bits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.BitsPerSecond"><code class="name">var <span class="ident">BitsPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Bytes"><code class="name">var <span class="ident">Bytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.BytesPerSecond"><code class="name">var <span class="ident">BytesPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Count"><code class="name">var <span class="ident">Count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.CountPerSecond"><code class="name">var <span class="ident">CountPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Gigabits"><code class="name">var <span class="ident">Gigabits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.GigabitsPerSecond"><code class="name">var <span class="ident">GigabitsPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Gigabytes"><code class="name">var <span class="ident">Gigabytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.GigabytesPerSecond"><code class="name">var <span class="ident">GigabytesPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Kilobits"><code class="name">var <span class="ident">Kilobits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.KilobitsPerSecond"><code class="name">var <span class="ident">KilobitsPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Kilobytes"><code class="name">var <span class="ident">Kilobytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.KilobytesPerSecond"><code class="name">var <span class="ident">KilobytesPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Megabits"><code class="name">var <span class="ident">Megabits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.MegabitsPerSecond"><code class="name">var <span class="ident">MegabitsPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Megabytes"><code class="name">var <span class="ident">Megabytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.MegabytesPerSecond"><code class="name">var <span class="ident">MegabytesPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Microseconds"><code class="name">var <span class="ident">Microseconds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Milliseconds"><code class="name">var <span class="ident">Milliseconds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Percent"><code class="name">var <span class="ident">Percent</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Seconds"><code class="name">var <span class="ident">Seconds</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Terabits"><code class="name">var <span class="ident">Terabits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.TerabitsPerSecond"><code class="name">var <span class="ident">TerabitsPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.Terabytes"><code class="name">var <span class="ident">Terabytes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.metrics.base.MetricUnit.TerabytesPerSecond"><code class="name">var <span class="ident">TerabytesPerSecond</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.metrics.base.SingleMetric"><code class="flex name class">
<span>class <span class="ident">SingleMetric</span></span>
<span>(</span><span>metric_set: Optional[Dict[str, Any]] = None, dimension_set: Optional[Dict] = None, namespace: Optional[str] = None, metadata_set: Optional[Dict[str, Any]] = None, service: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>SingleMetric creates an EMF object with a single metric.</p>
<p>EMF specification doesn't allow metrics with different dimensions.
SingleMetric overrides MetricManager's add_metric method to do just that.</p>
<p>Use <code><a title="aws_lambda_powertools.metrics.base.single_metric" href="#aws_lambda_powertools.metrics.base.single_metric">single_metric()</a></code> when you need to create metrics with different dimensions,
otherwise <code><a title="aws_lambda_powertools.metrics.metrics.Metrics" href="metrics.html#aws_lambda_powertools.metrics.metrics.Metrics">Metrics</a></code> is
a more cost effective option</p>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_METRICS_NAMESPACE : str
metric namespace</p>
<h2 id="example">Example</h2>
<p><strong>Creates cold start metric with function_version as dimension</strong></p>
<pre><code>import json
from aws_lambda_powertools.metrics import single_metric, MetricUnit, MetricResolution
metric = single_metric(namespace="ServerlessAirline")

metric.add_metric(name="ColdStart", unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard)
metric.add_dimension(name="function_version", value=47)

print(json.dumps(metric.serialize_metric_set(), indent=4))
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>MetricManager</code></strong> :&ensp;<code><a title="aws_lambda_powertools.metrics.base.MetricManager" href="#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></code></dt>
<dd>Inherits from <code><a title="aws_lambda_powertools.metrics.base.MetricManager" href="#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleMetric(MetricManager):
    &#34;&#34;&#34;SingleMetric creates an EMF object with a single metric.

    EMF specification doesn&#39;t allow metrics with different dimensions.
    SingleMetric overrides MetricManager&#39;s add_metric method to do just that.

    Use `single_metric` when you need to create metrics with different dimensions,
    otherwise `aws_lambda_powertools.metrics.metrics.Metrics` is
    a more cost effective option

    Environment variables
    ---------------------
    POWERTOOLS_METRICS_NAMESPACE : str
        metric namespace

    Example
    -------
    **Creates cold start metric with function_version as dimension**

        import json
        from aws_lambda_powertools.metrics import single_metric, MetricUnit, MetricResolution
        metric = single_metric(namespace=&#34;ServerlessAirline&#34;)

        metric.add_metric(name=&#34;ColdStart&#34;, unit=MetricUnit.Count, value=1, resolution=MetricResolution.Standard)
        metric.add_dimension(name=&#34;function_version&#34;, value=47)

        print(json.dumps(metric.serialize_metric_set(), indent=4))

    Parameters
    ----------
    MetricManager : MetricManager
        Inherits from `aws_lambda_powertools.metrics.base.MetricManager`
    &#34;&#34;&#34;

    def add_metric(
        self,
        name: str,
        unit: Union[MetricUnit, str],
        value: float,
        resolution: Union[MetricResolution, int] = 60,
    ) -&gt; None:
        &#34;&#34;&#34;Method to prevent more than one metric being created

        Parameters
        ----------
        name : str
            Metric name (e.g. BookingConfirmation)
        unit : MetricUnit
            Metric unit (e.g. &#34;Seconds&#34;, MetricUnit.Seconds)
        value : float
            Metric value
        resolution : MetricResolution
            Metric resolution (e.g. 60, MetricResolution.Standard)
        &#34;&#34;&#34;
        if len(self.metric_set) &gt; 0:
            logger.debug(f&#34;Metric {name} already set, skipping...&#34;)
            return
        return super().add_metric(name, unit, value, resolution)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.metrics.base.MetricManager" href="#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.metrics.base.SingleMetric.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self, name: str, unit: Union[<a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a>, str], value: float, resolution: Union[<a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a>, int] = 60) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to prevent more than one metric being created</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Metric name (e.g. BookingConfirmation)</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code><a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a></code></dt>
<dd>Metric unit (e.g. "Seconds", MetricUnit.Seconds)</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Metric value</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code><a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a></code></dt>
<dd>Metric resolution (e.g. 60, MetricResolution.Standard)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(
    self,
    name: str,
    unit: Union[MetricUnit, str],
    value: float,
    resolution: Union[MetricResolution, int] = 60,
) -&gt; None:
    &#34;&#34;&#34;Method to prevent more than one metric being created

    Parameters
    ----------
    name : str
        Metric name (e.g. BookingConfirmation)
    unit : MetricUnit
        Metric unit (e.g. &#34;Seconds&#34;, MetricUnit.Seconds)
    value : float
        Metric value
    resolution : MetricResolution
        Metric resolution (e.g. 60, MetricResolution.Standard)
    &#34;&#34;&#34;
    if len(self.metric_set) &gt; 0:
        logger.debug(f&#34;Metric {name} already set, skipping...&#34;)
        return
    return super().add_metric(name, unit, value, resolution)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aws_lambda_powertools.metrics.base.MetricManager" href="#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></b></code>:
<ul class="hlist">
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_dimension" href="#aws_lambda_powertools.metrics.base.MetricManager.add_dimension">add_dimension</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_metadata" href="#aws_lambda_powertools.metrics.base.MetricManager.add_metadata">add_metadata</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.flush_metrics" href="#aws_lambda_powertools.metrics.base.MetricManager.flush_metrics">flush_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.log_metrics" href="#aws_lambda_powertools.metrics.base.MetricManager.log_metrics">log_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set" href="#aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set">serialize_metric_set</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.metrics" href="index.html">aws_lambda_powertools.metrics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.metrics.base.reset_cold_start_flag" href="#aws_lambda_powertools.metrics.base.reset_cold_start_flag">reset_cold_start_flag</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.single_metric" href="#aws_lambda_powertools.metrics.base.single_metric">single_metric</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.metrics.base.MetricManager" href="#aws_lambda_powertools.metrics.base.MetricManager">MetricManager</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_dimension" href="#aws_lambda_powertools.metrics.base.MetricManager.add_dimension">add_dimension</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_metadata" href="#aws_lambda_powertools.metrics.base.MetricManager.add_metadata">add_metadata</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.add_metric" href="#aws_lambda_powertools.metrics.base.MetricManager.add_metric">add_metric</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.clear_metrics" href="#aws_lambda_powertools.metrics.base.MetricManager.clear_metrics">clear_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.flush_metrics" href="#aws_lambda_powertools.metrics.base.MetricManager.flush_metrics">flush_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.log_metrics" href="#aws_lambda_powertools.metrics.base.MetricManager.log_metrics">log_metrics</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set" href="#aws_lambda_powertools.metrics.base.MetricManager.serialize_metric_set">serialize_metric_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.metrics.base.MetricResolution" href="#aws_lambda_powertools.metrics.base.MetricResolution">MetricResolution</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.metrics.base.MetricResolution.High" href="#aws_lambda_powertools.metrics.base.MetricResolution.High">High</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricResolution.Standard" href="#aws_lambda_powertools.metrics.base.MetricResolution.Standard">Standard</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.metrics.base.MetricUnit" href="#aws_lambda_powertools.metrics.base.MetricUnit">MetricUnit</a></code></h4>
<ul class="two-column">
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Bits" href="#aws_lambda_powertools.metrics.base.MetricUnit.Bits">Bits</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.BitsPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.BitsPerSecond">BitsPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Bytes" href="#aws_lambda_powertools.metrics.base.MetricUnit.Bytes">Bytes</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.BytesPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.BytesPerSecond">BytesPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Count" href="#aws_lambda_powertools.metrics.base.MetricUnit.Count">Count</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.CountPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.CountPerSecond">CountPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Gigabits" href="#aws_lambda_powertools.metrics.base.MetricUnit.Gigabits">Gigabits</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.GigabitsPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.GigabitsPerSecond">GigabitsPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Gigabytes" href="#aws_lambda_powertools.metrics.base.MetricUnit.Gigabytes">Gigabytes</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.GigabytesPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.GigabytesPerSecond">GigabytesPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Kilobits" href="#aws_lambda_powertools.metrics.base.MetricUnit.Kilobits">Kilobits</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.KilobitsPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.KilobitsPerSecond">KilobitsPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Kilobytes" href="#aws_lambda_powertools.metrics.base.MetricUnit.Kilobytes">Kilobytes</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.KilobytesPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.KilobytesPerSecond">KilobytesPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Megabits" href="#aws_lambda_powertools.metrics.base.MetricUnit.Megabits">Megabits</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.MegabitsPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.MegabitsPerSecond">MegabitsPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Megabytes" href="#aws_lambda_powertools.metrics.base.MetricUnit.Megabytes">Megabytes</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.MegabytesPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.MegabytesPerSecond">MegabytesPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Microseconds" href="#aws_lambda_powertools.metrics.base.MetricUnit.Microseconds">Microseconds</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Milliseconds" href="#aws_lambda_powertools.metrics.base.MetricUnit.Milliseconds">Milliseconds</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Percent" href="#aws_lambda_powertools.metrics.base.MetricUnit.Percent">Percent</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Seconds" href="#aws_lambda_powertools.metrics.base.MetricUnit.Seconds">Seconds</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Terabits" href="#aws_lambda_powertools.metrics.base.MetricUnit.Terabits">Terabits</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.TerabitsPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.TerabitsPerSecond">TerabitsPerSecond</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.Terabytes" href="#aws_lambda_powertools.metrics.base.MetricUnit.Terabytes">Terabytes</a></code></li>
<li><code><a title="aws_lambda_powertools.metrics.base.MetricUnit.TerabytesPerSecond" href="#aws_lambda_powertools.metrics.base.MetricUnit.TerabytesPerSecond">TerabytesPerSecond</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.metrics.base.SingleMetric" href="#aws_lambda_powertools.metrics.base.SingleMetric">SingleMetric</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.metrics.base.SingleMetric.add_metric" href="#aws_lambda_powertools.metrics.base.SingleMetric.add_metric">add_metric</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>