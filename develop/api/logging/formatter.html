<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.logging.formatter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.logging.formatter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import inspect
import json
import logging
import os
import time
from abc import ABCMeta, abstractmethod
from datetime import datetime, timezone
from functools import partial
from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, Union

from ..shared import constants
from ..shared.functions import powertools_dev_is_set

RESERVED_LOG_ATTRS = (
    &#34;name&#34;,
    &#34;msg&#34;,
    &#34;args&#34;,
    &#34;level&#34;,
    &#34;levelname&#34;,
    &#34;levelno&#34;,
    &#34;pathname&#34;,
    &#34;filename&#34;,
    &#34;module&#34;,
    &#34;exc_info&#34;,
    &#34;exc_text&#34;,
    &#34;stack_info&#34;,
    &#34;lineno&#34;,
    &#34;funcName&#34;,
    &#34;created&#34;,
    &#34;msecs&#34;,
    &#34;relativeCreated&#34;,
    &#34;thread&#34;,
    &#34;threadName&#34;,
    &#34;processName&#34;,
    &#34;process&#34;,
    &#34;asctime&#34;,
    &#34;location&#34;,
    &#34;timestamp&#34;,
)


class BasePowertoolsFormatter(logging.Formatter, metaclass=ABCMeta):
    @abstractmethod
    def append_keys(self, **additional_keys):
        raise NotImplementedError()

    def remove_keys(self, keys: Iterable[str]):
        raise NotImplementedError()

    @abstractmethod
    def clear_state(self):
        &#34;&#34;&#34;Removes any previously added logging keys&#34;&#34;&#34;
        raise NotImplementedError()


class LambdaPowertoolsFormatter(BasePowertoolsFormatter):
    &#34;&#34;&#34;AWS Lambda Powertools Logging formatter.

    Formats the log message as a JSON encoded string. If the message is a
    dict it will be used directly.
    &#34;&#34;&#34;

    default_time_format = &#34;%Y-%m-%d %H:%M:%S,%F%z&#34;  # &#39;2021-04-17 18:19:57,656+0200&#39;
    custom_ms_time_directive = &#34;%F&#34;
    RFC3339_ISO8601_FORMAT = &#34;%Y-%m-%dT%H:%M:%S.%F%z&#34;  # &#39;2022-10-27T16:27:43.738+02:00&#39;

    def __init__(
        self,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Return a LambdaPowertoolsFormatter instance.

        The `log_record_order` kwarg is used to specify the order of the keys used in
        the structured json logs. By default the order is: &#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;,
        &#34;service&#34;.

        Other kwargs are used to specify log field format strings.

        Parameters
        ----------
        json_serializer : Callable, optional
            function to serialize `obj` to a JSON formatted `str`, by default json.dumps
        json_deserializer : Callable, optional
            function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
            by default json.loads
        json_default : Callable, optional
            function to coerce unserializable values, by default str

            Only used when no custom JSON encoder is set

        datefmt : str, optional
            String directives (strftime) to format log timestamp.

            See https://docs.python.org/3/library/time.html#time.strftime or
        use_datetime_directive: str, optional
            Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
            `time.strftime` - Only useful when used alongside `datefmt`.

            See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
            also supports a custom %F directive for milliseconds.
        utc : bool, optional
            set logging timestamp to UTC, by default False to continue to use local time as per stdlib
        use_rfc3339: bool, optional
            Whether to use a popular dateformat that complies with both RFC3339 and ISO8601.
            e.g., 2022-10-27T16:27:43.738+02:00.
        log_record_order : list, optional
            set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        kwargs
            Key-value to be included in log messages

        &#34;&#34;&#34;

        self.json_deserializer = json_deserializer or json.loads
        self.json_default = json_default or str
        self.json_indent = (
            constants.PRETTY_INDENT if powertools_dev_is_set() else constants.COMPACT_INDENT
        )  # indented json serialization when in AWS SAM Local
        self.json_serializer = json_serializer or partial(
            json.dumps, default=self.json_default, separators=(&#34;,&#34;, &#34;:&#34;), indent=self.json_indent
        )

        self.datefmt = datefmt
        self.use_datetime_directive = use_datetime_directive

        self.utc = utc
        self.log_record_order = log_record_order or [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        self.log_format = dict.fromkeys(self.log_record_order)  # Set the insertion order for the log messages
        self.update_formatter = self.append_keys  # alias to old method
        self.use_rfc3339_iso8601 = use_rfc3339

        if self.utc:
            self.converter = time.gmtime

        self.keys_combined = {**self._build_default_keys(), **kwargs}
        self.log_format.update(**self.keys_combined)

        super().__init__(datefmt=self.datefmt)

    def serialize(self, log: Dict) -&gt; str:
        &#34;&#34;&#34;Serialize structured log dict to JSON str&#34;&#34;&#34;
        return self.json_serializer(log)

    def format(self, record: logging.LogRecord) -&gt; str:  # noqa: A003
        &#34;&#34;&#34;Format logging record as structured JSON str&#34;&#34;&#34;
        formatted_log = self._extract_log_keys(log_record=record)
        formatted_log[&#34;message&#34;] = self._extract_log_message(log_record=record)
        # exception and exception_name fields can be added as extra key
        # in any log level, we try to extract and use them first
        extracted_exception, extracted_exception_name = self._extract_log_exception(log_record=record)
        formatted_log[&#34;exception&#34;] = formatted_log.get(&#34;exception&#34;, extracted_exception)
        formatted_log[&#34;exception_name&#34;] = formatted_log.get(&#34;exception_name&#34;, extracted_exception_name)
        formatted_log[&#34;xray_trace_id&#34;] = self._get_latest_trace_id()
        formatted_log = self._strip_none_records(records=formatted_log)

        return self.serialize(log=formatted_log)

    def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -&gt; str:
        # As of Py3.7, we can infer milliseconds directly from any datetime
        # saving processing time as we can shortcircuit early
        # Maintenance: In V3, we (and Java) should move to this format by default
        # since we&#39;ve provided enough time for those migrating from std logging
        if self.use_rfc3339_iso8601:
            if self.utc:
                ts_as_datetime = datetime.fromtimestamp(record.created, tz=timezone.utc)
            else:
                ts_as_datetime = datetime.fromtimestamp(record.created).astimezone()

            return ts_as_datetime.isoformat(timespec=&#34;milliseconds&#34;)  # 2022-10-27T17:42:26.841+0200

        # converts to local/UTC TZ as struct time
        record_ts = self.converter(record.created)

        if datefmt is None:  # pragma: no cover, it&#39;ll always be None in std logging, but mypy
            datefmt = self.datefmt

        # NOTE: Python `time.strftime` doesn&#39;t provide msec directives
        # so we create a custom one (%F) and replace logging record_ts
        # Reason 2 is that std logging doesn&#39;t support msec after TZ
        msecs = &#34;%03d&#34; % record.msecs

        # Datetime format codes is a superset of time format codes
        # therefore we only honour them if explicitly asked
        # by default, those migrating from std logging will use time format codes
        # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
        if self.use_datetime_directive and datefmt:
            # record.msecs are microseconds, divide by 1000 to get milliseconds
            timestamp = record.created + record.msecs / 1000

            if self.utc:
                dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
            else:
                dt = datetime.fromtimestamp(timestamp).astimezone()

            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return dt.strftime(custom_fmt)

        # Only time format codes being used
        elif datefmt:
            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return time.strftime(custom_fmt, record_ts)

        # Use default fmt: 2021-05-03 10:20:19,650+0200
        custom_fmt = self.default_time_format.replace(self.custom_ms_time_directive, msecs)
        return time.strftime(custom_fmt, record_ts)

    def append_keys(self, **additional_keys):
        self.log_format.update(additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        for key in keys:
            self.log_format.pop(key, None)

    def clear_state(self):
        self.log_format = dict.fromkeys(self.log_record_order)
        self.log_format.update(**self.keys_combined)

    @staticmethod
    def _build_default_keys():
        return {
            &#34;level&#34;: &#34;%(levelname)s&#34;,
            &#34;location&#34;: &#34;%(funcName)s:%(lineno)d&#34;,
            &#34;timestamp&#34;: &#34;%(asctime)s&#34;,
        }

    @staticmethod
    def _get_latest_trace_id():
        xray_trace_id = os.getenv(constants.XRAY_TRACE_ID_ENV)
        return xray_trace_id.split(&#34;;&#34;)[0].replace(&#34;Root=&#34;, &#34;&#34;) if xray_trace_id else None

    def _extract_log_message(self, log_record: logging.LogRecord) -&gt; Union[Dict[str, Any], str, bool, Iterable]:
        &#34;&#34;&#34;Extract message from log record and attempt to JSON decode it if str

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        message: Union[Dict, str, bool, Iterable]
            Extracted message
        &#34;&#34;&#34;
        message = log_record.msg
        if isinstance(message, dict):
            return message

        if log_record.args:  # logger.info(&#34;foo %s&#34;, &#34;bar&#34;) requires formatting
            return log_record.getMessage()

        if isinstance(message, str):  # could be a JSON string
            try:
                message = self.json_deserializer(message)
            except (json.decoder.JSONDecodeError, TypeError, ValueError):
                pass

        return message

    def _extract_log_exception(self, log_record: logging.LogRecord) -&gt; Union[Tuple[str, str], Tuple[None, None]]:
        &#34;&#34;&#34;Format traceback information, if available

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        log_record: Optional[Tuple[str, str]]
            Log record with constant traceback info and exception name
        &#34;&#34;&#34;
        if log_record.exc_info:
            return self.formatException(log_record.exc_info), log_record.exc_info[0].__name__  # type: ignore

        return None, None

    def _extract_log_keys(self, log_record: logging.LogRecord) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Extract and parse custom and reserved log keys

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract keys from

        Returns
        -------
        formatted_log: Dict
            Structured log as dictionary
        &#34;&#34;&#34;
        record_dict = log_record.__dict__.copy()
        record_dict[&#34;asctime&#34;] = self.formatTime(record=log_record)
        extras = {k: v for k, v in record_dict.items() if k not in RESERVED_LOG_ATTRS}

        formatted_log = {}

        # Iterate over a default or existing log structure
        # then replace any std log attribute e.g. &#39;%(level)s&#39; to &#39;INFO&#39;, &#39;%(process)d to &#39;4773&#39;
        # lastly add or replace incoming keys (those added within the constructor or .structure_logs method)
        for key, value in self.log_format.items():
            if value and key in RESERVED_LOG_ATTRS:
                formatted_log[key] = value % record_dict
            else:
                formatted_log[key] = value

        formatted_log.update(**extras)
        return formatted_log

    @staticmethod
    def _strip_none_records(records: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Remove any key with None as value&#34;&#34;&#34;
        return {k: v for k, v in records.items() if v is not None}


JsonFormatter = LambdaPowertoolsFormatter  # alias to previous formatter


# Fetch current and future parameters from PowertoolsFormatter that should be reserved
RESERVED_FORMATTER_CUSTOM_KEYS: List[str] = inspect.getfullargspec(LambdaPowertoolsFormatter).args[1:]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter"><code class="flex name class">
<span>class <span class="ident">BasePowertoolsFormatter</span></span>
<span>(</span><span>fmt=None, datefmt=None, style='%', validate=True, *, defaults=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Formatter instances are used to convert a LogRecord to text.</p>
<p>Formatters need to know how a LogRecord is constructed. They are
responsible for converting a LogRecord to (usually) a string which can
be interpreted by either a human or an external system. The base Formatter
allows a formatting string to be specified. If none is supplied, the
style-dependent default value, "%(message)s", "{message}", or
"${message}", is used.</p>
<p>The Formatter can be initialized with a format string which makes use of
knowledge of the LogRecord attributes - e.g. the default value mentioned
above makes use of the fact that the user's message and arguments are pre-
formatted into a LogRecord's message attribute. Currently, the useful
attributes in a LogRecord are described by:</p>
<p>%(name)s
Name of the logger (logging channel)
%(levelno)s
Numeric logging level for the message (DEBUG, INFO,
WARNING, ERROR, CRITICAL)
%(levelname)s
Text logging level for the message ("DEBUG", "INFO",
"WARNING", "ERROR", "CRITICAL")
%(pathname)s
Full pathname of the source file where the logging
call was issued (if available)
%(filename)s
Filename portion of pathname
%(module)s
Module (name portion of filename)
%(lineno)d
Source line number where the logging call was issued
(if available)
%(funcName)s
Function name
%(created)f
Time when the LogRecord was created (time.time()
return value)
%(asctime)s
Textual time when the LogRecord was created
%(msecs)d
Millisecond portion of the creation time
%(relativeCreated)d Time in milliseconds when the LogRecord was created,
relative to the time the logging module was loaded
(typically at application startup time)
%(thread)d
Thread ID (if available)
%(threadName)s
Thread name (if available)
%(process)d
Process ID (if available)
%(message)s
The result of record.getMessage(), computed just as
the record is emitted</p>
<p>Initialize the formatter with specified format strings.</p>
<p>Initialize the formatter either with the specified format string, or a
default as described above. Allow for specialized date formatting with
the optional datefmt argument. If datefmt is omitted, you get an
ISO8601-like (or RFC 3339-like) format.</p>
<p>Use a style parameter of '%', '{' or '$' to specify that you want to
use one of %-formatting, :meth:<code>str.format</code> (<code>{}</code>) formatting or
:class:<code>string.Template</code> formatting in your format string.</p>
<div class="admonition versionchanged">
<p class="admonition-title">Changed in version:&ensp;3.2</p>
<p>Added the <code>style</code> parameter.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePowertoolsFormatter(logging.Formatter, metaclass=ABCMeta):
    @abstractmethod
    def append_keys(self, **additional_keys):
        raise NotImplementedError()

    def remove_keys(self, keys: Iterable[str]):
        raise NotImplementedError()

    @abstractmethod
    def clear_state(self):
        &#34;&#34;&#34;Removes any previously added logging keys&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Formatter</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter">LambdaPowertoolsFormatter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.append_keys"><code class="name flex">
<span>def <span class="ident">append_keys</span></span>(<span>self, **additional_keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def append_keys(self, **additional_keys):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.clear_state"><code class="name flex">
<span>def <span class="ident">clear_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes any previously added logging keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def clear_state(self):
    &#34;&#34;&#34;Removes any previously added logging keys&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.remove_keys"><code class="name flex">
<span>def <span class="ident">remove_keys</span></span>(<span>self, keys: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keys(self, keys: Iterable[str]):
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter"><code class="flex name class">
<span>class <span class="ident">LambdaPowertoolsFormatter</span></span>
<span>(</span><span>json_serializer: Optional[Callable[[Dict], str]] = None, json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None, json_default: Optional[Callable[[Any], Any]] = None, datefmt: Optional[str] = None, use_datetime_directive: bool = False, log_record_order: Optional[List[str]] = None, utc: bool = False, use_rfc3339: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>AWS Lambda Powertools Logging formatter.</p>
<p>Formats the log message as a JSON encoded string. If the message is a
dict it will be used directly.</p>
<p>Return a LambdaPowertoolsFormatter instance.</p>
<p>The <code>log_record_order</code> kwarg is used to specify the order of the keys used in
the structured json logs. By default the order is: "level", "location", "message", "timestamp",
"service".</p>
<p>Other kwargs are used to specify log field format strings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_serializer</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>function to serialize <code>obj</code> to a JSON formatted <code>str</code>, by default json.dumps</dd>
<dt><strong><code>json_deserializer</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>function to deserialize <code>str</code>, <code>bytes</code>, bytearray<code> containing a JSON document to a Python </code>obj`,
by default json.loads</dd>
<dt><strong><code>json_default</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>
<p>function to coerce unserializable values, by default str</p>
<p>Only used when no custom JSON encoder is set</p>
</dd>
<dt><strong><code>datefmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>String directives (strftime) to format log timestamp.</p>
<p>See <a href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a> or</p>
</dd>
<dt><strong><code>use_datetime_directive</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Interpret <code>datefmt</code> as a format string for <code>datetime.datetime.strftime</code>, rather than
<code>time.strftime</code> - Only useful when used alongside <code>datefmt</code>.</p>
<p>See <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a> . This
also supports a custom %F directive for milliseconds.</p>
</dd>
<dt><strong><code>utc</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>set logging timestamp to UTC, by default False to continue to use local time as per stdlib</dd>
<dt><strong><code>use_rfc3339</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use a popular dateformat that complies with both RFC3339 and ISO8601.
e.g., 2022-10-27T16:27:43.738+02:00.</dd>
<dt><strong><code>log_record_order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>set order of log keys when logging, by default ["level", "location", "message", "timestamp"]</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Key-value to be included in log messages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LambdaPowertoolsFormatter(BasePowertoolsFormatter):
    &#34;&#34;&#34;AWS Lambda Powertools Logging formatter.

    Formats the log message as a JSON encoded string. If the message is a
    dict it will be used directly.
    &#34;&#34;&#34;

    default_time_format = &#34;%Y-%m-%d %H:%M:%S,%F%z&#34;  # &#39;2021-04-17 18:19:57,656+0200&#39;
    custom_ms_time_directive = &#34;%F&#34;
    RFC3339_ISO8601_FORMAT = &#34;%Y-%m-%dT%H:%M:%S.%F%z&#34;  # &#39;2022-10-27T16:27:43.738+02:00&#39;

    def __init__(
        self,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Return a LambdaPowertoolsFormatter instance.

        The `log_record_order` kwarg is used to specify the order of the keys used in
        the structured json logs. By default the order is: &#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;,
        &#34;service&#34;.

        Other kwargs are used to specify log field format strings.

        Parameters
        ----------
        json_serializer : Callable, optional
            function to serialize `obj` to a JSON formatted `str`, by default json.dumps
        json_deserializer : Callable, optional
            function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
            by default json.loads
        json_default : Callable, optional
            function to coerce unserializable values, by default str

            Only used when no custom JSON encoder is set

        datefmt : str, optional
            String directives (strftime) to format log timestamp.

            See https://docs.python.org/3/library/time.html#time.strftime or
        use_datetime_directive: str, optional
            Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
            `time.strftime` - Only useful when used alongside `datefmt`.

            See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
            also supports a custom %F directive for milliseconds.
        utc : bool, optional
            set logging timestamp to UTC, by default False to continue to use local time as per stdlib
        use_rfc3339: bool, optional
            Whether to use a popular dateformat that complies with both RFC3339 and ISO8601.
            e.g., 2022-10-27T16:27:43.738+02:00.
        log_record_order : list, optional
            set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        kwargs
            Key-value to be included in log messages

        &#34;&#34;&#34;

        self.json_deserializer = json_deserializer or json.loads
        self.json_default = json_default or str
        self.json_indent = (
            constants.PRETTY_INDENT if powertools_dev_is_set() else constants.COMPACT_INDENT
        )  # indented json serialization when in AWS SAM Local
        self.json_serializer = json_serializer or partial(
            json.dumps, default=self.json_default, separators=(&#34;,&#34;, &#34;:&#34;), indent=self.json_indent
        )

        self.datefmt = datefmt
        self.use_datetime_directive = use_datetime_directive

        self.utc = utc
        self.log_record_order = log_record_order or [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        self.log_format = dict.fromkeys(self.log_record_order)  # Set the insertion order for the log messages
        self.update_formatter = self.append_keys  # alias to old method
        self.use_rfc3339_iso8601 = use_rfc3339

        if self.utc:
            self.converter = time.gmtime

        self.keys_combined = {**self._build_default_keys(), **kwargs}
        self.log_format.update(**self.keys_combined)

        super().__init__(datefmt=self.datefmt)

    def serialize(self, log: Dict) -&gt; str:
        &#34;&#34;&#34;Serialize structured log dict to JSON str&#34;&#34;&#34;
        return self.json_serializer(log)

    def format(self, record: logging.LogRecord) -&gt; str:  # noqa: A003
        &#34;&#34;&#34;Format logging record as structured JSON str&#34;&#34;&#34;
        formatted_log = self._extract_log_keys(log_record=record)
        formatted_log[&#34;message&#34;] = self._extract_log_message(log_record=record)
        # exception and exception_name fields can be added as extra key
        # in any log level, we try to extract and use them first
        extracted_exception, extracted_exception_name = self._extract_log_exception(log_record=record)
        formatted_log[&#34;exception&#34;] = formatted_log.get(&#34;exception&#34;, extracted_exception)
        formatted_log[&#34;exception_name&#34;] = formatted_log.get(&#34;exception_name&#34;, extracted_exception_name)
        formatted_log[&#34;xray_trace_id&#34;] = self._get_latest_trace_id()
        formatted_log = self._strip_none_records(records=formatted_log)

        return self.serialize(log=formatted_log)

    def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -&gt; str:
        # As of Py3.7, we can infer milliseconds directly from any datetime
        # saving processing time as we can shortcircuit early
        # Maintenance: In V3, we (and Java) should move to this format by default
        # since we&#39;ve provided enough time for those migrating from std logging
        if self.use_rfc3339_iso8601:
            if self.utc:
                ts_as_datetime = datetime.fromtimestamp(record.created, tz=timezone.utc)
            else:
                ts_as_datetime = datetime.fromtimestamp(record.created).astimezone()

            return ts_as_datetime.isoformat(timespec=&#34;milliseconds&#34;)  # 2022-10-27T17:42:26.841+0200

        # converts to local/UTC TZ as struct time
        record_ts = self.converter(record.created)

        if datefmt is None:  # pragma: no cover, it&#39;ll always be None in std logging, but mypy
            datefmt = self.datefmt

        # NOTE: Python `time.strftime` doesn&#39;t provide msec directives
        # so we create a custom one (%F) and replace logging record_ts
        # Reason 2 is that std logging doesn&#39;t support msec after TZ
        msecs = &#34;%03d&#34; % record.msecs

        # Datetime format codes is a superset of time format codes
        # therefore we only honour them if explicitly asked
        # by default, those migrating from std logging will use time format codes
        # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
        if self.use_datetime_directive and datefmt:
            # record.msecs are microseconds, divide by 1000 to get milliseconds
            timestamp = record.created + record.msecs / 1000

            if self.utc:
                dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
            else:
                dt = datetime.fromtimestamp(timestamp).astimezone()

            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return dt.strftime(custom_fmt)

        # Only time format codes being used
        elif datefmt:
            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return time.strftime(custom_fmt, record_ts)

        # Use default fmt: 2021-05-03 10:20:19,650+0200
        custom_fmt = self.default_time_format.replace(self.custom_ms_time_directive, msecs)
        return time.strftime(custom_fmt, record_ts)

    def append_keys(self, **additional_keys):
        self.log_format.update(additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        for key in keys:
            self.log_format.pop(key, None)

    def clear_state(self):
        self.log_format = dict.fromkeys(self.log_record_order)
        self.log_format.update(**self.keys_combined)

    @staticmethod
    def _build_default_keys():
        return {
            &#34;level&#34;: &#34;%(levelname)s&#34;,
            &#34;location&#34;: &#34;%(funcName)s:%(lineno)d&#34;,
            &#34;timestamp&#34;: &#34;%(asctime)s&#34;,
        }

    @staticmethod
    def _get_latest_trace_id():
        xray_trace_id = os.getenv(constants.XRAY_TRACE_ID_ENV)
        return xray_trace_id.split(&#34;;&#34;)[0].replace(&#34;Root=&#34;, &#34;&#34;) if xray_trace_id else None

    def _extract_log_message(self, log_record: logging.LogRecord) -&gt; Union[Dict[str, Any], str, bool, Iterable]:
        &#34;&#34;&#34;Extract message from log record and attempt to JSON decode it if str

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        message: Union[Dict, str, bool, Iterable]
            Extracted message
        &#34;&#34;&#34;
        message = log_record.msg
        if isinstance(message, dict):
            return message

        if log_record.args:  # logger.info(&#34;foo %s&#34;, &#34;bar&#34;) requires formatting
            return log_record.getMessage()

        if isinstance(message, str):  # could be a JSON string
            try:
                message = self.json_deserializer(message)
            except (json.decoder.JSONDecodeError, TypeError, ValueError):
                pass

        return message

    def _extract_log_exception(self, log_record: logging.LogRecord) -&gt; Union[Tuple[str, str], Tuple[None, None]]:
        &#34;&#34;&#34;Format traceback information, if available

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        log_record: Optional[Tuple[str, str]]
            Log record with constant traceback info and exception name
        &#34;&#34;&#34;
        if log_record.exc_info:
            return self.formatException(log_record.exc_info), log_record.exc_info[0].__name__  # type: ignore

        return None, None

    def _extract_log_keys(self, log_record: logging.LogRecord) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Extract and parse custom and reserved log keys

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract keys from

        Returns
        -------
        formatted_log: Dict
            Structured log as dictionary
        &#34;&#34;&#34;
        record_dict = log_record.__dict__.copy()
        record_dict[&#34;asctime&#34;] = self.formatTime(record=log_record)
        extras = {k: v for k, v in record_dict.items() if k not in RESERVED_LOG_ATTRS}

        formatted_log = {}

        # Iterate over a default or existing log structure
        # then replace any std log attribute e.g. &#39;%(level)s&#39; to &#39;INFO&#39;, &#39;%(process)d to &#39;4773&#39;
        # lastly add or replace incoming keys (those added within the constructor or .structure_logs method)
        for key, value in self.log_format.items():
            if value and key in RESERVED_LOG_ATTRS:
                formatted_log[key] = value % record_dict
            else:
                formatted_log[key] = value

        formatted_log.update(**extras)
        return formatted_log

    @staticmethod
    def _strip_none_records(records: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Remove any key with None as value&#34;&#34;&#34;
        return {k: v for k, v in records.items() if v is not None}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter">BasePowertoolsFormatter</a></li>
<li>logging.Formatter</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.formatters.datadog.DatadogLogFormatter" href="formatters/datadog.html#aws_lambda_powertools.logging.formatters.datadog.DatadogLogFormatter">DatadogLogFormatter</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT"><code class="name">var <span class="ident">RFC3339_ISO8601_FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive"><code class="name">var <span class="ident">custom_ms_time_directive</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format"><code class="name">var <span class="ident">default_time_format</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys"><code class="name flex">
<span>def <span class="ident">append_keys</span></span>(<span>self, **additional_keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_keys(self, **additional_keys):
    self.log_format.update(additional_keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.clear_state"><code class="name flex">
<span>def <span class="ident">clear_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes any previously added logging keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_state(self):
    self.log_format = dict.fromkeys(self.log_record_order)
    self.log_format.update(**self.keys_combined)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, record: logging.LogRecord) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format logging record as structured JSON str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, record: logging.LogRecord) -&gt; str:  # noqa: A003
    &#34;&#34;&#34;Format logging record as structured JSON str&#34;&#34;&#34;
    formatted_log = self._extract_log_keys(log_record=record)
    formatted_log[&#34;message&#34;] = self._extract_log_message(log_record=record)
    # exception and exception_name fields can be added as extra key
    # in any log level, we try to extract and use them first
    extracted_exception, extracted_exception_name = self._extract_log_exception(log_record=record)
    formatted_log[&#34;exception&#34;] = formatted_log.get(&#34;exception&#34;, extracted_exception)
    formatted_log[&#34;exception_name&#34;] = formatted_log.get(&#34;exception_name&#34;, extracted_exception_name)
    formatted_log[&#34;xray_trace_id&#34;] = self._get_latest_trace_id()
    formatted_log = self._strip_none_records(records=formatted_log)

    return self.serialize(log=formatted_log)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime"><code class="name flex">
<span>def <span class="ident">formatTime</span></span>(<span>self, record: logging.LogRecord, datefmt: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the creation time of the specified LogRecord as formatted text.</p>
<p>This method should be called from format() by a formatter which
wants to make use of a formatted time. This method can be overridden
in formatters to provide for any specific requirement, but the
basic behaviour is as follows: if datefmt (a string) is specified,
it is used with time.strftime() to format the creation time of the
record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
The resulting string is returned. This function uses a user-configurable
function to convert the creation time to a tuple. By default,
time.localtime() is used; to change this for a particular formatter
instance, set the 'converter' attribute to a function with the same
signature as time.localtime() or time.gmtime(). To change it for all
formatters, for example if you want all logging times to be shown in GMT,
set the 'converter' attribute in the Formatter class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -&gt; str:
    # As of Py3.7, we can infer milliseconds directly from any datetime
    # saving processing time as we can shortcircuit early
    # Maintenance: In V3, we (and Java) should move to this format by default
    # since we&#39;ve provided enough time for those migrating from std logging
    if self.use_rfc3339_iso8601:
        if self.utc:
            ts_as_datetime = datetime.fromtimestamp(record.created, tz=timezone.utc)
        else:
            ts_as_datetime = datetime.fromtimestamp(record.created).astimezone()

        return ts_as_datetime.isoformat(timespec=&#34;milliseconds&#34;)  # 2022-10-27T17:42:26.841+0200

    # converts to local/UTC TZ as struct time
    record_ts = self.converter(record.created)

    if datefmt is None:  # pragma: no cover, it&#39;ll always be None in std logging, but mypy
        datefmt = self.datefmt

    # NOTE: Python `time.strftime` doesn&#39;t provide msec directives
    # so we create a custom one (%F) and replace logging record_ts
    # Reason 2 is that std logging doesn&#39;t support msec after TZ
    msecs = &#34;%03d&#34; % record.msecs

    # Datetime format codes is a superset of time format codes
    # therefore we only honour them if explicitly asked
    # by default, those migrating from std logging will use time format codes
    # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
    if self.use_datetime_directive and datefmt:
        # record.msecs are microseconds, divide by 1000 to get milliseconds
        timestamp = record.created + record.msecs / 1000

        if self.utc:
            dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
        else:
            dt = datetime.fromtimestamp(timestamp).astimezone()

        custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
        return dt.strftime(custom_fmt)

    # Only time format codes being used
    elif datefmt:
        custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
        return time.strftime(custom_fmt, record_ts)

    # Use default fmt: 2021-05-03 10:20:19,650+0200
    custom_fmt = self.default_time_format.replace(self.custom_ms_time_directive, msecs)
    return time.strftime(custom_fmt, record_ts)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys"><code class="name flex">
<span>def <span class="ident">remove_keys</span></span>(<span>self, keys: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keys(self, keys: Iterable[str]):
    for key in keys:
        self.log_format.pop(key, None)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, log: Dict) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize structured log dict to JSON str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, log: Dict) -&gt; str:
    &#34;&#34;&#34;Serialize structured log dict to JSON str&#34;&#34;&#34;
    return self.json_serializer(log)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter"><code class="flex name class">
<span>class <span class="ident">JsonFormatter</span></span>
<span>(</span><span>json_serializer: Optional[Callable[[Dict], str]] = None, json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None, json_default: Optional[Callable[[Any], Any]] = None, datefmt: Optional[str] = None, use_datetime_directive: bool = False, log_record_order: Optional[List[str]] = None, utc: bool = False, use_rfc3339: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>AWS Lambda Powertools Logging formatter.</p>
<p>Formats the log message as a JSON encoded string. If the message is a
dict it will be used directly.</p>
<p>Return a LambdaPowertoolsFormatter instance.</p>
<p>The <code>log_record_order</code> kwarg is used to specify the order of the keys used in
the structured json logs. By default the order is: "level", "location", "message", "timestamp",
"service".</p>
<p>Other kwargs are used to specify log field format strings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>json_serializer</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>function to serialize <code>obj</code> to a JSON formatted <code>str</code>, by default json.dumps</dd>
<dt><strong><code>json_deserializer</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>function to deserialize <code>str</code>, <code>bytes</code>, bytearray<code> containing a JSON document to a Python </code>obj`,
by default json.loads</dd>
<dt><strong><code>json_default</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>
<p>function to coerce unserializable values, by default str</p>
<p>Only used when no custom JSON encoder is set</p>
</dd>
<dt><strong><code>datefmt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>String directives (strftime) to format log timestamp.</p>
<p>See <a href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a> or</p>
</dd>
<dt><strong><code>use_datetime_directive</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Interpret <code>datefmt</code> as a format string for <code>datetime.datetime.strftime</code>, rather than
<code>time.strftime</code> - Only useful when used alongside <code>datefmt</code>.</p>
<p>See <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a> . This
also supports a custom %F directive for milliseconds.</p>
</dd>
<dt><strong><code>utc</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>set logging timestamp to UTC, by default False to continue to use local time as per stdlib</dd>
<dt><strong><code>use_rfc3339</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use a popular dateformat that complies with both RFC3339 and ISO8601.
e.g., 2022-10-27T16:27:43.738+02:00.</dd>
<dt><strong><code>log_record_order</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>set order of log keys when logging, by default ["level", "location", "message", "timestamp"]</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Key-value to be included in log messages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LambdaPowertoolsFormatter(BasePowertoolsFormatter):
    &#34;&#34;&#34;AWS Lambda Powertools Logging formatter.

    Formats the log message as a JSON encoded string. If the message is a
    dict it will be used directly.
    &#34;&#34;&#34;

    default_time_format = &#34;%Y-%m-%d %H:%M:%S,%F%z&#34;  # &#39;2021-04-17 18:19:57,656+0200&#39;
    custom_ms_time_directive = &#34;%F&#34;
    RFC3339_ISO8601_FORMAT = &#34;%Y-%m-%dT%H:%M:%S.%F%z&#34;  # &#39;2022-10-27T16:27:43.738+02:00&#39;

    def __init__(
        self,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Return a LambdaPowertoolsFormatter instance.

        The `log_record_order` kwarg is used to specify the order of the keys used in
        the structured json logs. By default the order is: &#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;,
        &#34;service&#34;.

        Other kwargs are used to specify log field format strings.

        Parameters
        ----------
        json_serializer : Callable, optional
            function to serialize `obj` to a JSON formatted `str`, by default json.dumps
        json_deserializer : Callable, optional
            function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
            by default json.loads
        json_default : Callable, optional
            function to coerce unserializable values, by default str

            Only used when no custom JSON encoder is set

        datefmt : str, optional
            String directives (strftime) to format log timestamp.

            See https://docs.python.org/3/library/time.html#time.strftime or
        use_datetime_directive: str, optional
            Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
            `time.strftime` - Only useful when used alongside `datefmt`.

            See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
            also supports a custom %F directive for milliseconds.
        utc : bool, optional
            set logging timestamp to UTC, by default False to continue to use local time as per stdlib
        use_rfc3339: bool, optional
            Whether to use a popular dateformat that complies with both RFC3339 and ISO8601.
            e.g., 2022-10-27T16:27:43.738+02:00.
        log_record_order : list, optional
            set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        kwargs
            Key-value to be included in log messages

        &#34;&#34;&#34;

        self.json_deserializer = json_deserializer or json.loads
        self.json_default = json_default or str
        self.json_indent = (
            constants.PRETTY_INDENT if powertools_dev_is_set() else constants.COMPACT_INDENT
        )  # indented json serialization when in AWS SAM Local
        self.json_serializer = json_serializer or partial(
            json.dumps, default=self.json_default, separators=(&#34;,&#34;, &#34;:&#34;), indent=self.json_indent
        )

        self.datefmt = datefmt
        self.use_datetime_directive = use_datetime_directive

        self.utc = utc
        self.log_record_order = log_record_order or [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]
        self.log_format = dict.fromkeys(self.log_record_order)  # Set the insertion order for the log messages
        self.update_formatter = self.append_keys  # alias to old method
        self.use_rfc3339_iso8601 = use_rfc3339

        if self.utc:
            self.converter = time.gmtime

        self.keys_combined = {**self._build_default_keys(), **kwargs}
        self.log_format.update(**self.keys_combined)

        super().__init__(datefmt=self.datefmt)

    def serialize(self, log: Dict) -&gt; str:
        &#34;&#34;&#34;Serialize structured log dict to JSON str&#34;&#34;&#34;
        return self.json_serializer(log)

    def format(self, record: logging.LogRecord) -&gt; str:  # noqa: A003
        &#34;&#34;&#34;Format logging record as structured JSON str&#34;&#34;&#34;
        formatted_log = self._extract_log_keys(log_record=record)
        formatted_log[&#34;message&#34;] = self._extract_log_message(log_record=record)
        # exception and exception_name fields can be added as extra key
        # in any log level, we try to extract and use them first
        extracted_exception, extracted_exception_name = self._extract_log_exception(log_record=record)
        formatted_log[&#34;exception&#34;] = formatted_log.get(&#34;exception&#34;, extracted_exception)
        formatted_log[&#34;exception_name&#34;] = formatted_log.get(&#34;exception_name&#34;, extracted_exception_name)
        formatted_log[&#34;xray_trace_id&#34;] = self._get_latest_trace_id()
        formatted_log = self._strip_none_records(records=formatted_log)

        return self.serialize(log=formatted_log)

    def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -&gt; str:
        # As of Py3.7, we can infer milliseconds directly from any datetime
        # saving processing time as we can shortcircuit early
        # Maintenance: In V3, we (and Java) should move to this format by default
        # since we&#39;ve provided enough time for those migrating from std logging
        if self.use_rfc3339_iso8601:
            if self.utc:
                ts_as_datetime = datetime.fromtimestamp(record.created, tz=timezone.utc)
            else:
                ts_as_datetime = datetime.fromtimestamp(record.created).astimezone()

            return ts_as_datetime.isoformat(timespec=&#34;milliseconds&#34;)  # 2022-10-27T17:42:26.841+0200

        # converts to local/UTC TZ as struct time
        record_ts = self.converter(record.created)

        if datefmt is None:  # pragma: no cover, it&#39;ll always be None in std logging, but mypy
            datefmt = self.datefmt

        # NOTE: Python `time.strftime` doesn&#39;t provide msec directives
        # so we create a custom one (%F) and replace logging record_ts
        # Reason 2 is that std logging doesn&#39;t support msec after TZ
        msecs = &#34;%03d&#34; % record.msecs

        # Datetime format codes is a superset of time format codes
        # therefore we only honour them if explicitly asked
        # by default, those migrating from std logging will use time format codes
        # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
        if self.use_datetime_directive and datefmt:
            # record.msecs are microseconds, divide by 1000 to get milliseconds
            timestamp = record.created + record.msecs / 1000

            if self.utc:
                dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
            else:
                dt = datetime.fromtimestamp(timestamp).astimezone()

            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return dt.strftime(custom_fmt)

        # Only time format codes being used
        elif datefmt:
            custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
            return time.strftime(custom_fmt, record_ts)

        # Use default fmt: 2021-05-03 10:20:19,650+0200
        custom_fmt = self.default_time_format.replace(self.custom_ms_time_directive, msecs)
        return time.strftime(custom_fmt, record_ts)

    def append_keys(self, **additional_keys):
        self.log_format.update(additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        for key in keys:
            self.log_format.pop(key, None)

    def clear_state(self):
        self.log_format = dict.fromkeys(self.log_record_order)
        self.log_format.update(**self.keys_combined)

    @staticmethod
    def _build_default_keys():
        return {
            &#34;level&#34;: &#34;%(levelname)s&#34;,
            &#34;location&#34;: &#34;%(funcName)s:%(lineno)d&#34;,
            &#34;timestamp&#34;: &#34;%(asctime)s&#34;,
        }

    @staticmethod
    def _get_latest_trace_id():
        xray_trace_id = os.getenv(constants.XRAY_TRACE_ID_ENV)
        return xray_trace_id.split(&#34;;&#34;)[0].replace(&#34;Root=&#34;, &#34;&#34;) if xray_trace_id else None

    def _extract_log_message(self, log_record: logging.LogRecord) -&gt; Union[Dict[str, Any], str, bool, Iterable]:
        &#34;&#34;&#34;Extract message from log record and attempt to JSON decode it if str

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        message: Union[Dict, str, bool, Iterable]
            Extracted message
        &#34;&#34;&#34;
        message = log_record.msg
        if isinstance(message, dict):
            return message

        if log_record.args:  # logger.info(&#34;foo %s&#34;, &#34;bar&#34;) requires formatting
            return log_record.getMessage()

        if isinstance(message, str):  # could be a JSON string
            try:
                message = self.json_deserializer(message)
            except (json.decoder.JSONDecodeError, TypeError, ValueError):
                pass

        return message

    def _extract_log_exception(self, log_record: logging.LogRecord) -&gt; Union[Tuple[str, str], Tuple[None, None]]:
        &#34;&#34;&#34;Format traceback information, if available

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract message from

        Returns
        -------
        log_record: Optional[Tuple[str, str]]
            Log record with constant traceback info and exception name
        &#34;&#34;&#34;
        if log_record.exc_info:
            return self.formatException(log_record.exc_info), log_record.exc_info[0].__name__  # type: ignore

        return None, None

    def _extract_log_keys(self, log_record: logging.LogRecord) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Extract and parse custom and reserved log keys

        Parameters
        ----------
        log_record : logging.LogRecord
            Log record to extract keys from

        Returns
        -------
        formatted_log: Dict
            Structured log as dictionary
        &#34;&#34;&#34;
        record_dict = log_record.__dict__.copy()
        record_dict[&#34;asctime&#34;] = self.formatTime(record=log_record)
        extras = {k: v for k, v in record_dict.items() if k not in RESERVED_LOG_ATTRS}

        formatted_log = {}

        # Iterate over a default or existing log structure
        # then replace any std log attribute e.g. &#39;%(level)s&#39; to &#39;INFO&#39;, &#39;%(process)d to &#39;4773&#39;
        # lastly add or replace incoming keys (those added within the constructor or .structure_logs method)
        for key, value in self.log_format.items():
            if value and key in RESERVED_LOG_ATTRS:
                formatted_log[key] = value % record_dict
            else:
                formatted_log[key] = value

        formatted_log.update(**extras)
        return formatted_log

    @staticmethod
    def _strip_none_records(records: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Remove any key with None as value&#34;&#34;&#34;
        return {k: v for k, v in records.items() if v is not None}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter">BasePowertoolsFormatter</a></li>
<li>logging.Formatter</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aws_lambda_powertools.logging.formatters.datadog.DatadogLogFormatter" href="formatters/datadog.html#aws_lambda_powertools.logging.formatters.datadog.DatadogLogFormatter">DatadogLogFormatter</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT"><code class="name">var <span class="ident">RFC3339_ISO8601_FORMAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive"><code class="name">var <span class="ident">custom_ms_time_directive</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format"><code class="name">var <span class="ident">default_time_format</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys"><code class="name flex">
<span>def <span class="ident">append_keys</span></span>(<span>self, **additional_keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_keys(self, **additional_keys):
    self.log_format.update(additional_keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, record: logging.LogRecord) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format logging record as structured JSON str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, record: logging.LogRecord) -&gt; str:  # noqa: A003
    &#34;&#34;&#34;Format logging record as structured JSON str&#34;&#34;&#34;
    formatted_log = self._extract_log_keys(log_record=record)
    formatted_log[&#34;message&#34;] = self._extract_log_message(log_record=record)
    # exception and exception_name fields can be added as extra key
    # in any log level, we try to extract and use them first
    extracted_exception, extracted_exception_name = self._extract_log_exception(log_record=record)
    formatted_log[&#34;exception&#34;] = formatted_log.get(&#34;exception&#34;, extracted_exception)
    formatted_log[&#34;exception_name&#34;] = formatted_log.get(&#34;exception_name&#34;, extracted_exception_name)
    formatted_log[&#34;xray_trace_id&#34;] = self._get_latest_trace_id()
    formatted_log = self._strip_none_records(records=formatted_log)

    return self.serialize(log=formatted_log)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime"><code class="name flex">
<span>def <span class="ident">formatTime</span></span>(<span>self, record: logging.LogRecord, datefmt: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the creation time of the specified LogRecord as formatted text.</p>
<p>This method should be called from format() by a formatter which
wants to make use of a formatted time. This method can be overridden
in formatters to provide for any specific requirement, but the
basic behaviour is as follows: if datefmt (a string) is specified,
it is used with time.strftime() to format the creation time of the
record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
The resulting string is returned. This function uses a user-configurable
function to convert the creation time to a tuple. By default,
time.localtime() is used; to change this for a particular formatter
instance, set the 'converter' attribute to a function with the same
signature as time.localtime() or time.gmtime(). To change it for all
formatters, for example if you want all logging times to be shown in GMT,
set the 'converter' attribute in the Formatter class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatTime(self, record: logging.LogRecord, datefmt: Optional[str] = None) -&gt; str:
    # As of Py3.7, we can infer milliseconds directly from any datetime
    # saving processing time as we can shortcircuit early
    # Maintenance: In V3, we (and Java) should move to this format by default
    # since we&#39;ve provided enough time for those migrating from std logging
    if self.use_rfc3339_iso8601:
        if self.utc:
            ts_as_datetime = datetime.fromtimestamp(record.created, tz=timezone.utc)
        else:
            ts_as_datetime = datetime.fromtimestamp(record.created).astimezone()

        return ts_as_datetime.isoformat(timespec=&#34;milliseconds&#34;)  # 2022-10-27T17:42:26.841+0200

    # converts to local/UTC TZ as struct time
    record_ts = self.converter(record.created)

    if datefmt is None:  # pragma: no cover, it&#39;ll always be None in std logging, but mypy
        datefmt = self.datefmt

    # NOTE: Python `time.strftime` doesn&#39;t provide msec directives
    # so we create a custom one (%F) and replace logging record_ts
    # Reason 2 is that std logging doesn&#39;t support msec after TZ
    msecs = &#34;%03d&#34; % record.msecs

    # Datetime format codes is a superset of time format codes
    # therefore we only honour them if explicitly asked
    # by default, those migrating from std logging will use time format codes
    # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
    if self.use_datetime_directive and datefmt:
        # record.msecs are microseconds, divide by 1000 to get milliseconds
        timestamp = record.created + record.msecs / 1000

        if self.utc:
            dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)
        else:
            dt = datetime.fromtimestamp(timestamp).astimezone()

        custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
        return dt.strftime(custom_fmt)

    # Only time format codes being used
    elif datefmt:
        custom_fmt = datefmt.replace(self.custom_ms_time_directive, msecs)
        return time.strftime(custom_fmt, record_ts)

    # Use default fmt: 2021-05-03 10:20:19,650+0200
    custom_fmt = self.default_time_format.replace(self.custom_ms_time_directive, msecs)
    return time.strftime(custom_fmt, record_ts)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys"><code class="name flex">
<span>def <span class="ident">remove_keys</span></span>(<span>self, keys: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keys(self, keys: Iterable[str]):
    for key in keys:
        self.log_format.pop(key, None)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, log: Dict) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize structured log dict to JSON str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, log: Dict) -&gt; str:
    &#34;&#34;&#34;Serialize structured log dict to JSON str&#34;&#34;&#34;
    return self.json_serializer(log)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter">BasePowertoolsFormatter</a></b></code>:
<ul class="hlist">
<li><code><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.clear_state" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.clear_state">clear_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.logging" href="index.html">aws_lambda_powertools.logging</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter">BasePowertoolsFormatter</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.append_keys" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.append_keys">append_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.clear_state" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.clear_state">clear_state</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.remove_keys" href="#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter.remove_keys">remove_keys</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter">LambdaPowertoolsFormatter</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT">RFC3339_ISO8601_FORMAT</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys">append_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.clear_state" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.clear_state">clear_state</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive">custom_ms_time_directive</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format">default_time_format</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format">format</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime">formatTime</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys">remove_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter">LambdaPowertoolsFormatter</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.RFC3339_ISO8601_FORMAT">RFC3339_ISO8601_FORMAT</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.append_keys">append_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.custom_ms_time_directive">custom_ms_time_directive</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.default_time_format">default_time_format</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.format">format</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.formatTime">formatTime</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.remove_keys">remove_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize" href="#aws_lambda_powertools.logging.formatter.LambdaPowertoolsFormatter.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>