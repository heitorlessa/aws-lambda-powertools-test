<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>aws_lambda_powertools.logging.logger API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.logging.logger</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import functools
import inspect
import io
import logging
import os
import random
import sys
import traceback
from typing import (
    IO,
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Mapping,
    Optional,
    TypeVar,
    Union,
    overload,
)

import jmespath

from ..shared import constants
from ..shared.functions import (
    extract_event_from_common_models,
    resolve_env_var_choice,
    resolve_truthy_env_var_choice,
)
from ..shared.types import AnyCallableT
from .exceptions import InvalidLoggerSamplingRateError
from .filters import SuppressFilter
from .formatter import (
    RESERVED_FORMATTER_CUSTOM_KEYS,
    BasePowertoolsFormatter,
    LambdaPowertoolsFormatter,
)
from .lambda_context import build_lambda_context_model

logger = logging.getLogger(__name__)

is_cold_start = True

PowertoolsFormatter = TypeVar(&#34;PowertoolsFormatter&#34;, bound=BasePowertoolsFormatter)


def _is_cold_start() -&gt; bool:
    &#34;&#34;&#34;Verifies whether is cold start

    Returns
    -------
    bool
        cold start bool value
    &#34;&#34;&#34;
    cold_start = False

    global is_cold_start
    if is_cold_start:
        cold_start = is_cold_start
        is_cold_start = False

    return cold_start


# PyCharm does not support autocomplete via getattr
# so we need to return to subclassing removed in #97
# All methods/properties continue to be proxied to inner logger
# https://github.com/awslabs/aws-lambda-powertools-python/issues/107
# noinspection PyRedeclaration
class Logger(logging.Logger):  # lgtm [py/missing-call-to-init]
    &#34;&#34;&#34;Creates and setups a logger to format statements in JSON.

    Includes service name and any additional key=value into logs
    It also accepts both service name or level explicitly via env vars

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME : str
        service name
    LOG_LEVEL: str
        logging level (e.g. INFO, DEBUG)
    POWERTOOLS_LOGGER_SAMPLE_RATE: float
        sampling rate ranging from 0 to 1, 1 being 100% sampling

    Parameters
    ----------
    service : str, optional
        service name to be appended in logs, by default &#34;service_undefined&#34;
    level : str, int optional
        logging.level, by default &#34;INFO&#34;
    child: bool, optional
        create a child Logger named &lt;service&gt;.&lt;caller_file_name&gt;, False by default
    sample_rate: float, optional
        sample rate for debug calls within execution context defaults to 0.0
    stream: sys.stdout, optional
        valid output for a logging stream, by default sys.stdout
    logger_formatter: PowertoolsFormatter, optional
        custom logging formatter that implements PowertoolsFormatter
    logger_handler: logging.Handler, optional
        custom logging handler e.g. logging.FileHandler(&#34;file.log&#34;)
    log_uncaught_exceptions: bool, by default False
        logs uncaught exception using sys.excepthook

        See: https://docs.python.org/3/library/sys.html#sys.excepthook


    Parameters propagated to LambdaPowertoolsFormatter
    --------------------------------------------------
    datefmt: str, optional
        String directives (strftime) to format log timestamp using `time`, by default it uses 2021-05-03 11:47:12,494+0200. # noqa: E501
    use_datetime_directive: bool, optional
        Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
        `time.strftime`.

        See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
        also supports a custom %F directive for milliseconds.
    use_rfc3339: bool, optional
        Whether to use a popular date format that complies with both RFC3339 and ISO8601.
        e.g., 2022-10-27T16:27:43.738+02:00.
    json_serializer : Callable, optional
        function to serialize `obj` to a JSON formatted `str`, by default json.dumps
    json_deserializer : Callable, optional
        function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
        by default json.loads
    json_default : Callable, optional
        function to coerce unserializable values, by default `str()`

        Only used when no custom formatter is set
    utc : bool, optional
        set logging timestamp to UTC, by default False to continue to use local time as per stdlib
    log_record_order : list, optional
        set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]

    Example
    -------
    **Setups structured logging in JSON for Lambda functions with explicit service name**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Setups structured logging in JSON for Lambda functions using env vars**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        $ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger()
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Append payment_id to previously setup logger**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.append_keys(payment_id=event[&#34;payment_id&#34;])
                logger.info(&#34;Hello&#34;)

    **Create child Logger using logging inheritance via child param**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import another_file
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # another_file.py
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, child=True)

    **Logging in UTC timezone**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, utc=True)

    **Brings message as the first key in log statements**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, log_record_order=[&#34;message&#34;])

    **Logging to a file instead of standard output for testing**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, logger_handler=logging.FileHandler(&#34;log.json&#34;))

    Raises
    ------
    InvalidLoggerSamplingRateError
        When sampling rate provided is not a float
    &#34;&#34;&#34;

    def __init__(
        self,
        service: Optional[str] = None,
        level: Union[str, int, None] = None,
        child: bool = False,
        sampling_rate: Optional[float] = None,
        stream: Optional[IO[str]] = None,
        logger_formatter: Optional[PowertoolsFormatter] = None,
        logger_handler: Optional[logging.Handler] = None,
        log_uncaught_exceptions: bool = False,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        self.service = resolve_env_var_choice(
            choice=service, env=os.getenv(constants.SERVICE_NAME_ENV, &#34;service_undefined&#34;)
        )
        self.sampling_rate = resolve_env_var_choice(
            choice=sampling_rate, env=os.getenv(constants.LOGGER_LOG_SAMPLING_RATE)
        )
        self.child = child
        self.logger_formatter = logger_formatter
        self.logger_handler = logger_handler or logging.StreamHandler(stream)
        self.log_uncaught_exceptions = log_uncaught_exceptions

        self.log_level = self._get_log_level(level)
        self._is_deduplication_disabled = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_DEDUPLICATION_ENV, &#34;false&#34;)
        )
        self._default_log_keys = {&#34;service&#34;: self.service, &#34;sampling_rate&#34;: self.sampling_rate}
        self._logger = self._get_logger()

        # NOTE: This is primarily to improve UX, so IDEs can autocomplete LambdaPowertoolsFormatter options
        # previously, we masked all of them as kwargs thus limiting feature discovery
        formatter_options = {
            &#34;json_serializer&#34;: json_serializer,
            &#34;json_deserializer&#34;: json_deserializer,
            &#34;json_default&#34;: json_default,
            &#34;datefmt&#34;: datefmt,
            &#34;use_datetime_directive&#34;: use_datetime_directive,
            &#34;log_record_order&#34;: log_record_order,
            &#34;utc&#34;: utc,
            &#34;use_rfc3339&#34;: use_rfc3339,
        }

        self._init_logger(formatter_options=formatter_options, **kwargs)

        if self.log_uncaught_exceptions:
            logger.debug(&#34;Replacing exception hook&#34;)
            sys.excepthook = functools.partial(log_uncaught_exception_hook, logger=self)

    # Prevent __getattr__ from shielding unknown attribute errors in type checkers
    # https://github.com/awslabs/aws-lambda-powertools-python/issues/1660
    if not TYPE_CHECKING:

        def __getattr__(self, name):
            # Proxy attributes not found to actual logger to support backward compatibility
            # https://github.com/awslabs/aws-lambda-powertools-python/issues/97
            return getattr(self._logger, name)

    def _get_logger(self):
        &#34;&#34;&#34;Returns a Logger named {self.service}, or {self.service.filename} for child loggers&#34;&#34;&#34;
        logger_name = self.service
        if self.child:
            logger_name = f&#34;{self.service}.{self._get_caller_filename()}&#34;

        return logging.getLogger(logger_name)

    def _init_logger(self, formatter_options: Optional[Dict] = None, **kwargs):
        &#34;&#34;&#34;Configures new logger&#34;&#34;&#34;

        # Skip configuration if it&#39;s a child logger or a pre-configured logger
        # to prevent the following:
        #   a) multiple handlers being attached
        #   b) different sampling mechanisms
        #   c) multiple messages from being logged as handlers can be duplicated
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if self.child or is_logger_preconfigured:
            return

        self._configure_sampling()
        self._logger.setLevel(self.log_level)
        self._logger.addHandler(self.logger_handler)
        self.structure_logs(formatter_options=formatter_options, **kwargs)

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        self._logger.findCaller = self.findCaller

        # Pytest Live Log feature duplicates log records for colored output
        # but we explicitly add a filter for log deduplication.
        # This flag disables this protection when you explicit want logs to be duplicated (#262)
        if not self._is_deduplication_disabled:
            logger.debug(&#34;Adding filter in root logger to suppress child logger records to bubble up&#34;)
            for handler in logging.root.handlers:
                # It&#39;ll add a filter to suppress any child logger from self.service
                # Example: `Logger(service=&#34;order&#34;)`, where service is Order
                # It&#39;ll reject all loggers starting with `order` e.g. order.checkout, order.shared
                handler.addFilter(SuppressFilter(self.service))

        # as per bug in #249, we should not be pre-configuring an existing logger
        # therefore we set a custom attribute in the Logger that will be returned
        # std logging will return the same Logger with our attribute if name is reused
        logger.debug(f&#34;Marking logger {self.service} as preconfigured&#34;)
        self._logger.init = True

    def _configure_sampling(self):
        &#34;&#34;&#34;Dynamically set log level based on sampling rate

        Raises
        ------
        InvalidLoggerSamplingRateError
            When sampling rate provided is not a float
        &#34;&#34;&#34;
        try:
            if self.sampling_rate and random.random() &lt;= float(self.sampling_rate):
                logger.debug(&#34;Setting log level to Debug due to sampling rate&#34;)
                self.log_level = logging.DEBUG
        except ValueError:
            raise InvalidLoggerSamplingRateError(
                f&#34;Expected a float value ranging 0 to 1, but received {self.sampling_rate} instead.&#34;
                f&#34;Please review POWERTOOLS_LOGGER_SAMPLE_RATE environment variable.&#34;
            )

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: AnyCallableT,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; AnyCallableT:
        ...

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: None = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Callable[[AnyCallableT], AnyCallableT]:
        ...

    def inject_lambda_context(
        self,
        lambda_handler: Optional[AnyCallableT] = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into logger

        Parameters
        ----------
        clear_state : bool, optional
            Instructs logger to remove any custom keys previously added
        lambda_handler : Callable
            Method to inject the lambda context
        log_event : bool, optional
            Instructs logger to log Lambda Event, by default False
        correlation_id_path: str, optional
            Optional JMESPath for the correlation_id

        Environment variables
        ---------------------
        POWERTOOLS_LOGGER_LOG_EVENT : str
            instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

        Example
        -------
        **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        **Captures Lambda contextual runtime info and logs incoming request**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context(log_event=True)
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        Returns
        -------
        decorate : Callable
            Decorated lambda handler
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.inject_lambda_context,
                log_event=log_event,
                correlation_id_path=correlation_id_path,
                clear_state=clear_state,
            )

        log_event = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_EVENT_ENV, &#34;false&#34;), choice=log_event
        )

        @functools.wraps(lambda_handler)
        def decorate(event, context, *args, **kwargs):
            lambda_context = build_lambda_context_model(context)
            cold_start = _is_cold_start()

            if clear_state:
                self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
            else:
                self.append_keys(cold_start=cold_start, **lambda_context.__dict__)

            if correlation_id_path:
                self.set_correlation_id(jmespath.search(correlation_id_path, event))

            if log_event:
                logger.debug(&#34;Event received&#34;)
                self.info(extract_event_from_common_models(event))

            return lambda_handler(event, context, *args, **kwargs)

        return decorate

    def info(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.info(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.info(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def error(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.error(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.error(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def exception(
        self,
        msg: object,
        *args,
        exc_info=True,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.exception(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.exception(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def critical(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.critical(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.critical(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def warning(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.warning(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.warning(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def debug(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.debug(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.debug(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def append_keys(self, **additional_keys):
        self.registered_formatter.append_keys(**additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        self.registered_formatter.remove_keys(keys)

    @property
    def registered_handler(self) -&gt; logging.Handler:
        &#34;&#34;&#34;Convenience property to access logger handler&#34;&#34;&#34;
        handlers = self._logger.parent.handlers if self.child else self._logger.handlers
        return handlers[0]

    @property
    def registered_formatter(self) -&gt; BasePowertoolsFormatter:
        &#34;&#34;&#34;Convenience property to access logger formatter&#34;&#34;&#34;
        return self.registered_handler.formatter  # type: ignore

    def structure_logs(self, append: bool = False, formatter_options: Optional[Dict] = None, **keys):
        &#34;&#34;&#34;Sets logging formatting to JSON.

        Optionally, it can append keyword arguments
        to an existing logger, so it is available across future log statements.

        Last keyword argument and value wins if duplicated.

        Parameters
        ----------
        append : bool, optional
            append keys provided to logger formatter, by default False
        formatter_options : dict, optional
            LambdaPowertoolsFormatter options to be propagated, by default {}
        &#34;&#34;&#34;
        formatter_options = formatter_options or {}

        # There are 3 operational modes for this method
        ## 1. Register a Powertools Formatter for the first time
        ## 2. Append new keys to the current logger formatter; deprecated in favour of append_keys
        ## 3. Add new keys and discard existing to the registered formatter

        # Mode 1
        log_keys = {**self._default_log_keys, **keys}
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if not is_logger_preconfigured:
            formatter = self.logger_formatter or LambdaPowertoolsFormatter(**formatter_options, **log_keys)  # type: ignore # noqa: E501
            self.registered_handler.setFormatter(formatter)

            # when using a custom Lambda Powertools Formatter
            # standard and custom keys that are not Powertools Formatter parameters should be appended
            # and custom keys that might happen to be Powertools Formatter parameters should be discarded
            # this prevents adding them as custom keys, for example, `json_default=&lt;callable&gt;`
            # see https://github.com/awslabs/aws-lambda-powertools-python/issues/1263
            custom_keys = {k: v for k, v in log_keys.items() if k not in RESERVED_FORMATTER_CUSTOM_KEYS}
            return self.registered_formatter.append_keys(**custom_keys)

        # Mode 2 (legacy)
        if append:
            # Maintenance: Add deprecation warning for major version
            return self.append_keys(**keys)

        # Mode 3
        self.registered_formatter.clear_state()
        self.registered_formatter.append_keys(**log_keys)

    def set_correlation_id(self, value: Optional[str]):
        &#34;&#34;&#34;Sets the correlation_id in the logging json

        Parameters
        ----------
        value : str, optional
            Value for the correlation id. None will remove the correlation_id
        &#34;&#34;&#34;
        self.append_keys(correlation_id=value)

    def get_correlation_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Gets the correlation_id in the logging json

        Returns
        -------
        str, optional
            Value for the correlation id
        &#34;&#34;&#34;
        if isinstance(self.registered_formatter, LambdaPowertoolsFormatter):
            return self.registered_formatter.log_format.get(&#34;correlation_id&#34;)
        return None

    @staticmethod
    def _get_log_level(level: Union[str, int, None]) -&gt; Union[str, int]:
        &#34;&#34;&#34;Returns preferred log level set by the customer in upper case&#34;&#34;&#34;
        if isinstance(level, int):
            return level

        log_level: Optional[str] = level or os.getenv(&#34;LOG_LEVEL&#34;)
        if log_level is None:
            return logging.INFO

        return log_level.upper()

    @staticmethod
    def _get_caller_filename():
        &#34;&#34;&#34;Return caller filename by finding the caller frame&#34;&#34;&#34;
        # Current frame         =&gt; _get_logger()
        # Previous frame        =&gt; logger.py
        # Before previous frame =&gt; Caller
        frame = inspect.currentframe()
        caller_frame = frame.f_back.f_back.f_back
        return caller_frame.f_globals[&#34;__name__&#34;]

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    def findCaller(self, stack_info=False, stacklevel=2):  # pragma: no cover
        &#34;&#34;&#34;
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        &#34;&#34;&#34;
        f = logging.currentframe()  # noqa: VNE001
        # On some versions of IronPython, currentframe() returns None if
        # IronPython isn&#39;t run with -X:Frames.
        if f is None:
            return &#34;(unknown file)&#34;, 0, &#34;(unknown function)&#34;, None
        while stacklevel &gt; 0:
            next_f = f.f_back
            if next_f is None:
                ## We&#39;ve got options here.
                ## If we want to use the last (deepest) frame:
                break
                ## If we want to mimic the warnings module:
                # return (&#34;sys&#34;, 1, &#34;(unknown function)&#34;, None) # noqa: E800
                ## If we want to be pedantic:  # noqa: E800
                # raise ValueError(&#34;call stack is not deep enough&#34;) # noqa: E800
            f = next_f  # noqa: VNE001
            if not _is_internal_frame(f):
                stacklevel -= 1
        co = f.f_code
        sinfo = None
        if stack_info:
            with io.StringIO() as sio:
                sio.write(&#34;Stack (most recent call last):\n&#34;)
                traceback.print_stack(f, file=sio)
                sinfo = sio.getvalue()
                if sinfo[-1] == &#34;\n&#34;:
                    sinfo = sinfo[:-1]
        return co.co_filename, f.f_lineno, co.co_name, sinfo


def set_package_logger(
    level: Union[str, int] = logging.DEBUG,
    stream: Optional[IO[str]] = None,
    formatter: Optional[logging.Formatter] = None,
):
    &#34;&#34;&#34;Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.

    **Package log by default is suppressed (NullHandler), this should only used for debugging.
    This is separate from application Logger class utility**

    Example
    -------
    **Enables debug logging for AWS Lambda Powertools package**

        &gt;&gt;&gt; aws_lambda_powertools.logging.logger import set_package_logger
        &gt;&gt;&gt; set_package_logger()

    Parameters
    ----------
    level: str, int
        log level, DEBUG by default
    stream: sys.stdout
        log stream, stdout by default
    formatter: logging.Formatter
        log formatter, &#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34; by default
    &#34;&#34;&#34;
    if formatter is None:
        formatter = logging.Formatter(&#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34;)

    if stream is None:
        stream = sys.stdout

    logger = logging.getLogger(&#34;aws_lambda_powertools&#34;)
    logger.setLevel(level)
    handler = logging.StreamHandler(stream)
    handler.setFormatter(formatter)
    logger.addHandler(handler)


# Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
# The following is based on warnings._is_internal_frame. It makes sure that
# frames of the import mechanism are skipped when logging at module level and
# using a stacklevel value greater than one.
def _is_internal_frame(frame):  # pragma: no cover
    &#34;&#34;&#34;Signal whether the frame is a CPython or logging module internal.&#34;&#34;&#34;
    filename = os.path.normcase(frame.f_code.co_filename)
    return filename == logging._srcfile or (&#34;importlib&#34; in filename and &#34;_bootstrap&#34; in filename)


def log_uncaught_exception_hook(exc_type, exc_value, exc_traceback, logger: Logger):
    &#34;&#34;&#34;Callback function for sys.excepthook to use Logger to log uncaught exceptions&#34;&#34;&#34;
    logger.exception(exc_value, exc_info=(exc_type, exc_value, exc_traceback))  # pragma: no cover</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.logging.logger.log_uncaught_exception_hook"><code class="name flex">
<span>def <span class="ident">log_uncaught_exception_hook</span></span>(<span>exc_type, exc_value, exc_traceback, logger: <a title="aws_lambda_powertools.logging.logger.Logger" href="#aws_lambda_powertools.logging.logger.Logger">Logger</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function for sys.excepthook to use Logger to log uncaught exceptions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_uncaught_exception_hook(exc_type, exc_value, exc_traceback, logger: Logger):
    &#34;&#34;&#34;Callback function for sys.excepthook to use Logger to log uncaught exceptions&#34;&#34;&#34;
    logger.exception(exc_value, exc_info=(exc_type, exc_value, exc_traceback))  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.set_package_logger"><code class="name flex">
<span>def <span class="ident">set_package_logger</span></span>(<span>level: Union[str, int] = 10, stream: Optional[IO[str]] = None, formatter: Optional[logging.Formatter] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.</p>
<p><strong>Package log by default is suppressed (NullHandler), this should only used for debugging.
This is separate from application Logger class utility</strong></p>
<h2 id="example">Example</h2>
<p><strong>Enables debug logging for AWS Lambda Powertools package</strong></p>
<pre><code>&gt;&gt;&gt; aws_lambda_powertools.logging.logger import set_package_logger
&gt;&gt;&gt; set_package_logger()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str, int</code></dt>
<dd>log level, DEBUG by default</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code></dt>
<dd>log stream, stdout by default</dd>
<dt><strong><code>formatter</code></strong> :&ensp;<code>logging.Formatter</code></dt>
<dd>log formatter, "%(asctime)s %(name)s [%(levelname)s] %(message)s" by default</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_package_logger(
    level: Union[str, int] = logging.DEBUG,
    stream: Optional[IO[str]] = None,
    formatter: Optional[logging.Formatter] = None,
):
    &#34;&#34;&#34;Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.

    **Package log by default is suppressed (NullHandler), this should only used for debugging.
    This is separate from application Logger class utility**

    Example
    -------
    **Enables debug logging for AWS Lambda Powertools package**

        &gt;&gt;&gt; aws_lambda_powertools.logging.logger import set_package_logger
        &gt;&gt;&gt; set_package_logger()

    Parameters
    ----------
    level: str, int
        log level, DEBUG by default
    stream: sys.stdout
        log stream, stdout by default
    formatter: logging.Formatter
        log formatter, &#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34; by default
    &#34;&#34;&#34;
    if formatter is None:
        formatter = logging.Formatter(&#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34;)

    if stream is None:
        stream = sys.stdout

    logger = logging.getLogger(&#34;aws_lambda_powertools&#34;)
    logger.setLevel(level)
    handler = logging.StreamHandler(stream)
    handler.setFormatter(formatter)
    logger.addHandler(handler)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.logging.logger.Logger"><code class="flex name class">
<span>class <span class="ident">Logger</span></span>
<span>(</span><span>service: Optional[str] = None, level: Union[str, int, None] = None, child: bool = False, sampling_rate: Optional[float] = None, stream: Optional[IO[str]] = None, logger_formatter: Optional[PowertoolsFormatter] = None, logger_handler: Optional[logging.Handler] = None, log_uncaught_exceptions: bool = False, json_serializer: Optional[Callable[[Dict], str]] = None, json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None, json_default: Optional[Callable[[Any], Any]] = None, datefmt: Optional[str] = None, use_datetime_directive: bool = False, log_record_order: Optional[List[str]] = None, utc: bool = False, use_rfc3339: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and setups a logger to format statements in JSON.</p>
<p>Includes service name and any additional key=value into logs
It also accepts both service name or level explicitly via env vars</p>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_SERVICE_NAME : str
service name
LOG_LEVEL: str
logging level (e.g. INFO, DEBUG)
POWERTOOLS_LOGGER_SAMPLE_RATE: float
sampling rate ranging from 0 to 1, 1 being 100% sampling</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name to be appended in logs, by default "service_undefined"</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str, int optional</code></dt>
<dd>logging.level, by default "INFO"</dd>
<dt><strong><code>child</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>create a child Logger named <service>.<caller_file_name>, False by default</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>sample rate for debug calls within execution context defaults to 0.0</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code>, optional</dt>
<dd>valid output for a logging stream, by default sys.stdout</dd>
<dt><strong><code>logger_formatter</code></strong> :&ensp;<code>PowertoolsFormatter</code>, optional</dt>
<dd>custom logging formatter that implements PowertoolsFormatter</dd>
<dt><strong><code>logger_handler</code></strong> :&ensp;<code>logging.Handler</code>, optional</dt>
<dd>custom logging handler e.g. logging.FileHandler("file.log")</dd>
<dt><strong><code>log_uncaught_exceptions</code></strong> :&ensp;<code>bool, by default False</code></dt>
<dd>
<p>logs uncaught exception using sys.excepthook</p>
<p>See: <a href="https://docs.python.org/3/library/sys.html#sys.excepthook">https://docs.python.org/3/library/sys.html#sys.excepthook</a></p>
</dd>
</dl>
<h2 id="parameters-propagated-to-lambdapowertoolsformatter">Parameters Propagated To Lambdapowertoolsformatter</h2>
<p>datefmt: str, optional
String directives (strftime) to format log timestamp using <code>time</code>, by default it uses 2021-05-03 11:47:12,494+0200. # noqa: E501
use_datetime_directive: bool, optional
Interpret <code>datefmt</code> as a format string for <code>datetime.datetime.strftime</code>, rather than
<code>time.strftime</code>.</p>
<pre><code>See &lt;https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior&gt; . This
also supports a custom %F directive for milliseconds.
</code></pre>
<p>use_rfc3339: bool, optional
Whether to use a popular date format that complies with both RFC3339 and ISO8601.
e.g., 2022-10-27T16:27:43.738+02:00.
json_serializer : Callable, optional
function to serialize <code>obj</code> to a JSON formatted <code>str</code>, by default json.dumps
json_deserializer : Callable, optional
function to deserialize <code>str</code>, <code>bytes</code>, bytearray<code> containing a JSON document to a Python </code>obj`,
by default json.loads
json_default : Callable, optional
function to coerce unserializable values, by default <code>str()</code></p>
<pre><code>Only used when no custom formatter is set
</code></pre>
<p>utc : bool, optional
set logging timestamp to UTC, by default False to continue to use local time as per stdlib
log_record_order : list, optional
set order of log keys when logging, by default ["level", "location", "message", "timestamp"]</p>
<h2 id="example">Example</h2>
<p><strong>Setups structured logging in JSON for Lambda functions with explicit service name</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Setups structured logging in JSON for Lambda functions using env vars</strong></p>
<pre><code>$ export POWERTOOLS_SERVICE_NAME="payment"
$ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger()
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Append payment_id to previously setup logger</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.append_keys(payment_id=event["payment_id"])
        logger.info("Hello")
</code></pre>
<p><strong>Create child Logger using logging inheritance via child param</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import another_file
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; # another_file.py
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment", child=True)
</code></pre>
<p><strong>Logging in UTC timezone</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", utc=True)
</code></pre>
<p><strong>Brings message as the first key in log statements</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", log_record_order=["message"])
</code></pre>
<p><strong>Logging to a file instead of standard output for testing</strong></p>
<pre><code>&gt;&gt;&gt; # app.py
&gt;&gt;&gt; import logging
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt;
&gt;&gt;&gt; logger = Logger(service="payment", logger_handler=logging.FileHandler("log.json"))
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidLoggerSamplingRateError</code></dt>
<dd>When sampling rate provided is not a float</dd>
</dl>
<p>Initialize the logger with a name and an optional level.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Logger(logging.Logger):  # lgtm [py/missing-call-to-init]
    &#34;&#34;&#34;Creates and setups a logger to format statements in JSON.

    Includes service name and any additional key=value into logs
    It also accepts both service name or level explicitly via env vars

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME : str
        service name
    LOG_LEVEL: str
        logging level (e.g. INFO, DEBUG)
    POWERTOOLS_LOGGER_SAMPLE_RATE: float
        sampling rate ranging from 0 to 1, 1 being 100% sampling

    Parameters
    ----------
    service : str, optional
        service name to be appended in logs, by default &#34;service_undefined&#34;
    level : str, int optional
        logging.level, by default &#34;INFO&#34;
    child: bool, optional
        create a child Logger named &lt;service&gt;.&lt;caller_file_name&gt;, False by default
    sample_rate: float, optional
        sample rate for debug calls within execution context defaults to 0.0
    stream: sys.stdout, optional
        valid output for a logging stream, by default sys.stdout
    logger_formatter: PowertoolsFormatter, optional
        custom logging formatter that implements PowertoolsFormatter
    logger_handler: logging.Handler, optional
        custom logging handler e.g. logging.FileHandler(&#34;file.log&#34;)
    log_uncaught_exceptions: bool, by default False
        logs uncaught exception using sys.excepthook

        See: https://docs.python.org/3/library/sys.html#sys.excepthook


    Parameters propagated to LambdaPowertoolsFormatter
    --------------------------------------------------
    datefmt: str, optional
        String directives (strftime) to format log timestamp using `time`, by default it uses 2021-05-03 11:47:12,494+0200. # noqa: E501
    use_datetime_directive: bool, optional
        Interpret `datefmt` as a format string for `datetime.datetime.strftime`, rather than
        `time.strftime`.

        See https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior . This
        also supports a custom %F directive for milliseconds.
    use_rfc3339: bool, optional
        Whether to use a popular date format that complies with both RFC3339 and ISO8601.
        e.g., 2022-10-27T16:27:43.738+02:00.
    json_serializer : Callable, optional
        function to serialize `obj` to a JSON formatted `str`, by default json.dumps
    json_deserializer : Callable, optional
        function to deserialize `str`, `bytes`, bytearray` containing a JSON document to a Python `obj`,
        by default json.loads
    json_default : Callable, optional
        function to coerce unserializable values, by default `str()`

        Only used when no custom formatter is set
    utc : bool, optional
        set logging timestamp to UTC, by default False to continue to use local time as per stdlib
    log_record_order : list, optional
        set order of log keys when logging, by default [&#34;level&#34;, &#34;location&#34;, &#34;message&#34;, &#34;timestamp&#34;]

    Example
    -------
    **Setups structured logging in JSON for Lambda functions with explicit service name**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Setups structured logging in JSON for Lambda functions using env vars**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        $ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger()
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Append payment_id to previously setup logger**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.append_keys(payment_id=event[&#34;payment_id&#34;])
                logger.info(&#34;Hello&#34;)

    **Create child Logger using logging inheritance via child param**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import another_file
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; # another_file.py
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, child=True)

    **Logging in UTC timezone**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, utc=True)

    **Brings message as the first key in log statements**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, log_record_order=[&#34;message&#34;])

    **Logging to a file instead of standard output for testing**

        &gt;&gt;&gt; # app.py
        &gt;&gt;&gt; import logging
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt;
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;, logger_handler=logging.FileHandler(&#34;log.json&#34;))

    Raises
    ------
    InvalidLoggerSamplingRateError
        When sampling rate provided is not a float
    &#34;&#34;&#34;

    def __init__(
        self,
        service: Optional[str] = None,
        level: Union[str, int, None] = None,
        child: bool = False,
        sampling_rate: Optional[float] = None,
        stream: Optional[IO[str]] = None,
        logger_formatter: Optional[PowertoolsFormatter] = None,
        logger_handler: Optional[logging.Handler] = None,
        log_uncaught_exceptions: bool = False,
        json_serializer: Optional[Callable[[Dict], str]] = None,
        json_deserializer: Optional[Callable[[Union[Dict, str, bool, int, float]], str]] = None,
        json_default: Optional[Callable[[Any], Any]] = None,
        datefmt: Optional[str] = None,
        use_datetime_directive: bool = False,
        log_record_order: Optional[List[str]] = None,
        utc: bool = False,
        use_rfc3339: bool = False,
        **kwargs,
    ):
        self.service = resolve_env_var_choice(
            choice=service, env=os.getenv(constants.SERVICE_NAME_ENV, &#34;service_undefined&#34;)
        )
        self.sampling_rate = resolve_env_var_choice(
            choice=sampling_rate, env=os.getenv(constants.LOGGER_LOG_SAMPLING_RATE)
        )
        self.child = child
        self.logger_formatter = logger_formatter
        self.logger_handler = logger_handler or logging.StreamHandler(stream)
        self.log_uncaught_exceptions = log_uncaught_exceptions

        self.log_level = self._get_log_level(level)
        self._is_deduplication_disabled = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_DEDUPLICATION_ENV, &#34;false&#34;)
        )
        self._default_log_keys = {&#34;service&#34;: self.service, &#34;sampling_rate&#34;: self.sampling_rate}
        self._logger = self._get_logger()

        # NOTE: This is primarily to improve UX, so IDEs can autocomplete LambdaPowertoolsFormatter options
        # previously, we masked all of them as kwargs thus limiting feature discovery
        formatter_options = {
            &#34;json_serializer&#34;: json_serializer,
            &#34;json_deserializer&#34;: json_deserializer,
            &#34;json_default&#34;: json_default,
            &#34;datefmt&#34;: datefmt,
            &#34;use_datetime_directive&#34;: use_datetime_directive,
            &#34;log_record_order&#34;: log_record_order,
            &#34;utc&#34;: utc,
            &#34;use_rfc3339&#34;: use_rfc3339,
        }

        self._init_logger(formatter_options=formatter_options, **kwargs)

        if self.log_uncaught_exceptions:
            logger.debug(&#34;Replacing exception hook&#34;)
            sys.excepthook = functools.partial(log_uncaught_exception_hook, logger=self)

    # Prevent __getattr__ from shielding unknown attribute errors in type checkers
    # https://github.com/awslabs/aws-lambda-powertools-python/issues/1660
    if not TYPE_CHECKING:

        def __getattr__(self, name):
            # Proxy attributes not found to actual logger to support backward compatibility
            # https://github.com/awslabs/aws-lambda-powertools-python/issues/97
            return getattr(self._logger, name)

    def _get_logger(self):
        &#34;&#34;&#34;Returns a Logger named {self.service}, or {self.service.filename} for child loggers&#34;&#34;&#34;
        logger_name = self.service
        if self.child:
            logger_name = f&#34;{self.service}.{self._get_caller_filename()}&#34;

        return logging.getLogger(logger_name)

    def _init_logger(self, formatter_options: Optional[Dict] = None, **kwargs):
        &#34;&#34;&#34;Configures new logger&#34;&#34;&#34;

        # Skip configuration if it&#39;s a child logger or a pre-configured logger
        # to prevent the following:
        #   a) multiple handlers being attached
        #   b) different sampling mechanisms
        #   c) multiple messages from being logged as handlers can be duplicated
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if self.child or is_logger_preconfigured:
            return

        self._configure_sampling()
        self._logger.setLevel(self.log_level)
        self._logger.addHandler(self.logger_handler)
        self.structure_logs(formatter_options=formatter_options, **kwargs)

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        self._logger.findCaller = self.findCaller

        # Pytest Live Log feature duplicates log records for colored output
        # but we explicitly add a filter for log deduplication.
        # This flag disables this protection when you explicit want logs to be duplicated (#262)
        if not self._is_deduplication_disabled:
            logger.debug(&#34;Adding filter in root logger to suppress child logger records to bubble up&#34;)
            for handler in logging.root.handlers:
                # It&#39;ll add a filter to suppress any child logger from self.service
                # Example: `Logger(service=&#34;order&#34;)`, where service is Order
                # It&#39;ll reject all loggers starting with `order` e.g. order.checkout, order.shared
                handler.addFilter(SuppressFilter(self.service))

        # as per bug in #249, we should not be pre-configuring an existing logger
        # therefore we set a custom attribute in the Logger that will be returned
        # std logging will return the same Logger with our attribute if name is reused
        logger.debug(f&#34;Marking logger {self.service} as preconfigured&#34;)
        self._logger.init = True

    def _configure_sampling(self):
        &#34;&#34;&#34;Dynamically set log level based on sampling rate

        Raises
        ------
        InvalidLoggerSamplingRateError
            When sampling rate provided is not a float
        &#34;&#34;&#34;
        try:
            if self.sampling_rate and random.random() &lt;= float(self.sampling_rate):
                logger.debug(&#34;Setting log level to Debug due to sampling rate&#34;)
                self.log_level = logging.DEBUG
        except ValueError:
            raise InvalidLoggerSamplingRateError(
                f&#34;Expected a float value ranging 0 to 1, but received {self.sampling_rate} instead.&#34;
                f&#34;Please review POWERTOOLS_LOGGER_SAMPLE_RATE environment variable.&#34;
            )

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: AnyCallableT,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; AnyCallableT:
        ...

    @overload
    def inject_lambda_context(
        self,
        lambda_handler: None = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Callable[[AnyCallableT], AnyCallableT]:
        ...

    def inject_lambda_context(
        self,
        lambda_handler: Optional[AnyCallableT] = None,
        log_event: Optional[bool] = None,
        correlation_id_path: Optional[str] = None,
        clear_state: Optional[bool] = False,
    ) -&gt; Any:
        &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into logger

        Parameters
        ----------
        clear_state : bool, optional
            Instructs logger to remove any custom keys previously added
        lambda_handler : Callable
            Method to inject the lambda context
        log_event : bool, optional
            Instructs logger to log Lambda Event, by default False
        correlation_id_path: str, optional
            Optional JMESPath for the correlation_id

        Environment variables
        ---------------------
        POWERTOOLS_LOGGER_LOG_EVENT : str
            instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

        Example
        -------
        **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        **Captures Lambda contextual runtime info and logs incoming request**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context(log_event=True)
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        Returns
        -------
        decorate : Callable
            Decorated lambda handler
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(
                self.inject_lambda_context,
                log_event=log_event,
                correlation_id_path=correlation_id_path,
                clear_state=clear_state,
            )

        log_event = resolve_truthy_env_var_choice(
            env=os.getenv(constants.LOGGER_LOG_EVENT_ENV, &#34;false&#34;), choice=log_event
        )

        @functools.wraps(lambda_handler)
        def decorate(event, context, *args, **kwargs):
            lambda_context = build_lambda_context_model(context)
            cold_start = _is_cold_start()

            if clear_state:
                self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
            else:
                self.append_keys(cold_start=cold_start, **lambda_context.__dict__)

            if correlation_id_path:
                self.set_correlation_id(jmespath.search(correlation_id_path, event))

            if log_event:
                logger.debug(&#34;Event received&#34;)
                self.info(extract_event_from_common_models(event))

            return lambda_handler(event, context, *args, **kwargs)

        return decorate

    def info(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.info(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.info(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def error(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.error(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.error(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def exception(
        self,
        msg: object,
        *args,
        exc_info=True,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.exception(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.exception(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def critical(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.critical(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.critical(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def warning(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.warning(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.warning(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def debug(
        self,
        msg: object,
        *args,
        exc_info=None,
        stack_info: bool = False,
        stacklevel: int = 2,
        extra: Optional[Mapping[str, object]] = None,
        **kwargs,
    ):
        extra = extra or {}
        extra = {**extra, **kwargs}

        # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
        if sys.version_info &lt; (3, 8):  # pragma: no cover
            return self._logger.debug(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
        return self._logger.debug(
            msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
        )

    def append_keys(self, **additional_keys):
        self.registered_formatter.append_keys(**additional_keys)

    def remove_keys(self, keys: Iterable[str]):
        self.registered_formatter.remove_keys(keys)

    @property
    def registered_handler(self) -&gt; logging.Handler:
        &#34;&#34;&#34;Convenience property to access logger handler&#34;&#34;&#34;
        handlers = self._logger.parent.handlers if self.child else self._logger.handlers
        return handlers[0]

    @property
    def registered_formatter(self) -&gt; BasePowertoolsFormatter:
        &#34;&#34;&#34;Convenience property to access logger formatter&#34;&#34;&#34;
        return self.registered_handler.formatter  # type: ignore

    def structure_logs(self, append: bool = False, formatter_options: Optional[Dict] = None, **keys):
        &#34;&#34;&#34;Sets logging formatting to JSON.

        Optionally, it can append keyword arguments
        to an existing logger, so it is available across future log statements.

        Last keyword argument and value wins if duplicated.

        Parameters
        ----------
        append : bool, optional
            append keys provided to logger formatter, by default False
        formatter_options : dict, optional
            LambdaPowertoolsFormatter options to be propagated, by default {}
        &#34;&#34;&#34;
        formatter_options = formatter_options or {}

        # There are 3 operational modes for this method
        ## 1. Register a Powertools Formatter for the first time
        ## 2. Append new keys to the current logger formatter; deprecated in favour of append_keys
        ## 3. Add new keys and discard existing to the registered formatter

        # Mode 1
        log_keys = {**self._default_log_keys, **keys}
        is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
        if not is_logger_preconfigured:
            formatter = self.logger_formatter or LambdaPowertoolsFormatter(**formatter_options, **log_keys)  # type: ignore # noqa: E501
            self.registered_handler.setFormatter(formatter)

            # when using a custom Lambda Powertools Formatter
            # standard and custom keys that are not Powertools Formatter parameters should be appended
            # and custom keys that might happen to be Powertools Formatter parameters should be discarded
            # this prevents adding them as custom keys, for example, `json_default=&lt;callable&gt;`
            # see https://github.com/awslabs/aws-lambda-powertools-python/issues/1263
            custom_keys = {k: v for k, v in log_keys.items() if k not in RESERVED_FORMATTER_CUSTOM_KEYS}
            return self.registered_formatter.append_keys(**custom_keys)

        # Mode 2 (legacy)
        if append:
            # Maintenance: Add deprecation warning for major version
            return self.append_keys(**keys)

        # Mode 3
        self.registered_formatter.clear_state()
        self.registered_formatter.append_keys(**log_keys)

    def set_correlation_id(self, value: Optional[str]):
        &#34;&#34;&#34;Sets the correlation_id in the logging json

        Parameters
        ----------
        value : str, optional
            Value for the correlation id. None will remove the correlation_id
        &#34;&#34;&#34;
        self.append_keys(correlation_id=value)

    def get_correlation_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Gets the correlation_id in the logging json

        Returns
        -------
        str, optional
            Value for the correlation id
        &#34;&#34;&#34;
        if isinstance(self.registered_formatter, LambdaPowertoolsFormatter):
            return self.registered_formatter.log_format.get(&#34;correlation_id&#34;)
        return None

    @staticmethod
    def _get_log_level(level: Union[str, int, None]) -&gt; Union[str, int]:
        &#34;&#34;&#34;Returns preferred log level set by the customer in upper case&#34;&#34;&#34;
        if isinstance(level, int):
            return level

        log_level: Optional[str] = level or os.getenv(&#34;LOG_LEVEL&#34;)
        if log_level is None:
            return logging.INFO

        return log_level.upper()

    @staticmethod
    def _get_caller_filename():
        &#34;&#34;&#34;Return caller filename by finding the caller frame&#34;&#34;&#34;
        # Current frame         =&gt; _get_logger()
        # Previous frame        =&gt; logger.py
        # Before previous frame =&gt; Caller
        frame = inspect.currentframe()
        caller_frame = frame.f_back.f_back.f_back
        return caller_frame.f_globals[&#34;__name__&#34;]

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    def findCaller(self, stack_info=False, stacklevel=2):  # pragma: no cover
        &#34;&#34;&#34;
        Find the stack frame of the caller so that we can note the source
        file name, line number and function name.
        &#34;&#34;&#34;
        f = logging.currentframe()  # noqa: VNE001
        # On some versions of IronPython, currentframe() returns None if
        # IronPython isn&#39;t run with -X:Frames.
        if f is None:
            return &#34;(unknown file)&#34;, 0, &#34;(unknown function)&#34;, None
        while stacklevel &gt; 0:
            next_f = f.f_back
            if next_f is None:
                ## We&#39;ve got options here.
                ## If we want to use the last (deepest) frame:
                break
                ## If we want to mimic the warnings module:
                # return (&#34;sys&#34;, 1, &#34;(unknown function)&#34;, None) # noqa: E800
                ## If we want to be pedantic:  # noqa: E800
                # raise ValueError(&#34;call stack is not deep enough&#34;) # noqa: E800
            f = next_f  # noqa: VNE001
            if not _is_internal_frame(f):
                stacklevel -= 1
        co = f.f_code
        sinfo = None
        if stack_info:
            with io.StringIO() as sio:
                sio.write(&#34;Stack (most recent call last):\n&#34;)
                traceback.print_stack(f, file=sio)
                sinfo = sio.getvalue()
                if sinfo[-1] == &#34;\n&#34;:
                    sinfo = sinfo[:-1]
        return co.co_filename, f.f_lineno, co.co_name, sinfo</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Logger</li>
<li>logging.Filterer</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="aws_lambda_powertools.logging.logger.Logger.registered_formatter"><code class="name">var <span class="ident">registered_formatter</span> : <a title="aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter" href="formatter.html#aws_lambda_powertools.logging.formatter.BasePowertoolsFormatter">BasePowertoolsFormatter</a></code></dt>
<dd>
<div class="desc"><p>Convenience property to access logger formatter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def registered_formatter(self) -&gt; BasePowertoolsFormatter:
    &#34;&#34;&#34;Convenience property to access logger formatter&#34;&#34;&#34;
    return self.registered_handler.formatter  # type: ignore</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.registered_handler"><code class="name">var <span class="ident">registered_handler</span> : logging.Handler</code></dt>
<dd>
<div class="desc"><p>Convenience property to access logger handler</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def registered_handler(self) -&gt; logging.Handler:
    &#34;&#34;&#34;Convenience property to access logger handler&#34;&#34;&#34;
    handlers = self._logger.parent.handlers if self.child else self._logger.handlers
    return handlers[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.logger.Logger.append_keys"><code class="name flex">
<span>def <span class="ident">append_keys</span></span>(<span>self, **additional_keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_keys(self, **additional_keys):
    self.registered_formatter.append_keys(**additional_keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.critical"><code class="name flex">
<span>def <span class="ident">critical</span></span>(<span>self, msg: object, *args, exc_info=None, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log 'msg % args' with severity 'CRITICAL'.</p>
<p>To pass exception information, use the keyword argument exc_info with
a true value, e.g.</p>
<p>logger.critical("Houston, we have a %s", "major disaster", exc_info=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def critical(
    self,
    msg: object,
    *args,
    exc_info=None,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.critical(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.critical(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, msg: object, *args, exc_info=None, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log 'msg % args' with severity 'DEBUG'.</p>
<p>To pass exception information, use the keyword argument exc_info with
a true value, e.g.</p>
<p>logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(
    self,
    msg: object,
    *args,
    exc_info=None,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.debug(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.debug(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, msg: object, *args, exc_info=None, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log 'msg % args' with severity 'ERROR'.</p>
<p>To pass exception information, use the keyword argument exc_info with
a true value, e.g.</p>
<p>logger.error("Houston, we have a %s", "major problem", exc_info=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(
    self,
    msg: object,
    *args,
    exc_info=None,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.error(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.error(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, msg: object, *args, exc_info=True, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method for logging an ERROR with exception information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exception(
    self,
    msg: object,
    *args,
    exc_info=True,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.exception(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.exception(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.findCaller"><code class="name flex">
<span>def <span class="ident">findCaller</span></span>(<span>self, stack_info=False, stacklevel=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the stack frame of the caller so that we can note the source
file name, line number and function name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findCaller(self, stack_info=False, stacklevel=2):  # pragma: no cover
    &#34;&#34;&#34;
    Find the stack frame of the caller so that we can note the source
    file name, line number and function name.
    &#34;&#34;&#34;
    f = logging.currentframe()  # noqa: VNE001
    # On some versions of IronPython, currentframe() returns None if
    # IronPython isn&#39;t run with -X:Frames.
    if f is None:
        return &#34;(unknown file)&#34;, 0, &#34;(unknown function)&#34;, None
    while stacklevel &gt; 0:
        next_f = f.f_back
        if next_f is None:
            ## We&#39;ve got options here.
            ## If we want to use the last (deepest) frame:
            break
            ## If we want to mimic the warnings module:
            # return (&#34;sys&#34;, 1, &#34;(unknown function)&#34;, None) # noqa: E800
            ## If we want to be pedantic:  # noqa: E800
            # raise ValueError(&#34;call stack is not deep enough&#34;) # noqa: E800
        f = next_f  # noqa: VNE001
        if not _is_internal_frame(f):
            stacklevel -= 1
    co = f.f_code
    sinfo = None
    if stack_info:
        with io.StringIO() as sio:
            sio.write(&#34;Stack (most recent call last):\n&#34;)
            traceback.print_stack(f, file=sio)
            sinfo = sio.getvalue()
            if sinfo[-1] == &#34;\n&#34;:
                sinfo = sinfo[:-1]
    return co.co_filename, f.f_lineno, co.co_name, sinfo</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.get_correlation_id"><code class="name flex">
<span>def <span class="ident">get_correlation_id</span></span>(<span>self) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the correlation_id in the logging json</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code>, optional</dt>
<dd>Value for the correlation id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_correlation_id(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Gets the correlation_id in the logging json

    Returns
    -------
    str, optional
        Value for the correlation id
    &#34;&#34;&#34;
    if isinstance(self.registered_formatter, LambdaPowertoolsFormatter):
        return self.registered_formatter.log_format.get(&#34;correlation_id&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, msg: object, *args, exc_info=None, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log 'msg % args' with severity 'INFO'.</p>
<p>To pass exception information, use the keyword argument exc_info with
a true value, e.g.</p>
<p>logger.info("Houston, we have a %s", "interesting problem", exc_info=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(
    self,
    msg: object,
    *args,
    exc_info=None,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.info(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.info(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.inject_lambda_context"><code class="name flex">
<span>def <span class="ident">inject_lambda_context</span></span>(<span>self, lambda_handler: Optional[AnyCallableT] = None, log_event: Optional[bool] = None, correlation_id_path: Optional[str] = None, clear_state: Optional[bool] = False) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to capture Lambda contextual info and inject into logger</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clear_state</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs logger to remove any custom keys previously added</dd>
<dt><strong><code>lambda_handler</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method to inject the lambda context</dd>
<dt><strong><code>log_event</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs logger to log Lambda Event, by default False</dd>
<dt><strong><code>correlation_id_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optional JMESPath for the correlation_id</dd>
</dl>
<h2 id="environment-variables">Environment Variables</h2>
<p>POWERTOOLS_LOGGER_LOG_EVENT : str
instruct logger to log Lambda Event (e.g. <code>"true", "True", "TRUE"</code>)</p>
<h2 id="example">Example</h2>
<p><strong>Captures Lambda contextual runtime info (e.g memory, arn, req_id)</strong></p>
<pre><code>from aws_lambda_powertools import Logger

logger = Logger(service="payment")

@logger.inject_lambda_context
def handler(event, context):
    logger.info("Hello")
</code></pre>
<p><strong>Captures Lambda contextual runtime info and logs incoming request</strong></p>
<pre><code>from aws_lambda_powertools import Logger

logger = Logger(service="payment")

@logger.inject_lambda_context(log_event=True)
def handler(event, context):
    logger.info("Hello")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>decorate</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Decorated lambda handler</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_lambda_context(
    self,
    lambda_handler: Optional[AnyCallableT] = None,
    log_event: Optional[bool] = None,
    correlation_id_path: Optional[str] = None,
    clear_state: Optional[bool] = False,
) -&gt; Any:
    &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into logger

    Parameters
    ----------
    clear_state : bool, optional
        Instructs logger to remove any custom keys previously added
    lambda_handler : Callable
        Method to inject the lambda context
    log_event : bool, optional
        Instructs logger to log Lambda Event, by default False
    correlation_id_path: str, optional
        Optional JMESPath for the correlation_id

    Environment variables
    ---------------------
    POWERTOOLS_LOGGER_LOG_EVENT : str
        instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

    Example
    -------
    **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

        from aws_lambda_powertools import Logger

        logger = Logger(service=&#34;payment&#34;)

        @logger.inject_lambda_context
        def handler(event, context):
            logger.info(&#34;Hello&#34;)

    **Captures Lambda contextual runtime info and logs incoming request**

        from aws_lambda_powertools import Logger

        logger = Logger(service=&#34;payment&#34;)

        @logger.inject_lambda_context(log_event=True)
        def handler(event, context):
            logger.info(&#34;Hello&#34;)

    Returns
    -------
    decorate : Callable
        Decorated lambda handler
    &#34;&#34;&#34;

    # If handler is None we&#39;ve been called with parameters
    # Return a partial function with args filled
    if lambda_handler is None:
        logger.debug(&#34;Decorator called with parameters&#34;)
        return functools.partial(
            self.inject_lambda_context,
            log_event=log_event,
            correlation_id_path=correlation_id_path,
            clear_state=clear_state,
        )

    log_event = resolve_truthy_env_var_choice(
        env=os.getenv(constants.LOGGER_LOG_EVENT_ENV, &#34;false&#34;), choice=log_event
    )

    @functools.wraps(lambda_handler)
    def decorate(event, context, *args, **kwargs):
        lambda_context = build_lambda_context_model(context)
        cold_start = _is_cold_start()

        if clear_state:
            self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
        else:
            self.append_keys(cold_start=cold_start, **lambda_context.__dict__)

        if correlation_id_path:
            self.set_correlation_id(jmespath.search(correlation_id_path, event))

        if log_event:
            logger.debug(&#34;Event received&#34;)
            self.info(extract_event_from_common_models(event))

        return lambda_handler(event, context, *args, **kwargs)

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.remove_keys"><code class="name flex">
<span>def <span class="ident">remove_keys</span></span>(<span>self, keys: Iterable[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keys(self, keys: Iterable[str]):
    self.registered_formatter.remove_keys(keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.set_correlation_id"><code class="name flex">
<span>def <span class="ident">set_correlation_id</span></span>(<span>self, value: Optional[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the correlation_id in the logging json</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Value for the correlation id. None will remove the correlation_id</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_correlation_id(self, value: Optional[str]):
    &#34;&#34;&#34;Sets the correlation_id in the logging json

    Parameters
    ----------
    value : str, optional
        Value for the correlation id. None will remove the correlation_id
    &#34;&#34;&#34;
    self.append_keys(correlation_id=value)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.structure_logs"><code class="name flex">
<span>def <span class="ident">structure_logs</span></span>(<span>self, append: bool = False, formatter_options: Optional[Dict] = None, **keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets logging formatting to JSON.</p>
<p>Optionally, it can append keyword arguments
to an existing logger, so it is available across future log statements.</p>
<p>Last keyword argument and value wins if duplicated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>append</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>append keys provided to logger formatter, by default False</dd>
<dt><strong><code>formatter_options</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>LambdaPowertoolsFormatter options to be propagated, by default {}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structure_logs(self, append: bool = False, formatter_options: Optional[Dict] = None, **keys):
    &#34;&#34;&#34;Sets logging formatting to JSON.

    Optionally, it can append keyword arguments
    to an existing logger, so it is available across future log statements.

    Last keyword argument and value wins if duplicated.

    Parameters
    ----------
    append : bool, optional
        append keys provided to logger formatter, by default False
    formatter_options : dict, optional
        LambdaPowertoolsFormatter options to be propagated, by default {}
    &#34;&#34;&#34;
    formatter_options = formatter_options or {}

    # There are 3 operational modes for this method
    ## 1. Register a Powertools Formatter for the first time
    ## 2. Append new keys to the current logger formatter; deprecated in favour of append_keys
    ## 3. Add new keys and discard existing to the registered formatter

    # Mode 1
    log_keys = {**self._default_log_keys, **keys}
    is_logger_preconfigured = getattr(self._logger, &#34;init&#34;, False)
    if not is_logger_preconfigured:
        formatter = self.logger_formatter or LambdaPowertoolsFormatter(**formatter_options, **log_keys)  # type: ignore # noqa: E501
        self.registered_handler.setFormatter(formatter)

        # when using a custom Lambda Powertools Formatter
        # standard and custom keys that are not Powertools Formatter parameters should be appended
        # and custom keys that might happen to be Powertools Formatter parameters should be discarded
        # this prevents adding them as custom keys, for example, `json_default=&lt;callable&gt;`
        # see https://github.com/awslabs/aws-lambda-powertools-python/issues/1263
        custom_keys = {k: v for k, v in log_keys.items() if k not in RESERVED_FORMATTER_CUSTOM_KEYS}
        return self.registered_formatter.append_keys(**custom_keys)

    # Mode 2 (legacy)
    if append:
        # Maintenance: Add deprecation warning for major version
        return self.append_keys(**keys)

    # Mode 3
    self.registered_formatter.clear_state()
    self.registered_formatter.append_keys(**log_keys)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, msg: object, *args, exc_info=None, stack_info: bool = False, stacklevel: int = 2, extra: Optional[Mapping[str, object]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log 'msg % args' with severity 'WARNING'.</p>
<p>To pass exception information, use the keyword argument exc_info with
a true value, e.g.</p>
<p>logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warning(
    self,
    msg: object,
    *args,
    exc_info=None,
    stack_info: bool = False,
    stacklevel: int = 2,
    extra: Optional[Mapping[str, object]] = None,
    **kwargs,
):
    extra = extra or {}
    extra = {**extra, **kwargs}

    # Maintenance: We can drop this upon Py3.7 EOL. It&#39;s a backport for &#34;location&#34; key to work
    if sys.version_info &lt; (3, 8):  # pragma: no cover
        return self._logger.warning(msg, *args, exc_info=exc_info, stack_info=stack_info, extra=extra)
    return self._logger.warning(
        msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.logging" href="index.html">aws_lambda_powertools.logging</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.logger.log_uncaught_exception_hook" href="#aws_lambda_powertools.logging.logger.log_uncaught_exception_hook">log_uncaught_exception_hook</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.set_package_logger" href="#aws_lambda_powertools.logging.logger.set_package_logger">set_package_logger</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.logging.logger.Logger" href="#aws_lambda_powertools.logging.logger.Logger">Logger</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.append_keys" href="#aws_lambda_powertools.logging.logger.Logger.append_keys">append_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.critical" href="#aws_lambda_powertools.logging.logger.Logger.critical">critical</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.debug" href="#aws_lambda_powertools.logging.logger.Logger.debug">debug</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.error" href="#aws_lambda_powertools.logging.logger.Logger.error">error</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.exception" href="#aws_lambda_powertools.logging.logger.Logger.exception">exception</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.findCaller" href="#aws_lambda_powertools.logging.logger.Logger.findCaller">findCaller</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.get_correlation_id" href="#aws_lambda_powertools.logging.logger.Logger.get_correlation_id">get_correlation_id</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.info" href="#aws_lambda_powertools.logging.logger.Logger.info">info</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.inject_lambda_context" href="#aws_lambda_powertools.logging.logger.Logger.inject_lambda_context">inject_lambda_context</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.registered_formatter" href="#aws_lambda_powertools.logging.logger.Logger.registered_formatter">registered_formatter</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.registered_handler" href="#aws_lambda_powertools.logging.logger.Logger.registered_handler">registered_handler</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.remove_keys" href="#aws_lambda_powertools.logging.logger.Logger.remove_keys">remove_keys</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.set_correlation_id" href="#aws_lambda_powertools.logging.logger.Logger.set_correlation_id">set_correlation_id</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.structure_logs" href="#aws_lambda_powertools.logging.logger.Logger.structure_logs">structure_logs</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.warning" href="#aws_lambda_powertools.logging.logger.Logger.warning">warning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>